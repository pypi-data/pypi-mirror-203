# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pydantic_dynamo', 'pydantic_dynamo.v2']

package_data = \
{'': ['*']}

install_requires = \
['aioboto3>=11.1.0,<12.0.0',
 'boto3>=1.20.32,<2.0.0',
 'botocore>=1.23.32,<2.0.0',
 'pydantic>=1.10.5,<2.0.0']

setup_kwargs = {
    'name': 'pydantic-dynamo',
    'version': '0.2.0',
    'description': '',
    'long_description': '# pydantic-dynamo\nA Python repository over DynamoDB, leveraging the excellent \n[Pydantic](https://docs.pydantic.dev/) library to model records.\n\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\n## Contributing\n\nPlease see [the contributing guide](./contributing.md).\n\n## Installation\nInstall from PyPI:\n```\npip install pydantic-dynamo\n```\n\nOr even better, use [Poetry](https://python-poetry.org/docs/):\n```\npoetry add pydantic-dynamo\n```\n\n## Usage\n\nThe ideal consumer a developer of a low-to-medium complexity application. You will lose\nsome benefits of the single-table pattern, specifically the ability to query\nand retrieve objects of different types in a single connection. Except the most complex single-table examples, \naccess patterns can be implemented to utilize the `list`/`list_between`\nand `get_batch` functions, documented below, to prevent N+1 queries and provide sufficient performance.\n\n\n### Table Creation\n\nThis package assumes the specified table already exists and the application it is\nrunning from has sufficient access to the table.\n\nThe following IAM permissions are required:\n\n```yaml\n- dynamodb:BatchGetItem\n- dynamodb:BatchWriteItem\n- dynamodb:GetItem\n- dynamodb:PutItem\n- dynamodb:Query\n- dynamodb:UpdateItem\n```\n\n### Modeling\nCreate a Pydantic model specifically for storage. This should generally not be shared\nin API contracts or other external interfaces to adhere to single-responsibility principle.\n\n```python\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass FilmActor(BaseModel):\n    id: str\n    name: str\n    review: Optional[str]\n    \n```\n\n#### Reserved Attribute Names\nThis package implicitly uses the following attributes, and therefore they should not be used in any\nobject model classes.\n\n| Attribute            | Usage                                                                                                                   |\n|----------------------|-------------------------------------------------------------------------------------------------------------------------|\n| `_table_item_id`     | Default Partition Key name, can be overridden in repository instantiation. *Not a default in v2*                        |\n| `_table_content_id`  | Default Sort Key name, can be overridden in repository instantiation. *Not a default in v2*                             |\n| `_timestamp`         | Automatic ISO-formatted timestamp for when record was created or updated                                                |\n| `_object_version`    | Internal object versioning integer, automatically incremented on update, and can be used to enforce conditional updates |\n| `_ttl`               | Optionally used to store the DynamoDB TTL expiry value, which must be declared in the table\'s `TimeToLiveSpecification` |\n\n\n## Version 1 (Deprecated)\nThe original repository implementation that still exists but will no longer receive updates.\nThis will be removed in a future release.\n\n[V1 Documentation](./docs/v1.md) has been moved to keep the main README a reasonable size.\n\n## Version 2 (Experimental)\nThis is the implementation that is intended for longer-term maintenance and will receive updates.\n\n### Instantiation\nV2 removes the `build` convenience function found in V1 and provides only a `__init__` constructor. Since V2 is async-first\nthe table and resource objects need to be constructed from [aioboto3](https://aioboto3.readthedocs.io/en/latest/usage.html#dynamodb-examples)\n\nA working example can be found in the [integration tests conftest.py](./tests/test_integration/conftest.py)\n\n```python\nfrom aioboto3 import Session\nfrom pydantic_dynamo.v2.repository import DynamoRepository\nfrom tests.models import Example # Use your record model instead\n\nsession = Session()\nboto3_kwargs = {"service_name": "dynamodb"} # endpoint_url, region_name, etc.\nasync with session.resource(**boto3_kwargs) as resource:\n    repo = DynamoRepository[Example](\n        item_class=Example,\n        partition_prefix="test",\n        partition_name="integration",\n        content_type="example",\n        table_name="table_name",\n        partition_key="PARTITION_KEY",\n        sort_key="SORT_KEY",\n        table=await resource.Table("table_name"),\n        resource=resource,\n    )\n```\n\nThere is also a synchronous variant that can be used if you don\'t want to work with async/await and async generators\nin your business code. Most of the subsequent documentation is focused on the async variant.\n\n```python\nfrom aioboto3 import Session\nfrom pydantic_dynamo.v2.repository import DynamoRepository\nfrom pydantic_dynamo.v2.sync_repository import SyncDynamoRepository\nfrom tests.models import Example # Use your record model instead\n\nsession = Session()\nboto3_kwargs = {"service_name": "dynamodb"} # endpoint_url, region_name, etc.\nasync with session.resource(**boto3_kwargs) as resource:\n    repo = DynamoRepository[Example](\n        item_class=Example,\n        partition_prefix="test",\n        partition_name="integration",\n        content_type="example",\n        table_name="table_name",\n        partition_key="PARTITION_KEY",\n        sort_key="SORT_KEY",\n        table=await resource.Table("table_name"),\n        resource=resource,\n    )\n\n    sync_repo = SyncDynamoRepository[Example](async_repo=repo)\n```\n### Saving Data\n\nData is saved using an instance of the generic `PartitionedContent[ObjT]` class found in \n[models.py](./pydantic_dynamo/models.py). The `partition_ids` and `content_ids` are `List[str]`. \nEach value in the list is concatenated before saving, and prefixed with the repository\'s configured values.\n\nFor the `content_ids` field, you can leverage this to achieve degrees of query-ability for\nmore complex use cases, eg: `content_ids=["usa", "ny", "saratoga", "12020"]` will result in a \nsort key value of `usa#ny#saratoga#12020` that can be efficiently queried with DynamoDB\'s `begins_with`\ncondition, utilized in this library\'s `list` function.\n\nIt\'s wise to ensure that any values being used in the partition and content IDs are also retained as \nfields on the model object as well, which will make updates easier to perform. *This is less critical now\nsince the V2 responses include reified `PartitionedContent[ObjT]` objects instead of just the modeled records in V1.*\n\n#### Put Single Item\n\nThis leverages the DynamoDB Put operation, and will overwrite an existing item with identical partition and content IDs.\n\n```python\nfrom pydantic_dynamo.models import PartitionedContent\nfrom uuid import uuid4\n\nid1 = str(uuid4())\nactor1 = FilmActor(id=id1, name="Daniel Day-Lewis")\n\nawait repo.put(\n    PartitionedContent[FilmActor](\n        partition_ids=[], content_ids=[id1], item=actor1\n    )\n)\n```\n\n#### Put Multiple Items\n\nWhen saving more than one item, you can use a batch operation that will utilize DynamoDB\'s `write_batch` \noperation, which will more efficiently buffer data and minimize the total number of network calls compared to calling\n`put` in a loop.\n\n```python\nfrom pydantic_dynamo.models import PartitionedContent\nfrom uuid import uuid4\n\nid1 = str(uuid4())\nactor1 = FilmActor(id=id1, name="Daniel Day-Lewis")\nid2 = str(uuid4())\nactor2 = FilmActor(id=id2, name="Steve Buscemi")\n\n\nawait repo.put_batch(\n    (\n        PartitionedContent[FilmActor](\n            partition_ids=[], content_ids=[id1], item=actor1\n        ),\n        PartitionedContent[FilmActor](\n            partition_ids=[], content_ids=[id2], item=actor2\n        ),\n    )\n)\n```\n\n#### Update an item\n\nNB: Please review the limitation in [issue #1](https://github.com/david-a-jetter/pydantic-dynamo/issues/1)\n\nUpdates are handled in a somewhat more complex and manual manner using an `UpdateCommand` object. \nSince this is constructed by sending `Dict[str, Any]`, dictionary entries are validated against\nthe pydantic model\'s schema before sending data to DynamoDB.\n\n`set_commands` can be used to map attributes\' names to a new value.\n`increment_attrs` can be used to increment attributes\' current values by some integer.\n`append_attrs` can be used to extend a `List` attribute\'s values\n\n`current_version` can be used to enforce a check on the object\'s version number to\nadhere to an object versioning pattern. \n\n\n```python\nfrom pydantic_dynamo.models import UpdateCommand\n\nawait repo.update(\n    partition_id=None,\n    content_id=[id1],\n    command=UpdateCommand(\n        set_commands={"review": "Talented, but unfriendly in Gangs of New York"}\n    )\n)\n\n```\n\n\n### Reading Data\n\n#### Get Item\n\nFinally, something simple to document. This gets a single item by its partition and content IDs,\nreturning `None` if no item is found.\n\nThis example would retrieve just the first actor item.\n```python\nfrom typing import Optional\nfrom pydantic_dynamo.models import PartitionedContent\n\nitem: Optional[PartitionedContent[FilmActor]] = await repo.get(partition_id=None, content_id=[id1])\n```\n\n#### Reading Multiple Items\n\nThis and all subsequent read operations return `AsyncIterable[BatchResponse[ObjT]]` references. These cannot be directly awaited,\nbut rather need to be iterated in an async loop. See [PEP-525](https://peps.python.org/pep-0525/) for details and this\nrepository\'s tests for complete examples.\n\nMost DynamoDB batch operations implement a continuation token pattern, where the API will return a subset of the data\nthat matches the parameters up to some stored size (eg. 1MB) and then includes a continuation token to use in a subsequent\nAPI call.\n\nA single `BatchResponse[ObjT]` represents one API response from DynamoDB, and contains an `Iterable[ObjT]` reference. This leaves\nyou as the consumer in complete control whether you should lazily stream the records or project them all into a list.\n\n#### Get Batch by Key\n\nThis leverages DynamoDB\'s `batch_get_item` API to collect multiple items by their partition and content IDs.\nThis is often useful after having collected a previous set of records that have potentially related\nitems that you want to retrieve, and then associate the two in a subsequent mapping logic layer.\n\nThis example would retrieve both actor items in a single network request.\n```python\nfrom typing import List\nfrom pydantic_dynamo.models import PartitionedContent\n\nitems: List[PartitionedContent[FilmActor]] = [\n    content \n    async for response in repo.get_batch([(None, [id1]), (None, [id2])])\n    for content in response.contents                      \n]\n```\n\n#### Listing Items\nThe following two functions leverage DynamoDB\'s `query` API and offers the ability \nto filter on partial content ID values, change sort order, limit the quantity of items.\n\nThese operations support optional kwargs: \n* `limit` integer to cap the number of records returned\n* `sort_ascending` boolean to change sort order based on the sort key value, which defaults to `True`\n\n##### Filtering\n\nYou may also pass an optional `FilterCommand` to filter on non-key attributes. All fields\non this object are optional, and are applied utilizing `and` logic.\n\n```python\nfrom pydantic_dynamo.models import FilterCommand\n\n# Find actors without a `review` attribute\nfilter1 = FilterCommand(\n    not_exists={"review"}\n)\n\n# Find actors who are talented but unfriendly in Gangs of New York\nfilter2 = FilterCommand(\n    equals={"review": "Talented, but unfriendly in Gangs of New York"}\n)\n\n# Find actors who are not talented but unfriendly in Gangs of New York\nfilter3 = FilterCommand(\n    not_equals={"review": "Talented, but unfriendly in Gangs of New York"}\n)\n\n```\n\nThese operations are more interesting with a more complex data model, so let\'s pretend there might be \nmore than one opinion on a given actor, so we\'ll store many reviews instead of just my own.\n\nLet\'s define a review model that can be related to an actor:\n```python\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nclass ActorReview(BaseModel):\n    id: str\n    actor_id: str\n    created: datetime\n    review: str\n```\n\nand then pretend we save a few of them:\n\n```python\nfrom datetime import datetime, timezone\nfrom uuid import uuid4\n\nnow = datetime.now(tz=timezone.utc)\n\nawait repo.put_batch(\n    (\n        PartitionedContent[ActorReview](\n            partition_ids=[actor1.id],\n            content_ids=[now.isoformat()],\n            item=ActorReview(\n                id=str(uuid4()),\n                actor_id=actor1.id,\n                created=now,\n                review="I really thought he was the hero of this movie"\n            )\n        ),\n        PartitionedContent[ActorReview](\n            partition_ids=[actor1.id],\n            content_ids=[now.isoformat()],\n            item=ActorReview(\n                id=str(uuid4()),\n                actor_id=actor1.id,\n                created=now,\n                review="He really embodies the New York state of mind"\n            )\n        )\n    )\n)\n```\n\n##### List\nThis function supports filter items with a `begins_with` filter on their content IDs.\n\nThis example would retrieve all review items for `actor1` that we previously saved.\n```python\nfrom typing import List\nfrom pydantic_dynamo.models import PartitionedContent\n\nitems: List[PartitionedContent[ActorReview]] = [\n    content\n    async for response in repo.list(\n        partition_id=[actor1.id],\n        content_prefix=None,\n        sort_ascending=True,\n        limit=None,\n        filters=None\n    )\n    for content in response.contents\n]\n```\n\nThis example would retrieve all of the reviews created on a given year, because ISO-formatted datetime\nvalues are lexicographically sortable.\n```python\nfrom typing import List\nfrom pydantic_dynamo.models import PartitionedContent\n\nitems: List[PartitionedContent[ActorReview]] = [\n    content\n    async for response in repo.list(\n        partition_id=[actor1.id],\n        content_prefix=["2023"],\n        sort_ascending=True,\n        limit=None,\n        filters=None\n    )\n    for content in response.contents\n]\n```\n\n##### List Between\nThis function supports filter items with a `between` filter on their content IDs.\n\nNB: If `content_start == content_end` this will revert to calling `list` using `begins_with`. This prevents\nunexpected behavior of returning no records due to how Dynamo\'s Query API handles `between` conditions.\n\nThis example would retrieve all reviews for actor1 that were created in or after January 2023 *and* in or before March 2023.\n```python\nfrom typing import List\nfrom pydantic_dynamo.models import PartitionedContent\n\nitems: List[PartitionedContent[[FilmActor]] = [\n    content\n    async for response in repo.list_between(\n        partition_id=[actor1.id],\n        content_start=["2023-01"],\n        content_end=["2023-04"],\n        sort_ascending=True,\n        limit=None,\n        filters=None\n    )\n    for content in response.contents\n]\n```\n',
    'author': 'David Jetter',
    'author_email': 'davidajetter@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/david-a-jetter/pydantic-dynamo',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
