Metadata-Version: 2.1
Name: acryo
Version: 0.2.3
Summary: An extensible cryo-EM/ET toolkit for Python.
Author: Hanjin Liu
Author-email: liuhanjin-sc@g.ecc.u-tokyo.ac.jp
License: BSD 3-Clause
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy (>=1.21)
Requires-Dist: scipy (>=1.7.3)
Requires-Dist: polars (>=0.17.3)
Requires-Dist: dask (>=2021.6.0)
Requires-Dist: typing-extensions (>=4.1.1)

[![Python package index download statistics](https://img.shields.io/pypi/dm/acryo.svg)](https://pypistats.org/packages/acryo)
[![PyPI version](https://badge.fury.io/py/acryo.svg)](https://badge.fury.io/py/acryo)

# acryo

`acryo` is an extensible cryo-EM/ET toolkit for Python.

The purpose of this library is to make data analysis of cryo-EM/ET more safe, efficient and reproducible.
Scientists can avoid the error-prone CLI-based data handling, such as writing out the results to the files every time and manage all the result just by the file names.

[祷 Documentation](https://hanjinliu.github.io/acryo/)

### Install

###### Use pip

```bash
pip install acryo -U
```

###### From source

```bash
git clone git+https://github.com/hanjinliu/acryo.git
```

### Features

1. Out-of-core and parallel processing during subtomogram averaging/alignment to make full use of CPU.
2. Extensible and ready-to-use alignment models.
3. Manage subtomogram loading tasks from single or multiple tomograms in the same API.
4. Tomogram simulation.
5. Masked PCA clustering.

### Code Snippet

```Python
import polars as pl
from acryo import SubtomogramLoader, Molecules  # acryo objects
from acryo.pipe import soft_otsu  # data input pipelines

# construct a loader
loader = SubtomogramLoader.imread(
    "path/to/tomogram.mrc",
    molecules=Molecules.from_csv("path/to/molecules.csv"),
)

# filter out bad alignment in polars way
loader_filt = loader.filter(pl.col("score") > 0.7)

# averaging
avg = loader_filt.average(output_shape=(48, 48, 48))

# alignment
aligned_loader = loader.align(
    template=avg,                       # use the average as template
    mask=soft_otsu(sigma=2, radius=2),  # apply soft-Otsu to template to make the mask
    tilt_range=(-50, 50),               # range of tilt series degrees.
    cutoff=0.5,                         # lowpass filtering cutoff
    max_shifts=(4, 4, 4),               # search space limits
)

```
