from __future__ import annotations
import dataclasses
from os import path
import os
import shutil
import jinja2

from psql2py import common


GENERATED_COMMENT = "# Generated by psql2py"

class OutputDirectoryDoesNotExistError(Exception):
    pass


class OutputFileExistError(Exception):
    pass


@dataclasses.dataclass
class TypedStatement:
    name: str
    docstring: str
    sql: str
    args: list[common.TypedIdentifier]
    returns: list[common.TypedIdentifier]

    def imports(self) -> list[str]:
        return sum((type_.imports() for type_ in self.args + self.returns), start=[])



@dataclasses.dataclass
class Module:
    name: str
    statements: list[TypedStatement]

    def imports(self) -> list[str]:
        return sorted(
            set(sum((statement.imports() for statement in self.statements), start=[]))
        )
    
    def file_name(self) -> str:
        return self.name + ".py"
    
    def is_module(self) -> bool:
        return True

    def is_package(self) -> bool:
        return False


@dataclasses.dataclass
class Package:
    name: str
    sub_packages: list[Package]
    sub_modules: list[Module]

    def file_name(self) -> str:
        return self.name
    
    def is_module(self) -> bool:
        return False

    def is_package(self) -> bool:
        return True


def _is_generated(file_or_dir: str) -> bool:
    if path.isfile(file_or_dir):
        with open(file_or_dir) as file_:
            return file_.read().startswith(GENERATED_COMMENT)
    if not path.isdir(file_or_dir):
        return False
    init_file = path.join(file_or_dir, "__init__.py")
    if not path.isfile(init_file):
        return False
    with open(init_file) as file_:
        return file_.read().startswith(GENERATED_COMMENT)


def _clean(target_file_or_dir: str) -> None:
    assert _is_generated(target_file_or_dir)

    if path.isdir(target_file_or_dir):
        shutil.rmtree(target_file_or_dir)
    else:
        os.remove(target_file_or_dir)


def package_or_module(
    package_or_module: Package | Module, output_path: str
) -> None:
    if not path.isdir(output_path):
        raise OutputDirectoryDoesNotExistError()
    
    target_file = path.join(output_path, package_or_module.file_name())
    if path.exists(target_file):
        if _is_generated(target_file):
            _clean(target_file)
        else:
            raise OutputFileExistError()
    
    if isinstance(package_or_module, Package):
        _generate_package(package_or_module, output_path)
    else:
        _generate_module(package_or_module, output_path)


def _generate_module(module: Module, output_path: str) -> None:
    assert path.isdir(output_path)

    with open(path.join(output_path, module.file_name()), "w") as module_file:
        module_file.write(GENERATED_COMMENT + "\n")
        module_file.write(_render_module(module))


def _generate_package(package: Package, output_path: str) -> None:
    assert path.isdir(output_path)

    package_dir = path.join(output_path, package.file_name())
    os.mkdir(package_dir)

    with open(path.join(package_dir, "__init__.py"), "w") as init_file:
        init_file.write(GENERATED_COMMENT)

    for sub_package in package.sub_packages:
        _generate_package(sub_package, package_dir)
    for sub_module in package.sub_modules:
        _generate_module(sub_module, package_dir)


def _render_module(module: Module) -> str:
    env = jinja2.Environment(
        loader=jinja2.PackageLoader("psql2py", "templates"),
    )
    template = env.get_template("module.py.jinja")
    return template.render({"module": module})
