# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _l_master
else:
    import _l_master

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _l_master.delete_SwigPyIterator

    def value(self):
        return _l_master.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _l_master.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _l_master.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _l_master.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _l_master.SwigPyIterator_equal(self, x)

    def copy(self):
        return _l_master.SwigPyIterator_copy(self)

    def next(self):
        return _l_master.SwigPyIterator_next(self)

    def __next__(self):
        return _l_master.SwigPyIterator___next__(self)

    def previous(self):
        return _l_master.SwigPyIterator_previous(self)

    def advance(self, n):
        return _l_master.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _l_master.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _l_master.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _l_master.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _l_master.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _l_master.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _l_master.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _l_master:
_l_master.SwigPyIterator_swigregister(SwigPyIterator)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _l_master.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _l_master.DoubleVector___bool__(self)

    def __len__(self):
        return _l_master.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _l_master.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _l_master.DoubleVector_pop(self)

    def append(self, x):
        return _l_master.DoubleVector_append(self, x)

    def empty(self):
        return _l_master.DoubleVector_empty(self)

    def size(self):
        return _l_master.DoubleVector_size(self)

    def swap(self, v):
        return _l_master.DoubleVector_swap(self, v)

    def begin(self):
        return _l_master.DoubleVector_begin(self)

    def end(self):
        return _l_master.DoubleVector_end(self)

    def rbegin(self):
        return _l_master.DoubleVector_rbegin(self)

    def rend(self):
        return _l_master.DoubleVector_rend(self)

    def clear(self):
        return _l_master.DoubleVector_clear(self)

    def get_allocator(self):
        return _l_master.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _l_master.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _l_master.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _l_master.DoubleVector_swiginit(self, _l_master.new_DoubleVector(*args))

    def push_back(self, x):
        return _l_master.DoubleVector_push_back(self, x)

    def front(self):
        return _l_master.DoubleVector_front(self)

    def back(self):
        return _l_master.DoubleVector_back(self)

    def assign(self, n, x):
        return _l_master.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _l_master.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _l_master.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _l_master.DoubleVector_reserve(self, n)

    def capacity(self):
        return _l_master.DoubleVector_capacity(self)
    __swig_destroy__ = _l_master.delete_DoubleVector

# Register DoubleVector in _l_master:
_l_master.DoubleVector_swigregister(DoubleVector)

class CartArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def iterator(self):
        return _l_master.CartArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.CartArray___nonzero__(self)

    def __bool__(self):
        return _l_master.CartArray___bool__(self)

    def __len__(self):
        return _l_master.CartArray___len__(self)

    def __getslice__(self, i, j):
        return _l_master.CartArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.CartArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.CartArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.CartArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.CartArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.CartArray___setitem__(self, *args)

    def __init__(self, *args):
        _l_master.CartArray_swiginit(self, _l_master.new_CartArray(*args))

    def empty(self):
        return _l_master.CartArray_empty(self)

    def size(self):
        return _l_master.CartArray_size(self)

    def swap(self, v):
        return _l_master.CartArray_swap(self, v)

    def begin(self):
        return _l_master.CartArray_begin(self)

    def end(self):
        return _l_master.CartArray_end(self)

    def rbegin(self):
        return _l_master.CartArray_rbegin(self)

    def rend(self):
        return _l_master.CartArray_rend(self)

    def front(self):
        return _l_master.CartArray_front(self)

    def back(self):
        return _l_master.CartArray_back(self)

    def fill(self, u):
        return _l_master.CartArray_fill(self, u)

    def __repr__(self):
        return _l_master.CartArray___repr__(self)
    __swig_destroy__ = _l_master.delete_CartArray

# Register CartArray in _l_master:
_l_master.CartArray_swigregister(CartArray)

class CartesianPose(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def iterator(self):
        return _l_master.CartesianPose_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.CartesianPose___nonzero__(self)

    def __bool__(self):
        return _l_master.CartesianPose___bool__(self)

    def __len__(self):
        return _l_master.CartesianPose___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _l_master.CartesianPose___getitem__(self, key)

    def __delitem__(self, key):
        return _l_master.CartesianPose___delitem__(self, key)

    def has_key(self, key):
        return _l_master.CartesianPose_has_key(self, key)

    def keys(self):
        return _l_master.CartesianPose_keys(self)

    def values(self):
        return _l_master.CartesianPose_values(self)

    def items(self):
        return _l_master.CartesianPose_items(self)

    def __contains__(self, key):
        return _l_master.CartesianPose___contains__(self, key)

    def key_iterator(self):
        return _l_master.CartesianPose_key_iterator(self)

    def value_iterator(self):
        return _l_master.CartesianPose_value_iterator(self)

    def __setitem__(self, *args):
        return _l_master.CartesianPose___setitem__(self, *args)

    def asdict(self):
        return _l_master.CartesianPose_asdict(self)

    def __init__(self, *args):
        _l_master.CartesianPose_swiginit(self, _l_master.new_CartesianPose(*args))

    def empty(self):
        return _l_master.CartesianPose_empty(self)

    def size(self):
        return _l_master.CartesianPose_size(self)

    def swap(self, v):
        return _l_master.CartesianPose_swap(self, v)

    def begin(self):
        return _l_master.CartesianPose_begin(self)

    def end(self):
        return _l_master.CartesianPose_end(self)

    def rbegin(self):
        return _l_master.CartesianPose_rbegin(self)

    def rend(self):
        return _l_master.CartesianPose_rend(self)

    def clear(self):
        return _l_master.CartesianPose_clear(self)

    def get_allocator(self):
        return _l_master.CartesianPose_get_allocator(self)

    def count(self, x):
        return _l_master.CartesianPose_count(self, x)

    def erase(self, *args):
        return _l_master.CartesianPose_erase(self, *args)

    def find(self, x):
        return _l_master.CartesianPose_find(self, x)

    def lower_bound(self, x):
        return _l_master.CartesianPose_lower_bound(self, x)

    def upper_bound(self, x):
        return _l_master.CartesianPose_upper_bound(self, x)

    def __repr__(self):
        return _l_master.CartesianPose___repr__(self)
    __swig_destroy__ = _l_master.delete_CartesianPose

# Register CartesianPose in _l_master:
_l_master.CartesianPose_swigregister(CartesianPose)

class UintVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _l_master.UintVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.UintVector___nonzero__(self)

    def __bool__(self):
        return _l_master.UintVector___bool__(self)

    def __len__(self):
        return _l_master.UintVector___len__(self)

    def __getslice__(self, i, j):
        return _l_master.UintVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.UintVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.UintVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.UintVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.UintVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.UintVector___setitem__(self, *args)

    def pop(self):
        return _l_master.UintVector_pop(self)

    def append(self, x):
        return _l_master.UintVector_append(self, x)

    def empty(self):
        return _l_master.UintVector_empty(self)

    def size(self):
        return _l_master.UintVector_size(self)

    def swap(self, v):
        return _l_master.UintVector_swap(self, v)

    def begin(self):
        return _l_master.UintVector_begin(self)

    def end(self):
        return _l_master.UintVector_end(self)

    def rbegin(self):
        return _l_master.UintVector_rbegin(self)

    def rend(self):
        return _l_master.UintVector_rend(self)

    def clear(self):
        return _l_master.UintVector_clear(self)

    def get_allocator(self):
        return _l_master.UintVector_get_allocator(self)

    def pop_back(self):
        return _l_master.UintVector_pop_back(self)

    def erase(self, *args):
        return _l_master.UintVector_erase(self, *args)

    def __init__(self, *args):
        _l_master.UintVector_swiginit(self, _l_master.new_UintVector(*args))

    def push_back(self, x):
        return _l_master.UintVector_push_back(self, x)

    def front(self):
        return _l_master.UintVector_front(self)

    def back(self):
        return _l_master.UintVector_back(self)

    def assign(self, n, x):
        return _l_master.UintVector_assign(self, n, x)

    def resize(self, *args):
        return _l_master.UintVector_resize(self, *args)

    def insert(self, *args):
        return _l_master.UintVector_insert(self, *args)

    def reserve(self, n):
        return _l_master.UintVector_reserve(self, n)

    def capacity(self):
        return _l_master.UintVector_capacity(self)
    __swig_destroy__ = _l_master.delete_UintVector

# Register UintVector in _l_master:
_l_master.UintVector_swigregister(UintVector)

class StrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _l_master.StrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.StrVector___nonzero__(self)

    def __bool__(self):
        return _l_master.StrVector___bool__(self)

    def __len__(self):
        return _l_master.StrVector___len__(self)

    def __getslice__(self, i, j):
        return _l_master.StrVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.StrVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.StrVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.StrVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.StrVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.StrVector___setitem__(self, *args)

    def pop(self):
        return _l_master.StrVector_pop(self)

    def append(self, x):
        return _l_master.StrVector_append(self, x)

    def empty(self):
        return _l_master.StrVector_empty(self)

    def size(self):
        return _l_master.StrVector_size(self)

    def swap(self, v):
        return _l_master.StrVector_swap(self, v)

    def begin(self):
        return _l_master.StrVector_begin(self)

    def end(self):
        return _l_master.StrVector_end(self)

    def rbegin(self):
        return _l_master.StrVector_rbegin(self)

    def rend(self):
        return _l_master.StrVector_rend(self)

    def clear(self):
        return _l_master.StrVector_clear(self)

    def get_allocator(self):
        return _l_master.StrVector_get_allocator(self)

    def pop_back(self):
        return _l_master.StrVector_pop_back(self)

    def erase(self, *args):
        return _l_master.StrVector_erase(self, *args)

    def __init__(self, *args):
        _l_master.StrVector_swiginit(self, _l_master.new_StrVector(*args))

    def push_back(self, x):
        return _l_master.StrVector_push_back(self, x)

    def front(self):
        return _l_master.StrVector_front(self)

    def back(self):
        return _l_master.StrVector_back(self)

    def assign(self, n, x):
        return _l_master.StrVector_assign(self, n, x)

    def resize(self, *args):
        return _l_master.StrVector_resize(self, *args)

    def insert(self, *args):
        return _l_master.StrVector_insert(self, *args)

    def reserve(self, n):
        return _l_master.StrVector_reserve(self, n)

    def capacity(self):
        return _l_master.StrVector_capacity(self)
    __swig_destroy__ = _l_master.delete_StrVector

# Register StrVector in _l_master:
_l_master.StrVector_swigregister(StrVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _l_master.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.IntVector___nonzero__(self)

    def __bool__(self):
        return _l_master.IntVector___bool__(self)

    def __len__(self):
        return _l_master.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _l_master.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.IntVector___setitem__(self, *args)

    def pop(self):
        return _l_master.IntVector_pop(self)

    def append(self, x):
        return _l_master.IntVector_append(self, x)

    def empty(self):
        return _l_master.IntVector_empty(self)

    def size(self):
        return _l_master.IntVector_size(self)

    def swap(self, v):
        return _l_master.IntVector_swap(self, v)

    def begin(self):
        return _l_master.IntVector_begin(self)

    def end(self):
        return _l_master.IntVector_end(self)

    def rbegin(self):
        return _l_master.IntVector_rbegin(self)

    def rend(self):
        return _l_master.IntVector_rend(self)

    def clear(self):
        return _l_master.IntVector_clear(self)

    def get_allocator(self):
        return _l_master.IntVector_get_allocator(self)

    def pop_back(self):
        return _l_master.IntVector_pop_back(self)

    def erase(self, *args):
        return _l_master.IntVector_erase(self, *args)

    def __init__(self, *args):
        _l_master.IntVector_swiginit(self, _l_master.new_IntVector(*args))

    def push_back(self, x):
        return _l_master.IntVector_push_back(self, x)

    def front(self):
        return _l_master.IntVector_front(self)

    def back(self):
        return _l_master.IntVector_back(self)

    def assign(self, n, x):
        return _l_master.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _l_master.IntVector_resize(self, *args)

    def insert(self, *args):
        return _l_master.IntVector_insert(self, *args)

    def reserve(self, n):
        return _l_master.IntVector_reserve(self, n)

    def capacity(self):
        return _l_master.IntVector_capacity(self)
    __swig_destroy__ = _l_master.delete_IntVector

# Register IntVector in _l_master:
_l_master.IntVector_swigregister(IntVector)

class BVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _l_master.BVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.BVector___nonzero__(self)

    def __bool__(self):
        return _l_master.BVector___bool__(self)

    def __len__(self):
        return _l_master.BVector___len__(self)

    def __getslice__(self, i, j):
        return _l_master.BVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.BVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.BVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.BVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.BVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.BVector___setitem__(self, *args)

    def pop(self):
        return _l_master.BVector_pop(self)

    def append(self, x):
        return _l_master.BVector_append(self, x)

    def empty(self):
        return _l_master.BVector_empty(self)

    def size(self):
        return _l_master.BVector_size(self)

    def swap(self, v):
        return _l_master.BVector_swap(self, v)

    def begin(self):
        return _l_master.BVector_begin(self)

    def end(self):
        return _l_master.BVector_end(self)

    def rbegin(self):
        return _l_master.BVector_rbegin(self)

    def rend(self):
        return _l_master.BVector_rend(self)

    def clear(self):
        return _l_master.BVector_clear(self)

    def get_allocator(self):
        return _l_master.BVector_get_allocator(self)

    def pop_back(self):
        return _l_master.BVector_pop_back(self)

    def erase(self, *args):
        return _l_master.BVector_erase(self, *args)

    def __init__(self, *args):
        _l_master.BVector_swiginit(self, _l_master.new_BVector(*args))

    def push_back(self, x):
        return _l_master.BVector_push_back(self, x)

    def front(self):
        return _l_master.BVector_front(self)

    def back(self):
        return _l_master.BVector_back(self)

    def assign(self, n, x):
        return _l_master.BVector_assign(self, n, x)

    def resize(self, *args):
        return _l_master.BVector_resize(self, *args)

    def insert(self, *args):
        return _l_master.BVector_insert(self, *args)

    def reserve(self, n):
        return _l_master.BVector_reserve(self, n)

    def capacity(self):
        return _l_master.BVector_capacity(self)
    __swig_destroy__ = _l_master.delete_BVector

# Register BVector in _l_master:
_l_master.BVector_swigregister(BVector)

class BSVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _l_master.BSVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _l_master.BSVector___nonzero__(self)

    def __bool__(self):
        return _l_master.BSVector___bool__(self)

    def __len__(self):
        return _l_master.BSVector___len__(self)

    def __getslice__(self, i, j):
        return _l_master.BSVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _l_master.BSVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _l_master.BSVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _l_master.BSVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _l_master.BSVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _l_master.BSVector___setitem__(self, *args)

    def pop(self):
        return _l_master.BSVector_pop(self)

    def append(self, x):
        return _l_master.BSVector_append(self, x)

    def empty(self):
        return _l_master.BSVector_empty(self)

    def size(self):
        return _l_master.BSVector_size(self)

    def swap(self, v):
        return _l_master.BSVector_swap(self, v)

    def begin(self):
        return _l_master.BSVector_begin(self)

    def end(self):
        return _l_master.BSVector_end(self)

    def rbegin(self):
        return _l_master.BSVector_rbegin(self)

    def rend(self):
        return _l_master.BSVector_rend(self)

    def clear(self):
        return _l_master.BSVector_clear(self)

    def get_allocator(self):
        return _l_master.BSVector_get_allocator(self)

    def pop_back(self):
        return _l_master.BSVector_pop_back(self)

    def erase(self, *args):
        return _l_master.BSVector_erase(self, *args)

    def __init__(self, *args):
        _l_master.BSVector_swiginit(self, _l_master.new_BSVector(*args))

    def push_back(self, x):
        return _l_master.BSVector_push_back(self, x)

    def front(self):
        return _l_master.BSVector_front(self)

    def back(self):
        return _l_master.BSVector_back(self)

    def assign(self, n, x):
        return _l_master.BSVector_assign(self, n, x)

    def resize(self, *args):
        return _l_master.BSVector_resize(self, *args)

    def insert(self, *args):
        return _l_master.BSVector_insert(self, *args)

    def reserve(self, n):
        return _l_master.BSVector_reserve(self, n)

    def capacity(self):
        return _l_master.BSVector_capacity(self)
    __swig_destroy__ = _l_master.delete_BSVector

# Register BSVector in _l_master:
_l_master.BSVector_swigregister(BSVector)

class TupleDDB(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, arg2, arg3, v1):
        _l_master.TupleDDB_swiginit(self, _l_master.new_TupleDDB(arg2, arg3, v1))

    def get0(self):
        return _l_master.TupleDDB_get0(self)

    def get1(self):
        return _l_master.TupleDDB_get1(self)

    def get2(self):
        return _l_master.TupleDDB_get2(self)

    def set0(self, val):
        return _l_master.TupleDDB_set0(self, val)

    def set1(self, val):
        return _l_master.TupleDDB_set1(self, val)

    def set2(self, val):
        return _l_master.TupleDDB_set2(self, val)

    def __len__(self):
        return _l_master.TupleDDB___len__(self)

    #[7]
    def __getitem__(self, n):
        if n >= len(self): raise IndexError()
        return getattr(self, 'get%d' % n)()
    def __setitem__(self, n, val):
        if n >= len(self): raise IndexError()
        getattr(self, 'set%d' % n)(val)


    def __repr__(self):
        return _l_master.TupleDDB___repr__(self)
    __swig_destroy__ = _l_master.delete_TupleDDB

# Register TupleDDB in _l_master:
_l_master.TupleDDB_swigregister(TupleDDB)

class TupleIntStr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3):
        _l_master.TupleIntStr_swiginit(self, _l_master.new_TupleIntStr(arg2, arg3))

    def get0(self):
        return _l_master.TupleIntStr_get0(self)

    def get1(self):
        return _l_master.TupleIntStr_get1(self)

    def set0(self, val):
        return _l_master.TupleIntStr_set0(self, val)

    def set1(self, val):
        return _l_master.TupleIntStr_set1(self, val)

    def __len__(self):
        return _l_master.TupleIntStr___len__(self)

    #[7]
    def __getitem__(self, n):
        if n >= len(self): raise IndexError()
        return getattr(self, 'get%d' % n)()
    def __setitem__(self, n, val):
        if n >= len(self): raise IndexError()
        getattr(self, 'set%d' % n)(val)

    __swig_destroy__ = _l_master.delete_TupleIntStr

# Register TupleIntStr in _l_master:
_l_master.TupleIntStr_swigregister(TupleIntStr)

class TupleBS(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3):
        _l_master.TupleBS_swiginit(self, _l_master.new_TupleBS(arg2, arg3))

    def get0(self):
        return _l_master.TupleBS_get0(self)

    def get1(self):
        return _l_master.TupleBS_get1(self)

    def set0(self, val):
        return _l_master.TupleBS_set0(self, val)

    def set1(self, val):
        return _l_master.TupleBS_set1(self, val)

    def __len__(self):
        return _l_master.TupleBS___len__(self)

    #[7]
    def __getitem__(self, n):
        if n >= len(self): raise IndexError()
        return getattr(self, 'get%d' % n)()
    def __setitem__(self, n, val):
        if n >= len(self): raise IndexError()
        getattr(self, 'set%d' % n)(val)

    __swig_destroy__ = _l_master.delete_TupleBS

# Register TupleBS in _l_master:
_l_master.TupleBS_swigregister(TupleBS)


def version():
    r"""
    获取当前SDK版本号

    :rtype: string
    :return: 返回版本号字符串
    """
    return _l_master.version()
class KinematicsForwardResp(object):
    r"""运动学正解的返回值数据结构."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    pose = property(_l_master.KinematicsForwardResp_pose_get, _l_master.KinematicsForwardResp_pose_set, doc=r""" 笛卡尔坐标位置，依次为 x, y, z, rz, ry, rx.""")
    ok = property(_l_master.KinematicsForwardResp_ok_get, _l_master.KinematicsForwardResp_ok_set, doc=r""" 计算是否成功.""")

    def __repr__(self):
        return _l_master.KinematicsForwardResp___repr__(self)

    def __init__(self):
        _l_master.KinematicsForwardResp_swiginit(self, _l_master.new_KinematicsForwardResp())
    __swig_destroy__ = _l_master.delete_KinematicsForwardResp

# Register KinematicsForwardResp in _l_master:
_l_master.KinematicsForwardResp_swigregister(KinematicsForwardResp)

class KinematicsInverseResp(object):
    r"""运动学逆解的返回值数据结构"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    joint_positions = property(_l_master.KinematicsInverseResp_joint_positions_get, _l_master.KinematicsInverseResp_joint_positions_set, doc=r""" 机械臂关节位置的map数据，应当包括'j1','j2','j3','j4','j5','j6'六个关节的角度值.""")
    ok = property(_l_master.KinematicsInverseResp_ok_get, _l_master.KinematicsInverseResp_ok_set, doc=r""" 计算是否成功""")

    def __repr__(self):
        return _l_master.KinematicsInverseResp___repr__(self)

    def __init__(self):
        _l_master.KinematicsInverseResp_swiginit(self, _l_master.new_KinematicsInverseResp())
    __swig_destroy__ = _l_master.delete_KinematicsInverseResp

# Register KinematicsInverseResp in _l_master:
_l_master.KinematicsInverseResp_swigregister(KinematicsInverseResp)

class Robot(object):
    r""" 机械臂的主要接口对象，通过本对象的方法与机械臂进行数据交互."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ip, simulator=False):
        r"""
        构造Robot对象.

        :type ip: string
        :param ip:: 机械臂IP地址.
        :type simulator: boolean, optional
        :param simulator:: 用于表示机械臂是否为仿真机械臂(docker仿真或控制器运行在仿真模式下)的标志.True表示仿真模式，False表示实物机械臂.
        """
        _l_master.Robot_swiginit(self, _l_master.new_Robot(ip, simulator))
    __swig_destroy__ = _l_master.delete_Robot

    def call(self, method, params):
        r"""
        示例代码:

            std::string movej_req = "{\"param":{"v":0.1},"pose":{"joint":{"delta":"{\"joint":[-1.0,0.0,0.0,0.0,0.0,0.0]}}}}";
            resp = robot.call("movej", movej_req);
            std::cout << "resp: " << std::get<0>(resp) << ", " << std::get<1>(resp) << std::endl;


        @brief 用JSON格式字符串调用机械臂的接口.
        @note SDK采用JSONRPC协议和机械臂控制进行通讯. 您可以自行生成JSON数据，并通过本接口调用相应的JSONRPC，并获取返回的结果和JSON数据.
        @param[in] method 方法名字
        @param[in] params 请求JSONRPC的JSON格式字符串.
        @return 返回一个元组，第一个元素是返回码，第二个元素是数据字符串.
        如果返回码为0，表示调用成功，第二个元素是JSONRPC的返回数据.
        如果返回码为非0，表示调用失败，第二个元素是错误信息.
        """
        return _l_master.Robot_call(self, method, params)

    def start_sys(self):
        r"""启动机械臂（机械臂上使能）."""
        return _l_master.Robot_start_sys(self)

    def stop_sys(self):
        r"""停止机械臂（机械臂上使能）."""
        return _l_master.Robot_stop_sys(self)

    def powerdown(self):
        r"""关闭机器人电源（关机."""
        return _l_master.Robot_powerdown(self)

    def stop(self):
        r"""停止运动（但不下电）."""
        return _l_master.Robot_stop(self)

    def estop(self):
        r"""紧急停止（急停）."""
        return _l_master.Robot_estop(self)

    def teach_mode(self):
        r"""进入示教模式."""
        return _l_master.Robot_teach_mode(self)

    def end_teach_mode(self):
        r"""退出示教模式."""
        return _l_master.Robot_end_teach_mode(self)

    def pause(self):
        r"""暂停运动."""
        return _l_master.Robot_pause(self)

    def resume(self):
        r"""恢复运动."""
        return _l_master.Robot_resume(self)

    def reboot(self):
        r"""重新启动机箱"""
        return _l_master.Robot_reboot(self)

    def movej(self, *args):
        r"""
        *Overload 1:*

        示例代码:

            std::vector<double> joint_positions = {0.0, -60.0 / 180.0 * M_PI, 80.0 / 180.0 * M_PI, -10.0 / 180.0 * M_PI, -60.0 / 180.0 * M_PI, 0.0};
            robot.movej(joint_positions, 3.0, 1.0, 0.0, 0.0);


        通过关节位置发送机械臂关节移动
        Notes: 该接口为异步接口，仅向控制器内部的运动缓冲区写入一个关节移动即返回，不会等待运动结束.
        :type joint_positions: std::vector< double,std::allocator< double > >, in
        :param joint_positions: 目标位置的关节数据,为关节的角度值构成的数组.
        :type a: float, in
        :param a: 加速度
        :type v: float, in
        :param v: 速度
        :type t: float, in
        :param t: 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        :type r: float, in
        :param r: 交融半径，设置为0，则无交融半径.
        :rtype: int
        :return: >0 发送成功
        :rtype: int
        :return: <=0 发送失败


        |

        *Overload 2:*

        示例代码:

            robot.movej({”x",-0.296},{"y",-0.295},{"z",0.285},{"rz",60.0 / 180.0 * M_PI},{"ry",-5.0 / 180.0 * M_PI},{"rx", 81.0 / 180.0 * M_PI}}, 3.0, 1.0, 0.0, 0.0);


        @brief 通过坐标位置发送机械臂关节移动
        @note 该接口为异步接口，仅向控制器内部的运动缓冲区写入一个关节移动即返回，不会等待运动结束.
        @param[in] cart_pose 目标位置在机器人基座标系下的坐标数据(目前不支持在其它坐标系下的坐标数据)，CartesianPose = std::map<std::string,double>，应当包括键为x,y,z,rz,ry,rx的值.
        @param[in] a 加速度.
        @param[in] v 速度.
        @param[in] t 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        @param[in] r 交融半径，设置为0，则无交融半径.
        @return >0 发送成功
        @return <=0 发送失败
        """
        return _l_master.Robot_movej(self, *args)

    def movel(self, *args):
        r"""
        *Overload 1:*

        示例代码:

            std::vector<double> joint_positions = {0.0, -60.0 / 180.0 * M_PI, 80.0 / 180.0 * M_PI, -10.0 / 180.0 * M_PI, -60.0 / 180.0 * M_PI, 0.0};
            robot.movel(joint_positions, 3.0, 1.0, 0.0, 0.0);


        通过关节位置发送机械臂直线移动
        Notes: 该接口为异步接口，仅向控制器内部的运动缓冲区写入一个关节移动即返回，不会等待运动结束.
        :type joint_positions: std::vector< double,std::allocator< double > >, in
        :param joint_positions:: 目标位置的关节数据,为关节的角度值构成的数组.
        :type a: float, in
        :param a: 加速度.
        :type v: float, in
        :param v: 速度.
        :type t: float, in
        :param t: 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        :type r: float, in
        :param r: 交融半径，设置为0，则无交融半径.
        :rtype: int
        :return: >0 发送成功
        :rtype: int
        :return: <=0 发送失败

        |

        *Overload 2:*

        示例代码:

            robot.movel({”x",-0.296},{"y",-0.295},{"z",0.285},{"rz",60.0 / 180.0 * M_PI},{"ry",-5.0 / 180.0 * M_PI},{"rx", 81.0 / 180.0 * M_PI}}, 3.0, 1.0, 0.0, 0.0);


        @brief 通过坐标位置发送机械臂直线移动
        @note 该接口为异步接口，仅向控制器内部的运动缓冲区写入一个关节移动即返回，不会等待运动结束.
        @param cart_pose 目标位置在机器人基座标系下的坐标数据(目前不支持在其它坐标系下的坐标数据)，CartesianPose = std::map<std::string,double>，应当包括键为x,y,z,rz,ry,rx的值.
        @param a 加速度.
        @param v 速度.
        @param t 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        @param r 交融半径，设置为0，则无交融半径.
        @return >0 发送成功.
        @return <=0 发送失败.
        """
        return _l_master.Robot_movel(self, *args)

    def movec(self, *args):
        r"""
        *Overload 1:*

        示例代码

            robot.movec({3.0/ 180.0 * M_PI, -48.0/ 180.0 * M_PI, 78.0/ 180.0 * M_PI, 9.0/ 180.0 * M_PI, -67.0/ 180.0 * M_PI, -3.0/ 180.0 * M_PI},
            {-28/ 180.0 * M_PI, -59.0/ 180.0 * M_PI, 96.0/ 180.0 * M_PI, -2.0/ 180.0 * M_PI, -92.0/ 180.0 * M_PI, 16.0/ 180.0 * M_PI},
            0.0, 1.0, 0.5, 0.0, 0.0);

        通过关节位置发送机械臂圆弧运动.
        :type joint_via: std::vector< double,std::allocator< double > >, in
        :param joint_via: 圆弧上途径点关节位置，为关节的角度值构成的数组.为圆上三点中的一点.
        :type joint: std::vector< double,std::allocator< double > >, in
        :param joint: 圆弧目标点关节位置，为关节的角度值构成的数组.如果编程rad不为零，则为圆上三点中的一点.
        :type rad: float, in
        :param rad: 圆弧角度值，单位为弧度，如果为零，则走到目标点，正负值用来确定圆弧方向.
        :type a: float, in
        :param a: 加速度.
        :type v: float, in
        :param v: 速度.
        :type t: float, in
        :param t:: 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        :type r: float, in
        :param r:: 交融半径，设置为0，则无交融半径.
        :rtype: int
        :return: >0 发送成功.
        :rtype: int
        :return: <=0 发送失败.

        |

        *Overload 2:*


        通过坐标位置发送机械臂圆弧运动     *
        :type cart_via: :py:class:`CartesianPose`, in
        :param cart_via: 圆弧上途径点坐标位置，应当包括键为x,y,z,rz,ry,rx的值.为圆上三点中的一点.
        :type cart: :py:class:`CartesianPose`, in
        :param cart: 圆弧目标点坐标位置，应当包括键为x,y,z,rz,ry,rx的值.如果编程rad不为零，则为圆上三点中的一点.
        :type rad: float, in
        :param rad: 圆弧角度值，单位为弧度，如果为零，则走到目标点，正负值用来确定圆弧方向.
        :type a: float, in
        :param a: 加速度.
        :type v: float, in
        :param v: 速度.
        :type t: float, in
        :param t:: 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        :type r: float, in
        :param r:: 交融半径，设置为0，则无交融半径.
        :rtype: int
        :return: >0 发送成功.
        :rtype: int
        :return: <=0 发送失败.
        """
        return _l_master.Robot_movec(self, *args)

    def towardj(self, joint_positions, a, v, t, r):
        r"""
        示例代码:

            std::vector<double> joint_positions = {0.0, -60.0 / 180.0 * M_PI, 80.0 / 180.0 * M_PI, -10.0 / 180.0 * M_PI, -60.0 / 180.0 * M_PI, 0.0};
            robot.toawrdj(joint_positions, 3.0, 1.0, 0.0, 0.0);


        通过关节位置发送机械臂关节自由移动.
        Notes: 该接口为异步接口，仅向控制器内部的运动缓冲区写入一个关节自由移动即返回，不会等待运动结束.
        :type joint_positions: std::vector< double,std::allocator< double > >, in
        :param joint_positions:: 目标位置的关节数据,为关节的角度值构成的数组.
        :type a: float, in
        :param a:: 加速度.
        :type v: float, in
        :param v:: 速度.
        :type t: float, in
        :param t:: 时间参数，如果设置时间不为零，则按照时间计算出速度，而不使用速度参数.
        :type r: float, in
        :param r:: 交融半径，设置为0，则无交融半径.
        :rtype: int
        :return: >0 发送成功.
        :rtype: int
        :return: <=0 发送失败.
        """
        return _l_master.Robot_towardj(self, joint_positions, a, v, t, r)

    def move_pvat(self, p, v, a, t):
        r"""
        伺服运动PVAT

        :type p: std::vector< double,std::allocator< double > >
        :param p: 关节位置，或者坐标位置（将通过运动学反解转为关节位置）.
        :type v: std::vector< double,std::allocator< double > >
        :param v: 每个关节的速度 (rad/s)。如该值为数字，则表示所有关节速度相同.
        :type a: std::vector< double,std::allocator< double > >
        :param a: 每个关节的加速度 (rad/s2)。如该值为数字，则表示所有关节加速度相同.
        :type t: float
        :param t: 运动时间 (s)
        """
        return _l_master.Robot_move_pvat(self, p, v, a, t)

    def wait_move(self, *args):
        r"""
        *Overload 1:*

        等待运动完成.

        :type id: int
        :param id: 指定运动的id(0为等待全部任务).

        |

        *Overload 2:*

        等待所有运动完成.
        """
        return _l_master.Robot_wait_move(self, *args)

    def get_running_motion(self):
        r"""查询当前正在运动的MotionId(无运动时返回上次MotionId)."""
        return _l_master.Robot_get_running_motion(self)

    def get_motion_state(self, id):
        r"""
        查询指定MotionId的运动状态.

        :type id: int
        :param id: 指定的运动id.
        """
        return _l_master.Robot_get_motion_state(self, id)

    def stop_move(self):
        r"""停止所有运动."""
        return _l_master.Robot_stop_move(self)

    def get_robot_mode(self):
        r"""
        获取机器人状态码

        :rtype: int
        :return: int 返回状态码.

         状态码 |      状态	     |       说明
         ------ | -------------  | -------------
           -1	 |   控制系统故障  |  机器人软件控制系统异常
           0	   |   硬件通讯故障  |  机器人硬件通讯故障
           1	   |   已急停	       |  机器人处于急停状态，请确认安全性
           2	   |   初始化中	     |  机器人初始化中
           4	   |   初始化完成	   |  机器人电源已开启
           5	   |   空闲	         |  机器人处于空闲状态
           6	   |   暂停	         |  机器人处于暂停中状态
           7	   |   运行中	       |  机器人运行中
           8	   |   更新中	       |  机器人系统更新中
           9	   |   启动中	       |  机器人初始化完成到空闲的启动过程中
           10	 |   正在停止	     |  机器人空闲状态转到停止状态
           11	 |   示教中	       |  机器人处于示教模式中
           12	 |   已停止	       |  机器人处于停止状态，非急停状态

        Notes: 查看 具体信息 ("https://help.lebai.ltd/guide/basic.html#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%8A%B6%E6%80%81").
        """
        return _l_master.Robot_get_robot_mode(self)

    def get_estop_reason(self):
        r"""
        查看急停原因

        :rtype: int
        :return: 急停原因
        """
        return _l_master.Robot_get_estop_reason(self)

    def is_disconnected(self):
        r"""
        是否已与手臂断开连接

        :rtype: boolean
        :return: 是否已断开连接
        """
        return _l_master.Robot_is_disconnected(self)

    def is_down(self):
        r"""
        手臂是否已下电

        :rtype: boolean
        :return: 是否已下电
        """
        return _l_master.Robot_is_down(self)

    def get_actual_joint_positions(self):
        r"""
        获取机械臂关节当前反馈位置

        :rtype: std::vector< double,std::allocator< double > >
        :return: 关节反馈位置数组，包括所有关节的角度值.
        """
        return _l_master.Robot_get_actual_joint_positions(self)

    def get_target_joint_positions(self):
        r"""
        获取机械臂关节当前控制位置

        :rtype: std::vector< double,std::allocator< double > >
        :return: 关节控制位置数组，包括所有关节的角度值.
        """
        return _l_master.Robot_get_target_joint_positions(self)

    def get_actual_joint_speed(self):
        r"""
        获取机械臂关节当前反馈速度

        :rtype: std::vector< double,std::allocator< double > >
        :return: 关节反馈速度数据
        """
        return _l_master.Robot_get_actual_joint_speed(self)

    def get_target_joint_speed(self):
        r"""
        获取机械臂关节当前控制力矩

        :rtype: std::vector< double,std::allocator< double > >
        :return: 关节控制速度数据
        """
        return _l_master.Robot_get_target_joint_speed(self)

    def get_actual_tcp_pose(self):
        r"""
        获取机械臂末端在机械臂基坐标系下的实际位姿，CartesianPose = std::map<std::string,double>，应当包括键为x,y,z,rz,ry,rx的值.

        :rtype: :py:class:`CartesianPose`
        :return: CartesianPose
        """
        return _l_master.Robot_get_actual_tcp_pose(self)

    def get_target_tcp_pose(self):
        r"""
        获取机械臂末端在机械臂基坐标系下的控制位姿，CartesianPose = std::map<std::string,double>，应当包括键为x,y,z,rz,ry,rx的值.

        :rtype: :py:class:`CartesianPose`
        :return: CartesianPose
        """
        return _l_master.Robot_get_target_tcp_pose(self)

    def get_joint_temp(self, joint_index):
        r"""
        获取单个关节温度

        :type joint_index: int
        :param joint_index: 关节索引
        :rtype: float
        :return: double 关节当前温度
        """
        return _l_master.Robot_get_joint_temp(self, joint_index)

    def get_actual_joint_torques(self):
        r"""
        获取机械臂关节当前反馈力矩

        :rtype: std::vector< double,std::allocator< double > >
        :return: 关节当前反馈力矩
        """
        return _l_master.Robot_get_actual_joint_torques(self)

    def get_target_joint_torques(self):
        r"""
        获取机械臂关节当前控制力矩

        :rtype: std::vector< double,std::allocator< double > >
        :return: 关节当前控制力矩
        """
        return _l_master.Robot_get_target_joint_torques(self)

    def set_do(self, device, pin, value):
        r"""
        设置数字输出
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin: 端口，从 0 开始
        :type value: int
        :param value: 待设置的值
        """
        return _l_master.Robot_set_do(self, device, pin, value)

    def get_do(self, device, pin):
        r"""
        获取数字输出
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin: 端口，从 0 开始
        :rtype: int
        :return: 返回数字输出数值
        """
        return _l_master.Robot_get_do(self, device, pin)

    def get_dos(self, device, pin, num):
        r"""
        获取多个数字输出
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin: 起始数字输出端口，从 0 开始
        :type num: int
        :param num: 连续的数字输出个数
        :rtype: std::vector< unsigned int,std::allocator< unsigned int > >
        :return: 返回多个数字输出数值
        """
        return _l_master.Robot_get_dos(self, device, pin, num)

    def get_di(self, device, pin):
        r"""
        获取数字输入
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin: 端口，从 0 开始
        :rtype: int
        :return: 返回输入数值
        """
        return _l_master.Robot_get_di(self, device, pin)

    def get_dis(self, device, pin, num):
        r"""
        获取多个数字输入
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin: 起始数字输入端口，从 0 开始
        :type num: int
        :param num: 连续的数字输入个数
        :rtype: std::vector< unsigned int,std::allocator< unsigned int > >
        :return: 返回多个数字输入
        """
        return _l_master.Robot_get_dis(self, device, pin, num)

    def set_ao(self, device, pin, value):
        r"""
        设置模拟输出
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin:: 模拟输出端口，从 0 开始
        :type value: float
        :param value:: 待设置的模拟输出值
        """
        return _l_master.Robot_set_ao(self, device, pin, value)

    def get_ao(self, device, pin):
        r"""
        获取模拟输出
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin:: 端口，从 0 开始
        :rtype: float
        :return: 返回模拟输入数值
        """
        return _l_master.Robot_get_ao(self, device, pin)

    def get_aos(self, device, pin, num):
        r"""
        获取多个模拟输出
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin:: 起始模拟输出端口，从 0 开始
        :type num: int
        :param num: 连续的模拟输出个数
        :rtype: std::vector< double,std::allocator< double > >
        :return: 返回模拟输出数值
        """
        return _l_master.Robot_get_aos(self, device, pin, num)

    def get_ai(self, device, pin):
        r"""
        获取模拟输入
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin:: 端口，从 0 开始
        :rtype: float
        :return: 返回模拟输入数值
        """
        return _l_master.Robot_get_ai(self, device, pin)

    def get_ais(self, device, pin, num):
        r"""
        获取多个模拟输入
        :type device: string
        :param device: 设备类型，以字符串形式传入，包括 `ROBOT`, `FLANGE`, `EXTRA`, `SHOULDER`, `FLANGE_BTN`
            查看 详细信息 ("https://help.lebai.ltd/sdk/io.html#io-%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B").
        :type pin: int
        :param pin:: 起始模拟输入端口，从 0 开始
        :type num: int
        :param num: 连续的模拟输入个数
        :rtype: std::vector< double,std::allocator< double > >
        :return: 返回多个模拟输入数值
        """
        return _l_master.Robot_get_ais(self, device, pin, num)

    def set_dio_mode(self, device, pin, value):
        r"""
        设置数字端口模式
        :type pin: int
        :param pin: 端口号，从 0 开始
        :type value: boolean
        :param value: 设置的值，false为输入模式，true为输出模式
        :rtype: void
        :return: 返回是否成功
        """
        return _l_master.Robot_set_dio_mode(self, device, pin, value)

    def get_dios_mode(self, device, pin, count):
        r"""
        获取数字端口模式
        :type pin: int
        :param pin: 端口号，从 0 开始
        :type count: int
        :param count: 查询的连续端口数
        :rtype: std::vector< bool,std::allocator< bool > >
        :return: 从pin开始的连续count个端口的当前模式
        """
        return _l_master.Robot_get_dios_mode(self, device, pin, count)

    def set_claw(self, force, amplitude):
        r"""
        设置夹爪力度（力控）和幅度（位控）.如果在闭合过程中抓取到物体，则不再继续闭合以避免夹坏物体，判断的准则为这里设置的力的大小.

        :type force: float
        :param force: 力度（0-100）
        :type amplitude: float
        :param amplitude: 张合幅度（0-100）
        """
        return _l_master.Robot_set_claw(self, force, amplitude)

    def get_claw(self):
        r"""
        获取夹爪当前数据

        :rtype: std::tuple< double,double,bool >
        :return: std::tuple<double, double ,bool> 第一个数据为夹爪力度，第二个数据为幅度，第三个数据为开度是否稳定
        """
        return _l_master.Robot_get_claw(self)

    def set_led(self, mode, speed, color):
        r"""
        设置LED灯状态.

        :type mode: int
        :param mode:: 亮灯模式.0：不变；1：关闭；2：常亮；3：呼吸；4：均分旋转；5：同色旋转；6：闪烁
        :type speed: int
        :param speed:: 速度.1：快速；2：正常；3：慢速
        :type color: std::vector< unsigned int,std::allocator< unsigned int > >
        :param color:: 最多包含 4 个 0 ~ 15 之间的整数
        """
        return _l_master.Robot_set_led(self, mode, speed, color)

    def set_voice(self, voice, volume):
        r"""
        设置声音

        :type voice: int
        :param voice:: 声音列表
        :type volume: int
        :param volume:: 音量.0：静音；1：低；2：正常；3：高
        """
        return _l_master.Robot_set_voice(self, voice, volume)

    def set_fan(self, status):
        r"""
        开关风扇

        :type status: int
        :param status:: 状态.1：关闭；2：开启
        """
        return _l_master.Robot_set_fan(self, status)

    def set_signal(self, index, value):
        r"""
        设置信号量

        :type index: int
        :param index:: 信号量下标（取值范围0~255)
        :type value: int
        :param value:: 待设置的信号量(32位有符号整数)
        """
        return _l_master.Robot_set_signal(self, index, value)

    def get_signal(self, index):
        r"""
        获取信号量

        :type index: int
        :param index:: 信号量下标（取值范围0~255)
        :rtype: int
        :return: 返回对应的信号量
        """
        return _l_master.Robot_get_signal(self, index)

    def add_signal(self, index, value):
        r"""
        增加指定下标的信号量值，该操作是原子的.

        :type index: int
        :param index:: 信号量下标（取值范围0~255）
        :type value: int
        :param value:: 待增加的信号量值
        """
        return _l_master.Robot_add_signal(self, index, value)

    def start_task(self, *args):
        r"""
        *Overload 1:*

        调用场景

        :type name: string
        :param name:: 调用场景的名字
        :type is_main: boolean
        :param is_main:: 是否以主任务方式运行（主任务会排队执行，子任务会并发执行）
        :type loop_to: int
        :param loop_to:: 循环次数（默认0永久循环）
        :type dir: string
        :param dir:: 调用场景所在的文件夹名
        :type params: std::vector< std::string,std::allocator< std::string > >
        :param params:: 其他参数

        |

        *Overload 2:*

        调用场景

        :type name: string
        :param name:: 调用场景的名字
        :type is_main: boolean
        :param is_main:: 是否以主任务方式运行（主任务会排队执行，子任务会并发执行）
        :type loop_to: int
        :param loop_to:: 循环次数（默认0永久循环）
        :type dir: string
        :param dir:: 调用场景所在的文件夹名

        |

        *Overload 3:*

        调用场景

        :type name: string
        :param name:: 调用场景的名字
        """
        return _l_master.Robot_start_task(self, *args)

    def load_task_list(self):
        r"""查询任务列表"""
        return _l_master.Robot_load_task_list(self)

    def pause_task(self, id, time, wait):
        r"""
        暂停任务与运动

        :type id: int
        :param id:: 任务的ID
        :type time: int
        :param time:: 暂停的时间
        :type wait: boolean
        :param wait:: 是否等待
        """
        return _l_master.Robot_pause_task(self, id, time, wait)

    def resume_task(self, id):
        r"""
        恢复任务与运动

        :type id: int
        :param id: 任务的ID
        """
        return _l_master.Robot_resume_task(self, id)

    def cancel_task(self, id):
        r"""
        取消任务与运动.

        :type id: int
        :param id: 任务的ID.
        """
        return _l_master.Robot_cancel_task(self, id)

    def exec_hook(self, id):
        r"""
        根据已设置的Hook执行对应场景

        :type id: int
        :param id: 任务的ID.
        """
        return _l_master.Robot_exec_hook(self, id)

    def get_task_state(self, *args):
        r"""
        *Overload 1:*

        获取任务状态.

        |

        *Overload 2:*

        获取任务状态.

        :type id: int
        :param id: 任务的ID.
        """
        return _l_master.Robot_get_task_state(self, *args)

    def kinematics_forward(self, joint_positions):
        r"""
        根据机械臂关节位置计算机器人末端位姿（位置的运动学正解）.
        :type joint_positions: std::vector< double,std::allocator< double > >
        :param joint_positions:: 机械臂关节位置的数组.
        :rtype: :py:class:`KinematicsForwardResp`
        :return: 返回计算结果 'KinematicsForwardResp'.
        """
        return _l_master.Robot_kinematics_forward(self, joint_positions)

    def kinematics_inverse(self, *args):
        r"""
        根据机械臂的末端位姿计算关节位置（位置的运动学逆解）.
        :type pose: :py:class:`CartesianPose`
        :param pose:: 机械臂末端位姿，应当包括键为x,y,z,rz,ry,rx的值.
        :type joint_init_positions: std::vector< double,std::allocator< double > >, optional
        :param joint_init_positions:: 机械臂关节初始位置, 以数组形式传入.
        :rtype: :py:class:`KinematicsInverseResp`
        :return: 返回计算结果 'KinematicsInverseResp'.
        """
        return _l_master.Robot_kinematics_inverse(self, *args)

    def pose_times(self, a, b):
        r"""
        位姿变换乘法（等价于对应的齐次坐标矩阵乘法）

        :type a: :py:class:`CartesianPose`, in
        :param a:: 位姿，应当包括键为x,y,z,rz,ry,rx的值.
        :type b: :py:class:`CartesianPose`, in
        :param b:: 位姿，应当包括键为x,y,z,rz,ry,rx的值.
        :rtype: :py:class:`CartesianPose`
        :return: CartesianPose 返回的位姿，应当包括键为x,y,z,rz,ry,rx的值.
        """
        return _l_master.Robot_pose_times(self, a, b)

    def pose_inverse(self, _in):
        r"""
        位姿变换的逆（等价于对应的齐次坐标矩的逆）

        :type in: :py:class:`CartesianPose`
        :param in:: 位姿，应当包括键为x,y,z,rz,ry,rx的值.
        :rtype: :py:class:`CartesianPose`
        :return: CartesianPose 返回位姿变换的逆，应当包括键为x,y,z,rz,ry,rx的值.
        """
        return _l_master.Robot_pose_inverse(self, _in)

    def save_file(self, dir, name, is_dir, data):
        r"""
        保存文件（以字节形式）.

        :type dir: string
        :param dir:: 保存的文件路径.
        :type name: string
        :param name:: 保存的文件名.
        :type is_dir: boolean
        :param is_dir:: 要保存的文件是否为文件夹.
        :type data: string
        :param data:: 文件字节.
        """
        return _l_master.Robot_save_file(self, dir, name, is_dir, data)

    def rename_file(self, from_dir, from_name, to_dir, to_name):
        r"""
        重命名文件

        :type from_dir: string
        :param from_dir:: 源文件所在的文件夹.
        :type from_name: string
        :param from_name:: 源文件名称.
        :type to_dir: string
        :param to_dir:: 目标文件文件夹.
        :type to_name: string
        :param to_name:: 目标文件文件名.
        """
        return _l_master.Robot_rename_file(self, from_dir, from_name, to_dir, to_name)

    def load_file(self, dir, name):
        r"""
        查询文件

        :type dir: string
        :param dir:: 文件的目录
        :type name: string
        :param name:: 文件名

        :rtype: std::tuple< bool,std::string >
        :return: 文件的具体内容
        """
        return _l_master.Robot_load_file(self, dir, name)

    def load_file_list(self, dir, prefix, suffix):
        r"""
        查询文件列表.

        :type dir: string
        :param dir:: 文件的目录.
        :type prefix: string
        :param prefix:: 前缀.
        :type suffix: string
        :param suffix:: 后缀.

        :rtype: std::vector< std::tuple< bool,std::string >,std::allocator< std::tuple< bool,std::string > > >
        :return: 文件列表.
        """
        return _l_master.Robot_load_file_list(self, dir, prefix, suffix)

    def set_tcp(self, tcp):
        r"""
        将文件从文件系统中压缩到zip文件.

        :param from_dir: 源文件的目录.
        :param files: 源文件的文件名.
        :param to_dir:  压缩后文件的路径.
        :param name: 压缩后文件的名称.

         设置工具中心点(TCP)坐标，坐标值相对于工具坐标系.

         :type tcp: std::array< double,6 >
         :param tcp: 参数为六元组，表示一个空间位置变换.
        """
        return _l_master.Robot_set_tcp(self, tcp)

    def get_tcp(self):
        r"""
        获取当前机器人工具中心点设置.

        :rtype: std::array< double,6 >
        :return: 当前机器人的工具中心点参数，为六元组.
        """
        return _l_master.Robot_get_tcp(self)

    def set_velocity_factor(self, factor):
        r"""
        设置速度因子.

        :type factor: int
        :param factor: 速度因子百分比，范围0-100.
        """
        return _l_master.Robot_set_velocity_factor(self, factor)

    def get_velocity_factor(self):
        r"""
        获取当前的速度因子.

        :rtype: int
        :return: 速度因子百分比.
        """
        return _l_master.Robot_get_velocity_factor(self)

    def set_payload(self, mass, cog):
        r"""
        设置机器人末端负载.

        :type mass: float
        :param mass: 末端负载的质量(kg).
        :type cog: std::map< std::string,double,std::less< std::string >,std::allocator< std::pair< std::string const,double > > >
        :param cog: 质心相对于TCP坐标系的偏移.
        """
        return _l_master.Robot_set_payload(self, mass, cog)

    def get_payload(self):
        r"""
        获取末端负载设置.

        :rtype: std::tuple< double,std::map< std::string,double,std::less< std::string >,std::allocator< std::pair< std::string const,double > > > >
        :return: 由负载质量mass和负载偏移组成的元组.
        """
        return _l_master.Robot_get_payload(self)

    def set_gravity(self, gravity):
        r"""
        设置机器人重力加速度方向.

        :type gravity: std::map< std::string,double,std::less< std::string >,std::allocator< std::pair< std::string const,double > > >
        :param gravity: 相对于机器人基座标的重力方向.
        """
        return _l_master.Robot_set_gravity(self, gravity)

    def get_gravity(self):
        r"""
        获取机器人重力加速度的方向.

        :rtype: std::map< std::string,double,std::less< std::string >,std::allocator< std::pair< std::string const,double > > >
        :return: 相对于机器人基座标的重力方向.
        """
        return _l_master.Robot_get_gravity(self)

    def load_tcp(self, *args):
        r"""
        从资源库加载tcp.

        :type name: string
        :param name: 点位名称.
        :type dir: string, optional
        :param dir: 点位目录.
        """
        return _l_master.Robot_load_tcp(self, *args)

    def write_single_coil(self, device, addr, value):
        r"""
        写单个线圈.

        :type device: string
        :param device: 设备名称.
        :type addr: string
        :param addr: 寄存器地址.
        :type value: boolean
        :param value: 待设置的值.
        """
        return _l_master.Robot_write_single_coil(self, device, addr, value)

    def wirte_multiple_coils(self, device, addr, values):
        r"""
        写多个线圈

        :type device: string
        :param device: 设备名称.
        :type addr: string
        :param addr: 寄存器地址.
        :type values: std::vector< bool,std::allocator< bool > >
        :param values: 待设置的值.
        """
        return _l_master.Robot_wirte_multiple_coils(self, device, addr, values)

    def read_coils(self, device, addr, num):
        r"""
        读线圈

        :type device: string
        :param device: 设备名称.
        :type addr: string
        :param addr: 寄存器地址.
        :type num: int
        :param num: 连续数量.
        """
        return _l_master.Robot_read_coils(self, device, addr, num)

    def read_discrete_inputs(self, device, addr, num):
        r"""
        读离散输入

        :type device: string
        :param device: 设备名称.
        :type addr: string
        :param addr: 寄存器地址.
        :type num: int
        :param num: 连续数量.
        """
        return _l_master.Robot_read_discrete_inputs(self, device, addr, num)

    def write_single_register(self, device, addr, value):
        r"""
        写单个寄存器

        :type device: string
        :param device: 设备名称.
        :type addr: string
        :param addr: 寄存器地址.
        :type value: int
        :param value: 待设置的值.
        """
        return _l_master.Robot_write_single_register(self, device, addr, value)

    def write_multiple_registers(self, device, addr, values):
        r"""
        写多个寄存器

        :type device: string
        :param device: 设备名称.
        :type addr: string
        :param addr: 寄存器地址.
        :type values: std::vector< unsigned int,std::allocator< unsigned int > >
        :param values: 待设置的值.
        """
        return _l_master.Robot_write_multiple_registers(self, device, addr, values)

    def read_holding_registers(self, device, addr, num):
        r"""
        读保持寄存器

        :type device: string
        :param device: 设备名称
        :type addr: string
        :param addr: 寄存器地址
        :type num: int
        :param num: 连续数量
        """
        return _l_master.Robot_read_holding_registers(self, device, addr, num)

    def read_input_registers(self, device, addr, num):
        r"""
        读输入寄存器

        :type device: string
        :param device: 设备名称
        :type addr: string
        :param addr: 寄存器地址
        :type num: int
        :param num: 连续数量
        """
        return _l_master.Robot_read_input_registers(self, device, addr, num)

# Register Robot in _l_master:
_l_master.Robot_swigregister(Robot)



