// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Media.Devices.Core.h"


namespace py::cpp::Windows::Media::Devices::Core
{
    struct module_state
    {
        PyObject* type_FrameFlashMode;
        PyTypeObject* type_CameraIntrinsics;
        PyTypeObject* type_DepthCorrelatedCoordinateMapper;
        PyTypeObject* type_FrameControlCapabilities;
        PyTypeObject* type_FrameController;
        PyTypeObject* type_FrameExposureCapabilities;
        PyTypeObject* type_FrameExposureCompensationCapabilities;
        PyTypeObject* type_FrameExposureCompensationControl;
        PyTypeObject* type_FrameExposureControl;
        PyTypeObject* type_FrameFlashCapabilities;
        PyTypeObject* type_FrameFlashControl;
        PyTypeObject* type_FrameFocusCapabilities;
        PyTypeObject* type_FrameFocusControl;
        PyTypeObject* type_FrameIsoSpeedCapabilities;
        PyTypeObject* type_FrameIsoSpeedControl;
        PyTypeObject* type_VariablePhotoSequenceController;
    };

    static PyObject* register_FrameFlashMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FrameFlashMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FrameFlashMode = type;
        Py_INCREF(state->type_FrameFlashMode);


        Py_RETURN_NONE;
    }

    // ----- CameraIntrinsics class --------------------
    static constexpr const char* const type_name_CameraIntrinsics = "CameraIntrinsics";

    static PyObject* _new_CameraIntrinsics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                winrt::Windows::Media::Devices::Core::CameraIntrinsics instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraIntrinsics(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraIntrinsics_DistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"DistortPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.DistortPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_DistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"DistortPoints", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                self->obj.DistortPoints(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectManyOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ProjectManyOntoFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                self->obj.ProjectManyOntoFrame(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ProjectOntoFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert(self->obj.ProjectOntoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UndistortPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.UndistortPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UndistortPoints", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                self->obj.UndistortPoints(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UnprojectAtUnitDepth", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.UnprojectAtUnitDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectPixelsAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UnprojectPixelsAtUnitDepth", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float2, true>>(args, 1);

                self->obj.UnprojectPixelsAtUnitDepth(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_FocalLength(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"FocalLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageHeight(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ImageHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImageHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageWidth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"ImageWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImageWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_PrincipalPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"PrincipalPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrincipalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_RadialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"RadialDistortion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_TangentialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"TangentialDistortion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TangentialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_UndistortedProjectionTransform(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.CameraIntrinsics", L"UndistortedProjectionTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UndistortedProjectionTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::CameraIntrinsics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::CameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraIntrinsics[] = {
        { "distort_point", reinterpret_cast<PyCFunction>(CameraIntrinsics_DistortPoint), METH_VARARGS, nullptr },
        { "distort_points", reinterpret_cast<PyCFunction>(CameraIntrinsics_DistortPoints), METH_VARARGS, nullptr },
        { "project_many_onto_frame", reinterpret_cast<PyCFunction>(CameraIntrinsics_ProjectManyOntoFrame), METH_VARARGS, nullptr },
        { "project_onto_frame", reinterpret_cast<PyCFunction>(CameraIntrinsics_ProjectOntoFrame), METH_VARARGS, nullptr },
        { "undistort_point", reinterpret_cast<PyCFunction>(CameraIntrinsics_UndistortPoint), METH_VARARGS, nullptr },
        { "undistort_points", reinterpret_cast<PyCFunction>(CameraIntrinsics_UndistortPoints), METH_VARARGS, nullptr },
        { "unproject_at_unit_depth", reinterpret_cast<PyCFunction>(CameraIntrinsics_UnprojectAtUnitDepth), METH_VARARGS, nullptr },
        { "unproject_pixels_at_unit_depth", reinterpret_cast<PyCFunction>(CameraIntrinsics_UnprojectPixelsAtUnitDepth), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CameraIntrinsics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraIntrinsics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraIntrinsics[] = {
        { "focal_length", reinterpret_cast<getter>(CameraIntrinsics_get_FocalLength), nullptr, nullptr, nullptr },
        { "image_height", reinterpret_cast<getter>(CameraIntrinsics_get_ImageHeight), nullptr, nullptr, nullptr },
        { "image_width", reinterpret_cast<getter>(CameraIntrinsics_get_ImageWidth), nullptr, nullptr, nullptr },
        { "principal_point", reinterpret_cast<getter>(CameraIntrinsics_get_PrincipalPoint), nullptr, nullptr, nullptr },
        { "radial_distortion", reinterpret_cast<getter>(CameraIntrinsics_get_RadialDistortion), nullptr, nullptr, nullptr },
        { "tangential_distortion", reinterpret_cast<getter>(CameraIntrinsics_get_TangentialDistortion), nullptr, nullptr, nullptr },
        { "undistorted_projection_transform", reinterpret_cast<getter>(CameraIntrinsics_get_UndistortedProjectionTransform), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraIntrinsics[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CameraIntrinsics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CameraIntrinsics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CameraIntrinsics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CameraIntrinsics) },
        { },
    };

    static PyType_Spec type_spec_CameraIntrinsics =
    {
        "_winsdk_Windows_Media_Devices_Core.CameraIntrinsics",
        sizeof(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraIntrinsics
    };

    // ----- DepthCorrelatedCoordinateMapper class --------------------
    static constexpr const char* const type_name_DepthCorrelatedCoordinateMapper = "DepthCorrelatedCoordinateMapper";

    static PyObject* _new_DepthCorrelatedCoordinateMapper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DepthCorrelatedCoordinateMapper);
        return nullptr;
    }

    static void _dealloc_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DepthCorrelatedCoordinateMapper_Close(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"MapPoint", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);

                return py::convert(self->obj.MapPoint(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"MapPoints", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 3);

                self->obj.MapPoints(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"UnprojectPoint", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);

                return py::convert(self->obj.UnprojectPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.DepthCorrelatedCoordinateMapper", L"UnprojectPoints", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 2);

                self->obj.UnprojectPoints(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_DepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DepthCorrelatedCoordinateMapper[] = {
        { "close", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_Close), METH_VARARGS, nullptr },
        { "map_point", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_MapPoint), METH_VARARGS, nullptr },
        { "map_points", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_MapPoints), METH_VARARGS, nullptr },
        { "unproject_point", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_UnprojectPoint), METH_VARARGS, nullptr },
        { "unproject_points", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_UnprojectPoints), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DepthCorrelatedCoordinateMapper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DepthCorrelatedCoordinateMapper), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DepthCorrelatedCoordinateMapper), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DepthCorrelatedCoordinateMapper), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DepthCorrelatedCoordinateMapper[] = {
        { }
    };

    static PyType_Slot _type_slots_DepthCorrelatedCoordinateMapper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DepthCorrelatedCoordinateMapper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DepthCorrelatedCoordinateMapper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DepthCorrelatedCoordinateMapper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DepthCorrelatedCoordinateMapper) },
        { },
    };

    static PyType_Spec type_spec_DepthCorrelatedCoordinateMapper =
    {
        "_winsdk_Windows_Media_Devices_Core.DepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DepthCorrelatedCoordinateMapper
    };

    // ----- FrameControlCapabilities class --------------------
    static constexpr const char* const type_name_FrameControlCapabilities = "FrameControlCapabilities";

    static PyObject* _new_FrameControlCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameControlCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameControlCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameControlCapabilities_get_Exposure(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"Exposure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_ExposureCompensation(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"ExposureCompensation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Focus(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"Focus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_IsoSpeed(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"IsoSpeed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_PhotoConfirmationSupported(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"PhotoConfirmationSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoConfirmationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Flash(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameControlCapabilities", L"Flash"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Flash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameControlCapabilities[] = {
        { "_assign_array_", _assign_array_FrameControlCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameControlCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameControlCapabilities[] = {
        { "exposure", reinterpret_cast<getter>(FrameControlCapabilities_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(FrameControlCapabilities_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(FrameControlCapabilities_get_Focus), nullptr, nullptr, nullptr },
        { "iso_speed", reinterpret_cast<getter>(FrameControlCapabilities_get_IsoSpeed), nullptr, nullptr, nullptr },
        { "photo_confirmation_supported", reinterpret_cast<getter>(FrameControlCapabilities_get_PhotoConfirmationSupported), nullptr, nullptr, nullptr },
        { "flash", reinterpret_cast<getter>(FrameControlCapabilities_get_Flash), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameControlCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameControlCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameControlCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameControlCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameControlCapabilities) },
        { },
    };

    static PyType_Spec type_spec_FrameControlCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameControlCapabilities
    };

    // ----- FrameController class --------------------
    static constexpr const char* const type_name_FrameController = "FrameController";

    static PyObject* _new_FrameController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::Core::FrameController instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameController(py::wrapper::Windows::Media::Devices::Core::FrameController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameController_get_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"PhotoConfirmationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotoConfirmationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameController_put_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"PhotoConfirmationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.PhotoConfirmationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"ExposureCompensationControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposureCompensationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_ExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"ExposureControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExposureControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FocusControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"FocusControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"IsoSpeedControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsoSpeedControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FlashControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameController", L"FlashControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlashControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameController[] = {
        { "_assign_array_", _assign_array_FrameController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameController[] = {
        { "photo_confirmation_enabled", reinterpret_cast<getter>(FrameController_get_PhotoConfirmationEnabled), reinterpret_cast<setter>(FrameController_put_PhotoConfirmationEnabled), nullptr, nullptr },
        { "exposure_compensation_control", reinterpret_cast<getter>(FrameController_get_ExposureCompensationControl), nullptr, nullptr, nullptr },
        { "exposure_control", reinterpret_cast<getter>(FrameController_get_ExposureControl), nullptr, nullptr, nullptr },
        { "focus_control", reinterpret_cast<getter>(FrameController_get_FocusControl), nullptr, nullptr, nullptr },
        { "iso_speed_control", reinterpret_cast<getter>(FrameController_get_IsoSpeedControl), nullptr, nullptr, nullptr },
        { "flash_control", reinterpret_cast<getter>(FrameController_get_FlashControl), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameController) },
        { },
    };

    static PyType_Spec type_spec_FrameController =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameController
    };

    // ----- FrameExposureCapabilities class --------------------
    static constexpr const char* const type_name_FrameExposureCapabilities = "FrameExposureCapabilities";

    static PyObject* _new_FrameExposureCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameExposureCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameExposureCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCapabilities", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameExposureCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCapabilities[] = {
        { "_assign_array_", _assign_array_FrameExposureCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameExposureCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameExposureCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameExposureCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameExposureCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureCapabilities) },
        { },
    };

    static PyType_Spec type_spec_FrameExposureCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCapabilities
    };

    // ----- FrameExposureCompensationCapabilities class --------------------
    static constexpr const char* const type_name_FrameExposureCompensationCapabilities = "FrameExposureCompensationCapabilities";

    static PyObject* _new_FrameExposureCompensationCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameExposureCompensationCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationCapabilities", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameExposureCompensationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureCompensationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationCapabilities[] = {
        { "_assign_array_", _assign_array_FrameExposureCompensationCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCompensationCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureCompensationCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureCompensationCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureCompensationCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureCompensationCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureCompensationCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureCompensationCapabilities) },
        { },
    };

    static PyType_Spec type_spec_FrameExposureCompensationCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureCompensationCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationCapabilities
    };

    // ----- FrameExposureCompensationControl class --------------------
    static constexpr const char* const type_name_FrameExposureCompensationControl = "FrameExposureCompensationControl";

    static PyObject* _new_FrameExposureCompensationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameExposureCompensationControl);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureCompensationControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureCompensationControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationControl[] = {
        { "_assign_array_", _assign_array_FrameExposureCompensationControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCompensationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureCompensationControl[] = {
        { "value", reinterpret_cast<getter>(FrameExposureCompensationControl_get_Value), reinterpret_cast<setter>(FrameExposureCompensationControl_put_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureCompensationControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureCompensationControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureCompensationControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureCompensationControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureCompensationControl) },
        { },
    };

    static PyType_Spec type_spec_FrameExposureCompensationControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationControl
    };

    // ----- FrameExposureControl class --------------------
    static constexpr const char* const type_name_FrameExposureControl = "FrameExposureControl";

    static PyObject* _new_FrameExposureControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameExposureControl);
        return nullptr;
    }

    static void _dealloc_FrameExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameExposureControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameExposureControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameExposureControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureControl[] = {
        { "_assign_array_", _assign_array_FrameExposureControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureControl[] = {
        { "value", reinterpret_cast<getter>(FrameExposureControl_get_Value), reinterpret_cast<setter>(FrameExposureControl_put_Value), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameExposureControl_get_Auto), reinterpret_cast<setter>(FrameExposureControl_put_Auto), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameExposureControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameExposureControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameExposureControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameExposureControl) },
        { },
    };

    static PyType_Spec type_spec_FrameExposureControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureControl
    };

    // ----- FrameFlashCapabilities class --------------------
    static constexpr const char* const type_name_FrameFlashCapabilities = "FrameFlashCapabilities";

    static PyObject* _new_FrameFlashCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameFlashCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameFlashCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFlashCapabilities_get_PowerSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashCapabilities", L"PowerSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashCapabilities", L"RedEyeReductionSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedEyeReductionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashCapabilities", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameFlashCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFlashCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashCapabilities[] = {
        { "_assign_array_", _assign_array_FrameFlashCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFlashCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFlashCapabilities[] = {
        { "power_supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_PowerSupported), nullptr, nullptr, nullptr },
        { "red_eye_reduction_supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_RedEyeReductionSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFlashCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFlashCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFlashCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFlashCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFlashCapabilities) },
        { },
    };

    static PyType_Spec type_spec_FrameFlashCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFlashCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashCapabilities
    };

    // ----- FrameFlashControl class --------------------
    static constexpr const char* const type_name_FrameFlashControl = "FrameFlashControl";

    static PyObject* _new_FrameFlashControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameFlashControl);
        return nullptr;
    }

    static void _dealloc_FrameFlashControl(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"RedEyeReduction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RedEyeReduction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"RedEyeReduction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RedEyeReduction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"PowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"PowerPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::Core::FrameFlashMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFlashControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameFlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFlashControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashControl[] = {
        { "_assign_array_", _assign_array_FrameFlashControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFlashControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFlashControl[] = {
        { "red_eye_reduction", reinterpret_cast<getter>(FrameFlashControl_get_RedEyeReduction), reinterpret_cast<setter>(FrameFlashControl_put_RedEyeReduction), nullptr, nullptr },
        { "power_percent", reinterpret_cast<getter>(FrameFlashControl_get_PowerPercent), reinterpret_cast<setter>(FrameFlashControl_put_PowerPercent), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FrameFlashControl_get_Mode), reinterpret_cast<setter>(FrameFlashControl_put_Mode), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameFlashControl_get_Auto), reinterpret_cast<setter>(FrameFlashControl_put_Auto), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFlashControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFlashControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFlashControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFlashControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFlashControl) },
        { },
    };

    static PyType_Spec type_spec_FrameFlashControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashControl
    };

    // ----- FrameFocusCapabilities class --------------------
    static constexpr const char* const type_name_FrameFocusCapabilities = "FrameFocusCapabilities";

    static PyObject* _new_FrameFocusCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameFocusCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameFocusCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFocusCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusCapabilities", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameFocusCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFocusCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusCapabilities[] = {
        { "_assign_array_", _assign_array_FrameFocusCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFocusCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFocusCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameFocusCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameFocusCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameFocusCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameFocusCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFocusCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFocusCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFocusCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFocusCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFocusCapabilities) },
        { },
    };

    static PyType_Spec type_spec_FrameFocusCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFocusCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusCapabilities
    };

    // ----- FrameFocusControl class --------------------
    static constexpr const char* const type_name_FrameFocusControl = "FrameFocusControl";

    static PyObject* _new_FrameFocusControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameFocusControl);
        return nullptr;
    }

    static void _dealloc_FrameFocusControl(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameFocusControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFocusControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameFocusControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameFocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameFocusControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameFocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusControl[] = {
        { "_assign_array_", _assign_array_FrameFocusControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFocusControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFocusControl[] = {
        { "value", reinterpret_cast<getter>(FrameFocusControl_get_Value), reinterpret_cast<setter>(FrameFocusControl_put_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFocusControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameFocusControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameFocusControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameFocusControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameFocusControl) },
        { },
    };

    static PyType_Spec type_spec_FrameFocusControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusControl
    };

    // ----- FrameIsoSpeedCapabilities class --------------------
    static constexpr const char* const type_name_FrameIsoSpeedCapabilities = "FrameIsoSpeedCapabilities";

    static PyObject* _new_FrameIsoSpeedCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameIsoSpeedCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Max"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Min"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Step"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedCapabilities", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameIsoSpeedCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameIsoSpeedCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedCapabilities[] = {
        { "_assign_array_", _assign_array_FrameIsoSpeedCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameIsoSpeedCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameIsoSpeedCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameIsoSpeedCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameIsoSpeedCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameIsoSpeedCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameIsoSpeedCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameIsoSpeedCapabilities) },
        { },
    };

    static PyType_Spec type_spec_FrameIsoSpeedCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameIsoSpeedCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedCapabilities
    };

    // ----- FrameIsoSpeedControl class --------------------
    static constexpr const char* const type_name_FrameIsoSpeedControl = "FrameIsoSpeedControl";

    static PyObject* _new_FrameIsoSpeedControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FrameIsoSpeedControl);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameIsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameIsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.FrameIsoSpeedControl", L"Auto"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FrameIsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameIsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedControl[] = {
        { "_assign_array_", _assign_array_FrameIsoSpeedControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameIsoSpeedControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameIsoSpeedControl[] = {
        { "value", reinterpret_cast<getter>(FrameIsoSpeedControl_get_Value), reinterpret_cast<setter>(FrameIsoSpeedControl_put_Value), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameIsoSpeedControl_get_Auto), reinterpret_cast<setter>(FrameIsoSpeedControl_put_Auto), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameIsoSpeedControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameIsoSpeedControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameIsoSpeedControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameIsoSpeedControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameIsoSpeedControl) },
        { },
    };

    static PyType_Spec type_spec_FrameIsoSpeedControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameIsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedControl
    };

    // ----- VariablePhotoSequenceController class --------------------
    static constexpr const char* const type_name_VariablePhotoSequenceController = "VariablePhotoSequenceController";

    static PyObject* _new_VariablePhotoSequenceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VariablePhotoSequenceController);
        return nullptr;
    }

    static void _dealloc_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VariablePhotoSequenceController_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"GetCurrentFrameRate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"GetHighestConcurrentFrameRate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"PhotosPerSecondLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhotosPerSecondLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VariablePhotoSequenceController_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"PhotosPerSecondLimit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PhotosPerSecondLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_DesiredFrameControllers(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"DesiredFrameControllers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredFrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_FrameCapabilities(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"FrameCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"MaxPhotosPerSecond"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPhotosPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_Supported(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Devices.Core.VariablePhotoSequenceController", L"Supported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VariablePhotoSequenceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VariablePhotoSequenceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VariablePhotoSequenceController[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(VariablePhotoSequenceController_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(VariablePhotoSequenceController_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VariablePhotoSequenceController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VariablePhotoSequenceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VariablePhotoSequenceController[] = {
        { "photos_per_second_limit", reinterpret_cast<getter>(VariablePhotoSequenceController_get_PhotosPerSecondLimit), reinterpret_cast<setter>(VariablePhotoSequenceController_put_PhotosPerSecondLimit), nullptr, nullptr },
        { "desired_frame_controllers", reinterpret_cast<getter>(VariablePhotoSequenceController_get_DesiredFrameControllers), nullptr, nullptr, nullptr },
        { "frame_capabilities", reinterpret_cast<getter>(VariablePhotoSequenceController_get_FrameCapabilities), nullptr, nullptr, nullptr },
        { "max_photos_per_second", reinterpret_cast<getter>(VariablePhotoSequenceController_get_MaxPhotosPerSecond), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(VariablePhotoSequenceController_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VariablePhotoSequenceController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VariablePhotoSequenceController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VariablePhotoSequenceController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VariablePhotoSequenceController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VariablePhotoSequenceController) },
        { },
    };

    static PyType_Spec type_spec_VariablePhotoSequenceController =
    {
        "_winsdk_Windows_Media_Devices_Core.VariablePhotoSequenceController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VariablePhotoSequenceController
    };

    // ----- Windows.Media.Devices.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Devices::Core");

    static PyMethodDef module_methods[] = {
        {"_register_FrameFlashMode", register_FrameFlashMode, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_FrameFlashMode);
        Py_VISIT(state->type_CameraIntrinsics);
        Py_VISIT(state->type_DepthCorrelatedCoordinateMapper);
        Py_VISIT(state->type_FrameControlCapabilities);
        Py_VISIT(state->type_FrameController);
        Py_VISIT(state->type_FrameExposureCapabilities);
        Py_VISIT(state->type_FrameExposureCompensationCapabilities);
        Py_VISIT(state->type_FrameExposureCompensationControl);
        Py_VISIT(state->type_FrameExposureControl);
        Py_VISIT(state->type_FrameFlashCapabilities);
        Py_VISIT(state->type_FrameFlashControl);
        Py_VISIT(state->type_FrameFocusCapabilities);
        Py_VISIT(state->type_FrameFocusControl);
        Py_VISIT(state->type_FrameIsoSpeedCapabilities);
        Py_VISIT(state->type_FrameIsoSpeedControl);
        Py_VISIT(state->type_VariablePhotoSequenceController);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_FrameFlashMode);
        Py_CLEAR(state->type_CameraIntrinsics);
        Py_CLEAR(state->type_DepthCorrelatedCoordinateMapper);
        Py_CLEAR(state->type_FrameControlCapabilities);
        Py_CLEAR(state->type_FrameController);
        Py_CLEAR(state->type_FrameExposureCapabilities);
        Py_CLEAR(state->type_FrameExposureCompensationCapabilities);
        Py_CLEAR(state->type_FrameExposureCompensationControl);
        Py_CLEAR(state->type_FrameExposureControl);
        Py_CLEAR(state->type_FrameFlashCapabilities);
        Py_CLEAR(state->type_FrameFlashControl);
        Py_CLEAR(state->type_FrameFocusCapabilities);
        Py_CLEAR(state->type_FrameFocusControl);
        Py_CLEAR(state->type_FrameIsoSpeedCapabilities);
        Py_CLEAR(state->type_FrameIsoSpeedControl);
        Py_CLEAR(state->type_VariablePhotoSequenceController);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Devices_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::Devices::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_Devices_Core(void) noexcept
{
    using namespace py::cpp::Windows::Media::Devices::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_CameraIntrinsics = py::register_python_type(module.get(), type_name_CameraIntrinsics, &type_spec_CameraIntrinsics, bases.get(), nullptr);
    if (!state->type_CameraIntrinsics)
    {
        return nullptr;
    }

    state->type_DepthCorrelatedCoordinateMapper = py::register_python_type(module.get(), type_name_DepthCorrelatedCoordinateMapper, &type_spec_DepthCorrelatedCoordinateMapper, bases.get(), nullptr);
    if (!state->type_DepthCorrelatedCoordinateMapper)
    {
        return nullptr;
    }

    state->type_FrameControlCapabilities = py::register_python_type(module.get(), type_name_FrameControlCapabilities, &type_spec_FrameControlCapabilities, bases.get(), nullptr);
    if (!state->type_FrameControlCapabilities)
    {
        return nullptr;
    }

    state->type_FrameController = py::register_python_type(module.get(), type_name_FrameController, &type_spec_FrameController, bases.get(), nullptr);
    if (!state->type_FrameController)
    {
        return nullptr;
    }

    state->type_FrameExposureCapabilities = py::register_python_type(module.get(), type_name_FrameExposureCapabilities, &type_spec_FrameExposureCapabilities, bases.get(), nullptr);
    if (!state->type_FrameExposureCapabilities)
    {
        return nullptr;
    }

    state->type_FrameExposureCompensationCapabilities = py::register_python_type(module.get(), type_name_FrameExposureCompensationCapabilities, &type_spec_FrameExposureCompensationCapabilities, bases.get(), nullptr);
    if (!state->type_FrameExposureCompensationCapabilities)
    {
        return nullptr;
    }

    state->type_FrameExposureCompensationControl = py::register_python_type(module.get(), type_name_FrameExposureCompensationControl, &type_spec_FrameExposureCompensationControl, bases.get(), nullptr);
    if (!state->type_FrameExposureCompensationControl)
    {
        return nullptr;
    }

    state->type_FrameExposureControl = py::register_python_type(module.get(), type_name_FrameExposureControl, &type_spec_FrameExposureControl, bases.get(), nullptr);
    if (!state->type_FrameExposureControl)
    {
        return nullptr;
    }

    state->type_FrameFlashCapabilities = py::register_python_type(module.get(), type_name_FrameFlashCapabilities, &type_spec_FrameFlashCapabilities, bases.get(), nullptr);
    if (!state->type_FrameFlashCapabilities)
    {
        return nullptr;
    }

    state->type_FrameFlashControl = py::register_python_type(module.get(), type_name_FrameFlashControl, &type_spec_FrameFlashControl, bases.get(), nullptr);
    if (!state->type_FrameFlashControl)
    {
        return nullptr;
    }

    state->type_FrameFocusCapabilities = py::register_python_type(module.get(), type_name_FrameFocusCapabilities, &type_spec_FrameFocusCapabilities, bases.get(), nullptr);
    if (!state->type_FrameFocusCapabilities)
    {
        return nullptr;
    }

    state->type_FrameFocusControl = py::register_python_type(module.get(), type_name_FrameFocusControl, &type_spec_FrameFocusControl, bases.get(), nullptr);
    if (!state->type_FrameFocusControl)
    {
        return nullptr;
    }

    state->type_FrameIsoSpeedCapabilities = py::register_python_type(module.get(), type_name_FrameIsoSpeedCapabilities, &type_spec_FrameIsoSpeedCapabilities, bases.get(), nullptr);
    if (!state->type_FrameIsoSpeedCapabilities)
    {
        return nullptr;
    }

    state->type_FrameIsoSpeedControl = py::register_python_type(module.get(), type_name_FrameIsoSpeedControl, &type_spec_FrameIsoSpeedControl, bases.get(), nullptr);
    if (!state->type_FrameIsoSpeedControl)
    {
        return nullptr;
    }

    state->type_VariablePhotoSequenceController = py::register_python_type(module.get(), type_name_VariablePhotoSequenceController, &type_spec_VariablePhotoSequenceController, bases.get(), nullptr);
    if (!state->type_VariablePhotoSequenceController)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::Devices::Core::FrameFlashMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameFlashMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameFlashMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::CameraIntrinsics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraIntrinsics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::CameraIntrinsics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DepthCorrelatedCoordinateMapper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameControlCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameControlCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameExposureCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameExposureCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameExposureCompensationCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameExposureCompensationControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameExposureControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameExposureControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameFlashCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameFlashCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameFlashControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameFlashControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameFocusCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameFocusCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameFocusControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameFocusControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameIsoSpeedCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FrameIsoSpeedControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Devices::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Devices::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VariablePhotoSequenceController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController is not registered");
        return nullptr;
    }

    return python_type;
}
