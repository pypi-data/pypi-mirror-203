// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.UI.StartScreen.h"


namespace py::cpp::Windows::UI::StartScreen
{
    struct module_state
    {
        PyObject* type_ForegroundText;
        PyObject* type_JumpListItemKind;
        PyObject* type_JumpListSystemGroupKind;
        PyObject* type_TileMixedRealityModelActivationBehavior;
        PyObject* type_TileOptions;
        PyObject* type_TileSize;
        PyTypeObject* type_JumpList;
        PyTypeObject* type_JumpListItem;
        PyTypeObject* type_SecondaryTile;
        PyTypeObject* type_SecondaryTileVisualElements;
        PyTypeObject* type_StartScreenManager;
        PyTypeObject* type_TileMixedRealityModel;
        PyTypeObject* type_VisualElementsRequest;
        PyTypeObject* type_VisualElementsRequestDeferral;
        PyTypeObject* type_VisualElementsRequestedEventArgs;
    };

    static PyObject* register_ForegroundText(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ForegroundText)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ForegroundText = type;
        Py_INCREF(state->type_ForegroundText);


        Py_RETURN_NONE;
    }

    static PyObject* register_JumpListItemKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_JumpListItemKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_JumpListItemKind = type;
        Py_INCREF(state->type_JumpListItemKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_JumpListSystemGroupKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_JumpListSystemGroupKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_JumpListSystemGroupKind = type;
        Py_INCREF(state->type_JumpListSystemGroupKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_TileMixedRealityModelActivationBehavior(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TileMixedRealityModelActivationBehavior)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TileMixedRealityModelActivationBehavior = type;
        Py_INCREF(state->type_TileMixedRealityModelActivationBehavior);


        Py_RETURN_NONE;
    }

    static PyObject* register_TileOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TileOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TileOptions = type;
        Py_INCREF(state->type_TileOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_TileSize(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TileSize)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TileSize = type;
        Py_INCREF(state->type_TileSize);


        Py_RETURN_NONE;
    }

    // ----- JumpList class --------------------
    static constexpr const char* const type_name_JumpList = "JumpList";

    static PyObject* _new_JumpList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_JumpList);
        return nullptr;
    }

    static void _dealloc_JumpList(py::wrapper::Windows::UI::StartScreen::JumpList* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpList_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpList", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::StartScreen::JumpList::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpList_LoadCurrentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpList", L"LoadCurrentAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::StartScreen::JumpList::LoadCurrentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpList_SaveAsync(py::wrapper::Windows::UI::StartScreen::JumpList* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpList", L"SaveAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpList_get_SystemGroupKind(py::wrapper::Windows::UI::StartScreen::JumpList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpList", L"SystemGroupKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemGroupKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpList_put_SystemGroupKind(py::wrapper::Windows::UI::StartScreen::JumpList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpList", L"SystemGroupKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::JumpListSystemGroupKind>(arg);

            self->obj.SystemGroupKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpList_get_Items(py::wrapper::Windows::UI::StartScreen::JumpList* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpList", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::JumpList>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::JumpList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpList[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(JumpList_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "load_current_async", reinterpret_cast<PyCFunction>(JumpList_LoadCurrentAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(JumpList_SaveAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpList, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpList[] = {
        { "system_group_kind", reinterpret_cast<getter>(JumpList_get_SystemGroupKind), reinterpret_cast<setter>(JumpList_put_SystemGroupKind), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(JumpList_get_Items), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpList[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpList) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpList) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpList) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpList) },
        { },
    };

    static PyType_Spec type_spec_JumpList =
    {
        "_winsdk_Windows_UI_StartScreen.JumpList",
        sizeof(py::wrapper::Windows::UI::StartScreen::JumpList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpList
    };

    // ----- JumpListItem class --------------------
    static constexpr const char* const type_name_JumpListItem = "JumpListItem";

    static PyObject* _new_JumpListItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_JumpListItem);
        return nullptr;
    }

    static void _dealloc_JumpListItem(py::wrapper::Windows::UI::StartScreen::JumpListItem* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItem_CreateSeparator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpListItem", L"CreateSeparator", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::StartScreen::JumpListItem::CreateSeparator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItem_CreateWithArguments(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.JumpListItem", L"CreateWithArguments", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::UI::StartScreen::JumpListItem::CreateWithArguments(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItem_get_Logo(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_Logo(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_GroupName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"GroupName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_GroupName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"GroupName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GroupName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_DisplayName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_DisplayName(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_Description(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItem_put_Description(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItem_get_Arguments(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItem_get_Kind(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItem_get_RemovedByUser(py::wrapper::Windows::UI::StartScreen::JumpListItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.JumpListItem", L"RemovedByUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemovedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::JumpListItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::JumpListItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItem[] = {
        { "create_separator", reinterpret_cast<PyCFunction>(JumpListItem_CreateSeparator), METH_VARARGS | METH_STATIC, nullptr },
        { "create_with_arguments", reinterpret_cast<PyCFunction>(JumpListItem_CreateWithArguments), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_JumpListItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItem[] = {
        { "logo", reinterpret_cast<getter>(JumpListItem_get_Logo), reinterpret_cast<setter>(JumpListItem_put_Logo), nullptr, nullptr },
        { "group_name", reinterpret_cast<getter>(JumpListItem_get_GroupName), reinterpret_cast<setter>(JumpListItem_put_GroupName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(JumpListItem_get_DisplayName), reinterpret_cast<setter>(JumpListItem_put_DisplayName), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(JumpListItem_get_Description), reinterpret_cast<setter>(JumpListItem_put_Description), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(JumpListItem_get_Arguments), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(JumpListItem_get_Kind), nullptr, nullptr, nullptr },
        { "removed_by_user", reinterpret_cast<getter>(JumpListItem_get_RemovedByUser), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItem) },
        { },
    };

    static PyType_Spec type_spec_JumpListItem =
    {
        "_winsdk_Windows_UI_StartScreen.JumpListItem",
        sizeof(py::wrapper::Windows::UI::StartScreen::JumpListItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItem
    };

    // ----- SecondaryTile class --------------------
    static constexpr const char* const type_name_SecondaryTile = "SecondaryTile";

    static PyObject* _new_SecondaryTile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::StartScreen::TileSize>(args, 4);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::StartScreen::TileOptions>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::StartScreen::TileOptions>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 6);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{ param0, param1, param2, param3, param4, param5, param6 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::StartScreen::SecondaryTile instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::StartScreen::SecondaryTile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecondaryTile(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecondaryTile_Exists(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Exists", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::StartScreen::SecondaryTile::Exists(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"FindAllAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::StartScreen::SecondaryTile::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"FindAllAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::StartScreen::SecondaryTile::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_FindAllForPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"FindAllForPackageAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::StartScreen::SecondaryTile::FindAllForPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestCreateAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestCreateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.RequestCreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestCreateForSelectionAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateForSelectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.RequestCreateForSelectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestCreateForSelectionAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert(self->obj.RequestCreateForSelectionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestDeleteAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.RequestDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_RequestDeleteForSelectionAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteForSelectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.RequestDeleteForSelectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RequestDeleteForSelectionAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert(self->obj.RequestDeleteForSelectionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_UpdateAsync(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.SecondaryTile", L"UpdateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UpdateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_get_ShortName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ShortName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShortName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_ShortName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ShortName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ShortName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_TileId(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_TileId(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TileId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_LockScreenDisplayBadgeAndTileText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenDisplayBadgeAndTileText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LockScreenDisplayBadgeAndTileText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_LockScreenDisplayBadgeAndTileText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenDisplayBadgeAndTileText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.LockScreenDisplayBadgeAndTileText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_LockScreenBadgeLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenBadgeLogo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LockScreenBadgeLogo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_LockScreenBadgeLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"LockScreenBadgeLogo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.LockScreenBadgeLogo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_Arguments(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_Arguments(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Arguments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ForegroundText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForegroundText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"ForegroundText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::ForegroundText>(arg);

            self->obj.ForegroundText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_DisplayName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_DisplayName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_WideLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"WideLogo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WideLogo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_WideLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"WideLogo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.WideLogo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_TileOptions(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_TileOptions(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"TileOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::TileOptions>(arg);

            self->obj.TileOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_SmallLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"SmallLogo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmallLogo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_SmallLogo(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"SmallLogo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.SmallLogo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_RoamingEnabled(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RoamingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoamingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_RoamingEnabled(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"RoamingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RoamingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_PhoneticName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"PhoneticName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneticName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTile_put_PhoneticName(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"PhoneticName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PhoneticName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTile_get_VisualElements(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTile", L"VisualElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VisualElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_add_VisualElementsRequested(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.StartScreen.SecondaryTile", L"VisualElementsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::StartScreen::SecondaryTile, winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>>(arg);

            return py::convert(self->obj.VisualElementsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SecondaryTile_remove_VisualElementsRequested(py::wrapper::Windows::UI::StartScreen::SecondaryTile* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.StartScreen.SecondaryTile", L"VisualElementsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisualElementsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SecondaryTile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::SecondaryTile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecondaryTile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::SecondaryTile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryTile[] = {
        { "exists", reinterpret_cast<PyCFunction>(SecondaryTile_Exists), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(SecondaryTile_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_for_package_async", reinterpret_cast<PyCFunction>(SecondaryTile_FindAllForPackageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_create_async", reinterpret_cast<PyCFunction>(SecondaryTile_RequestCreateAsync), METH_VARARGS, nullptr },
        { "request_create_for_selection_async", reinterpret_cast<PyCFunction>(SecondaryTile_RequestCreateForSelectionAsync), METH_VARARGS, nullptr },
        { "request_delete_async", reinterpret_cast<PyCFunction>(SecondaryTile_RequestDeleteAsync), METH_VARARGS, nullptr },
        { "request_delete_for_selection_async", reinterpret_cast<PyCFunction>(SecondaryTile_RequestDeleteForSelectionAsync), METH_VARARGS, nullptr },
        { "update_async", reinterpret_cast<PyCFunction>(SecondaryTile_UpdateAsync), METH_VARARGS, nullptr },
        { "add_visual_elements_requested", reinterpret_cast<PyCFunction>(SecondaryTile_add_VisualElementsRequested), METH_O, nullptr },
        { "remove_visual_elements_requested", reinterpret_cast<PyCFunction>(SecondaryTile_remove_VisualElementsRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_SecondaryTile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecondaryTile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SecondaryTile[] = {
        { "short_name", reinterpret_cast<getter>(SecondaryTile_get_ShortName), reinterpret_cast<setter>(SecondaryTile_put_ShortName), nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(SecondaryTile_get_Logo), reinterpret_cast<setter>(SecondaryTile_put_Logo), nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(SecondaryTile_get_TileId), reinterpret_cast<setter>(SecondaryTile_put_TileId), nullptr, nullptr },
        { "lock_screen_display_badge_and_tile_text", reinterpret_cast<getter>(SecondaryTile_get_LockScreenDisplayBadgeAndTileText), reinterpret_cast<setter>(SecondaryTile_put_LockScreenDisplayBadgeAndTileText), nullptr, nullptr },
        { "lock_screen_badge_logo", reinterpret_cast<getter>(SecondaryTile_get_LockScreenBadgeLogo), reinterpret_cast<setter>(SecondaryTile_put_LockScreenBadgeLogo), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(SecondaryTile_get_Arguments), reinterpret_cast<setter>(SecondaryTile_put_Arguments), nullptr, nullptr },
        { "foreground_text", reinterpret_cast<getter>(SecondaryTile_get_ForegroundText), reinterpret_cast<setter>(SecondaryTile_put_ForegroundText), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(SecondaryTile_get_DisplayName), reinterpret_cast<setter>(SecondaryTile_put_DisplayName), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(SecondaryTile_get_BackgroundColor), reinterpret_cast<setter>(SecondaryTile_put_BackgroundColor), nullptr, nullptr },
        { "wide_logo", reinterpret_cast<getter>(SecondaryTile_get_WideLogo), reinterpret_cast<setter>(SecondaryTile_put_WideLogo), nullptr, nullptr },
        { "tile_options", reinterpret_cast<getter>(SecondaryTile_get_TileOptions), reinterpret_cast<setter>(SecondaryTile_put_TileOptions), nullptr, nullptr },
        { "small_logo", reinterpret_cast<getter>(SecondaryTile_get_SmallLogo), reinterpret_cast<setter>(SecondaryTile_put_SmallLogo), nullptr, nullptr },
        { "roaming_enabled", reinterpret_cast<getter>(SecondaryTile_get_RoamingEnabled), reinterpret_cast<setter>(SecondaryTile_put_RoamingEnabled), nullptr, nullptr },
        { "phonetic_name", reinterpret_cast<getter>(SecondaryTile_get_PhoneticName), reinterpret_cast<setter>(SecondaryTile_put_PhoneticName), nullptr, nullptr },
        { "visual_elements", reinterpret_cast<getter>(SecondaryTile_get_VisualElements), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SecondaryTile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecondaryTile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecondaryTile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecondaryTile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecondaryTile) },
        { },
    };

    static PyType_Spec type_spec_SecondaryTile =
    {
        "_winsdk_Windows_UI_StartScreen.SecondaryTile",
        sizeof(py::wrapper::Windows::UI::StartScreen::SecondaryTile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryTile
    };

    // ----- SecondaryTileVisualElements class --------------------
    static constexpr const char* const type_name_SecondaryTileVisualElements = "SecondaryTileVisualElements";

    static PyObject* _new_SecondaryTileVisualElements(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SecondaryTileVisualElements);
        return nullptr;
    }

    static void _dealloc_SecondaryTileVisualElements(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecondaryTileVisualElements_get_Square150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square150x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Square150x150Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square150x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Square150x150Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ShowNameOnWide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnWide310x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowNameOnWide310x150Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ShowNameOnWide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnWide310x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowNameOnWide310x150Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ShowNameOnSquare310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare310x310Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowNameOnSquare310x310Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ShowNameOnSquare310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare310x310Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowNameOnSquare310x310Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ShowNameOnSquare150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare150x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowNameOnSquare150x150Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ShowNameOnSquare150x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ShowNameOnSquare150x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowNameOnSquare150x150Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ForegroundText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ForegroundText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_ForegroundText(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"ForegroundText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::ForegroundText>(arg);

            self->obj.ForegroundText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_BackgroundColor(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Wide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Wide310x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Wide310x150Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Wide310x150Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Wide310x150Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Wide310x150Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square70x70Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square70x70Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Square70x70Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square70x70Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square70x70Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Square70x70Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square310x310Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Square310x310Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square310x310Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square310x310Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Square310x310Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square30x30Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square30x30Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Square30x30Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square30x30Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square30x30Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Square30x30Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square71x71Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square71x71Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Square71x71Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square71x71Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square71x71Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Square71x71Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_Square44x44Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square44x44Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Square44x44Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SecondaryTileVisualElements_put_Square44x44Logo(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"Square44x44Logo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Square44x44Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SecondaryTileVisualElements_get_MixedRealityModel(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.SecondaryTileVisualElements", L"MixedRealityModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MixedRealityModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SecondaryTileVisualElements(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SecondaryTileVisualElements(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryTileVisualElements[] = {
        { "_assign_array_", _assign_array_SecondaryTileVisualElements, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecondaryTileVisualElements), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SecondaryTileVisualElements[] = {
        { "square150x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square150x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square150x150Logo), nullptr, nullptr },
        { "show_name_on_wide310x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ShowNameOnWide310x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ShowNameOnWide310x150Logo), nullptr, nullptr },
        { "show_name_on_square310x310_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ShowNameOnSquare310x310Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ShowNameOnSquare310x310Logo), nullptr, nullptr },
        { "show_name_on_square150x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ShowNameOnSquare150x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ShowNameOnSquare150x150Logo), nullptr, nullptr },
        { "foreground_text", reinterpret_cast<getter>(SecondaryTileVisualElements_get_ForegroundText), reinterpret_cast<setter>(SecondaryTileVisualElements_put_ForegroundText), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(SecondaryTileVisualElements_get_BackgroundColor), reinterpret_cast<setter>(SecondaryTileVisualElements_put_BackgroundColor), nullptr, nullptr },
        { "wide310x150_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Wide310x150Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Wide310x150Logo), nullptr, nullptr },
        { "square70x70_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square70x70Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square70x70Logo), nullptr, nullptr },
        { "square310x310_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square310x310Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square310x310Logo), nullptr, nullptr },
        { "square30x30_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square30x30Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square30x30Logo), nullptr, nullptr },
        { "square71x71_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square71x71Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square71x71Logo), nullptr, nullptr },
        { "square44x44_logo", reinterpret_cast<getter>(SecondaryTileVisualElements_get_Square44x44Logo), reinterpret_cast<setter>(SecondaryTileVisualElements_put_Square44x44Logo), nullptr, nullptr },
        { "mixed_reality_model", reinterpret_cast<getter>(SecondaryTileVisualElements_get_MixedRealityModel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SecondaryTileVisualElements[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SecondaryTileVisualElements) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SecondaryTileVisualElements) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SecondaryTileVisualElements) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SecondaryTileVisualElements) },
        { },
    };

    static PyType_Spec type_spec_SecondaryTileVisualElements =
    {
        "_winsdk_Windows_UI_StartScreen.SecondaryTileVisualElements",
        sizeof(py::wrapper::Windows::UI::StartScreen::SecondaryTileVisualElements),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryTileVisualElements
    };

    // ----- StartScreenManager class --------------------
    static constexpr const char* const type_name_StartScreenManager = "StartScreenManager";

    static PyObject* _new_StartScreenManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StartScreenManager);
        return nullptr;
    }

    static void _dealloc_StartScreenManager(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartScreenManager_ContainsAppListEntryAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"ContainsAppListEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.ContainsAppListEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_ContainsSecondaryTileAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"ContainsSecondaryTileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ContainsSecondaryTileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::StartScreen::StartScreenManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::StartScreen::StartScreenManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_RequestAddAppListEntryAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"RequestAddAppListEntryAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.RequestAddAppListEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_SupportsAppListEntry(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"SupportsAppListEntry", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.SupportsAppListEntry(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_TryRemoveSecondaryTileAsync(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.StartScreenManager", L"TryRemoveSecondaryTileAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryRemoveSecondaryTileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartScreenManager_get_User(py::wrapper::Windows::UI::StartScreen::StartScreenManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.StartScreenManager", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StartScreenManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::StartScreenManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StartScreenManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::StartScreenManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartScreenManager[] = {
        { "contains_app_list_entry_async", reinterpret_cast<PyCFunction>(StartScreenManager_ContainsAppListEntryAsync), METH_VARARGS, nullptr },
        { "contains_secondary_tile_async", reinterpret_cast<PyCFunction>(StartScreenManager_ContainsSecondaryTileAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(StartScreenManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(StartScreenManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "request_add_app_list_entry_async", reinterpret_cast<PyCFunction>(StartScreenManager_RequestAddAppListEntryAsync), METH_VARARGS, nullptr },
        { "supports_app_list_entry", reinterpret_cast<PyCFunction>(StartScreenManager_SupportsAppListEntry), METH_VARARGS, nullptr },
        { "try_remove_secondary_tile_async", reinterpret_cast<PyCFunction>(StartScreenManager_TryRemoveSecondaryTileAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StartScreenManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartScreenManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StartScreenManager[] = {
        { "user", reinterpret_cast<getter>(StartScreenManager_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StartScreenManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StartScreenManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StartScreenManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StartScreenManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StartScreenManager) },
        { },
    };

    static PyType_Spec type_spec_StartScreenManager =
    {
        "_winsdk_Windows_UI_StartScreen.StartScreenManager",
        sizeof(py::wrapper::Windows::UI::StartScreen::StartScreenManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartScreenManager
    };

    // ----- TileMixedRealityModel class --------------------
    static constexpr const char* const type_name_TileMixedRealityModel = "TileMixedRealityModel";

    static PyObject* _new_TileMixedRealityModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileMixedRealityModel);
        return nullptr;
    }

    static void _dealloc_TileMixedRealityModel(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileMixedRealityModel_get_Uri(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileMixedRealityModel_put_Uri(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileMixedRealityModel_get_BoundingBox(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"BoundingBox"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BoundingBox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileMixedRealityModel_put_BoundingBox(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"BoundingBox"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Perception::Spatial::SpatialBoundingBox>>(arg);

            self->obj.BoundingBox(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileMixedRealityModel_get_ActivationBehavior(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"ActivationBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivationBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileMixedRealityModel_put_ActivationBehavior(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.TileMixedRealityModel", L"ActivationBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::TileMixedRealityModelActivationBehavior>(arg);

            self->obj.ActivationBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TileMixedRealityModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::TileMixedRealityModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileMixedRealityModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::TileMixedRealityModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileMixedRealityModel[] = {
        { "_assign_array_", _assign_array_TileMixedRealityModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileMixedRealityModel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileMixedRealityModel[] = {
        { "uri", reinterpret_cast<getter>(TileMixedRealityModel_get_Uri), reinterpret_cast<setter>(TileMixedRealityModel_put_Uri), nullptr, nullptr },
        { "bounding_box", reinterpret_cast<getter>(TileMixedRealityModel_get_BoundingBox), reinterpret_cast<setter>(TileMixedRealityModel_put_BoundingBox), nullptr, nullptr },
        { "activation_behavior", reinterpret_cast<getter>(TileMixedRealityModel_get_ActivationBehavior), reinterpret_cast<setter>(TileMixedRealityModel_put_ActivationBehavior), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileMixedRealityModel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileMixedRealityModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileMixedRealityModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileMixedRealityModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileMixedRealityModel) },
        { },
    };

    static PyType_Spec type_spec_TileMixedRealityModel =
    {
        "_winsdk_Windows_UI_StartScreen.TileMixedRealityModel",
        sizeof(py::wrapper::Windows::UI::StartScreen::TileMixedRealityModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileMixedRealityModel
    };

    // ----- VisualElementsRequest class --------------------
    static constexpr const char* const type_name_VisualElementsRequest = "VisualElementsRequest";

    static PyObject* _new_VisualElementsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VisualElementsRequest);
        return nullptr;
    }

    static void _dealloc_VisualElementsRequest(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualElementsRequest_GetDeferral(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualElementsRequest_get_AlternateVisualElements(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"AlternateVisualElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlternateVisualElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualElementsRequest_get_Deadline(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VisualElementsRequest_get_VisualElements(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequest", L"VisualElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VisualElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualElementsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::VisualElementsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualElementsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::VisualElementsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualElementsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(VisualElementsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualElementsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualElementsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualElementsRequest[] = {
        { "alternate_visual_elements", reinterpret_cast<getter>(VisualElementsRequest_get_AlternateVisualElements), nullptr, nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(VisualElementsRequest_get_Deadline), nullptr, nullptr, nullptr },
        { "visual_elements", reinterpret_cast<getter>(VisualElementsRequest_get_VisualElements), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualElementsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualElementsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualElementsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualElementsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualElementsRequest) },
        { },
    };

    static PyType_Spec type_spec_VisualElementsRequest =
    {
        "_winsdk_Windows_UI_StartScreen.VisualElementsRequest",
        sizeof(py::wrapper::Windows::UI::StartScreen::VisualElementsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualElementsRequest
    };

    // ----- VisualElementsRequestDeferral class --------------------
    static constexpr const char* const type_name_VisualElementsRequestDeferral = "VisualElementsRequestDeferral";

    static PyObject* _new_VisualElementsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VisualElementsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_VisualElementsRequestDeferral(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualElementsRequestDeferral_Complete(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.StartScreen.VisualElementsRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualElementsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualElementsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualElementsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(VisualElementsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_VisualElementsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualElementsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualElementsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_VisualElementsRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualElementsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualElementsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualElementsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualElementsRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_VisualElementsRequestDeferral =
    {
        "_winsdk_Windows_UI_StartScreen.VisualElementsRequestDeferral",
        sizeof(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualElementsRequestDeferral
    };

    // ----- VisualElementsRequestedEventArgs class --------------------
    static constexpr const char* const type_name_VisualElementsRequestedEventArgs = "VisualElementsRequestedEventArgs";

    static PyObject* _new_VisualElementsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VisualElementsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_VisualElementsRequestedEventArgs(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualElementsRequestedEventArgs_get_Request(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.StartScreen.VisualElementsRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualElementsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualElementsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualElementsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_VisualElementsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualElementsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualElementsRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(VisualElementsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VisualElementsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualElementsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualElementsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualElementsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualElementsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_VisualElementsRequestedEventArgs =
    {
        "_winsdk_Windows_UI_StartScreen.VisualElementsRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::StartScreen::VisualElementsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualElementsRequestedEventArgs
    };

    // ----- Windows.UI.StartScreen Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::StartScreen");

    static PyMethodDef module_methods[] = {
        {"_register_ForegroundText", register_ForegroundText, METH_O, "registers type"},
        {"_register_JumpListItemKind", register_JumpListItemKind, METH_O, "registers type"},
        {"_register_JumpListSystemGroupKind", register_JumpListSystemGroupKind, METH_O, "registers type"},
        {"_register_TileMixedRealityModelActivationBehavior", register_TileMixedRealityModelActivationBehavior, METH_O, "registers type"},
        {"_register_TileOptions", register_TileOptions, METH_O, "registers type"},
        {"_register_TileSize", register_TileSize, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ForegroundText);
        Py_VISIT(state->type_JumpListItemKind);
        Py_VISIT(state->type_JumpListSystemGroupKind);
        Py_VISIT(state->type_TileMixedRealityModelActivationBehavior);
        Py_VISIT(state->type_TileOptions);
        Py_VISIT(state->type_TileSize);
        Py_VISIT(state->type_JumpList);
        Py_VISIT(state->type_JumpListItem);
        Py_VISIT(state->type_SecondaryTile);
        Py_VISIT(state->type_SecondaryTileVisualElements);
        Py_VISIT(state->type_StartScreenManager);
        Py_VISIT(state->type_TileMixedRealityModel);
        Py_VISIT(state->type_VisualElementsRequest);
        Py_VISIT(state->type_VisualElementsRequestDeferral);
        Py_VISIT(state->type_VisualElementsRequestedEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ForegroundText);
        Py_CLEAR(state->type_JumpListItemKind);
        Py_CLEAR(state->type_JumpListSystemGroupKind);
        Py_CLEAR(state->type_TileMixedRealityModelActivationBehavior);
        Py_CLEAR(state->type_TileOptions);
        Py_CLEAR(state->type_TileSize);
        Py_CLEAR(state->type_JumpList);
        Py_CLEAR(state->type_JumpListItem);
        Py_CLEAR(state->type_SecondaryTile);
        Py_CLEAR(state->type_SecondaryTileVisualElements);
        Py_CLEAR(state->type_StartScreenManager);
        Py_CLEAR(state->type_TileMixedRealityModel);
        Py_CLEAR(state->type_VisualElementsRequest);
        Py_CLEAR(state->type_VisualElementsRequestDeferral);
        Py_CLEAR(state->type_VisualElementsRequestedEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_StartScreen",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::StartScreen

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_StartScreen(void) noexcept
{
    using namespace py::cpp::Windows::UI::StartScreen;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_JumpList = py::register_python_type(module.get(), type_name_JumpList, &type_spec_JumpList, bases.get(), nullptr);
    if (!state->type_JumpList)
    {
        return nullptr;
    }

    state->type_JumpListItem = py::register_python_type(module.get(), type_name_JumpListItem, &type_spec_JumpListItem, bases.get(), nullptr);
    if (!state->type_JumpListItem)
    {
        return nullptr;
    }

    state->type_SecondaryTile = py::register_python_type(module.get(), type_name_SecondaryTile, &type_spec_SecondaryTile, bases.get(), nullptr);
    if (!state->type_SecondaryTile)
    {
        return nullptr;
    }

    state->type_SecondaryTileVisualElements = py::register_python_type(module.get(), type_name_SecondaryTileVisualElements, &type_spec_SecondaryTileVisualElements, bases.get(), nullptr);
    if (!state->type_SecondaryTileVisualElements)
    {
        return nullptr;
    }

    state->type_StartScreenManager = py::register_python_type(module.get(), type_name_StartScreenManager, &type_spec_StartScreenManager, bases.get(), nullptr);
    if (!state->type_StartScreenManager)
    {
        return nullptr;
    }

    state->type_TileMixedRealityModel = py::register_python_type(module.get(), type_name_TileMixedRealityModel, &type_spec_TileMixedRealityModel, bases.get(), nullptr);
    if (!state->type_TileMixedRealityModel)
    {
        return nullptr;
    }

    state->type_VisualElementsRequest = py::register_python_type(module.get(), type_name_VisualElementsRequest, &type_spec_VisualElementsRequest, bases.get(), nullptr);
    if (!state->type_VisualElementsRequest)
    {
        return nullptr;
    }

    state->type_VisualElementsRequestDeferral = py::register_python_type(module.get(), type_name_VisualElementsRequestDeferral, &type_spec_VisualElementsRequestDeferral, bases.get(), nullptr);
    if (!state->type_VisualElementsRequestDeferral)
    {
        return nullptr;
    }

    state->type_VisualElementsRequestedEventArgs = py::register_python_type(module.get(), type_name_VisualElementsRequestedEventArgs, &type_spec_VisualElementsRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_VisualElementsRequestedEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::StartScreen::ForegroundText>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ForegroundText;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::ForegroundText is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::StartScreen::JumpListItemKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JumpListItemKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::JumpListItemKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::StartScreen::JumpListSystemGroupKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JumpListSystemGroupKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::JumpListSystemGroupKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::StartScreen::TileMixedRealityModelActivationBehavior>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileMixedRealityModelActivationBehavior;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::TileMixedRealityModelActivationBehavior is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::StartScreen::TileOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::TileOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::StartScreen::TileSize>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileSize;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::TileSize is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::JumpList>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JumpList;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::JumpList is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::JumpListItem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JumpListItem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::JumpListItem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::SecondaryTile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecondaryTile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::SecondaryTile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::SecondaryTileVisualElements>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecondaryTileVisualElements;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::SecondaryTileVisualElements is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::StartScreenManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StartScreenManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::StartScreenManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::TileMixedRealityModel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileMixedRealityModel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::TileMixedRealityModel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::VisualElementsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualElementsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::VisualElementsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualElementsRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::VisualElementsRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::StartScreen;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::StartScreen");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VisualElementsRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::StartScreen::VisualElementsRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
