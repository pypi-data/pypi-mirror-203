// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.System.Profile.h"


namespace py::cpp::Windows::System::Profile
{
    struct module_state
    {
        PyObject* type_PlatformDataCollectionLevel;
        PyObject* type_SystemIdentificationSource;
        PyObject* type_SystemOutOfBoxExperienceState;
        PyObject* type_UnsupportedAppRequirementReasons;
        PyTypeObject* type_AnalyticsInfo;
        PyTypeObject* type_AnalyticsVersionInfo;
        PyTypeObject* type_AppApplicability;
        PyTypeObject* type_EducationSettings;
        PyTypeObject* type_HardwareIdentification;
        PyTypeObject* type_HardwareToken;
        PyTypeObject* type_KnownRetailInfoProperties;
        PyTypeObject* type_PlatformDiagnosticsAndUsageDataSettings;
        PyTypeObject* type_RetailInfo;
        PyTypeObject* type_SharedModeSettings;
        PyTypeObject* type_SmartAppControlPolicy;
        PyTypeObject* type_SystemIdentification;
        PyTypeObject* type_SystemIdentificationInfo;
        PyTypeObject* type_SystemSetupInfo;
        PyTypeObject* type_UnsupportedAppRequirement;
        PyTypeObject* type_WindowsIntegrityPolicy;
    };

    static PyObject* register_PlatformDataCollectionLevel(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PlatformDataCollectionLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PlatformDataCollectionLevel = type;
        Py_INCREF(state->type_PlatformDataCollectionLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_SystemIdentificationSource(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SystemIdentificationSource)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SystemIdentificationSource = type;
        Py_INCREF(state->type_SystemIdentificationSource);


        Py_RETURN_NONE;
    }

    static PyObject* register_SystemOutOfBoxExperienceState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SystemOutOfBoxExperienceState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SystemOutOfBoxExperienceState = type;
        Py_INCREF(state->type_SystemOutOfBoxExperienceState);


        Py_RETURN_NONE;
    }

    static PyObject* register_UnsupportedAppRequirementReasons(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UnsupportedAppRequirementReasons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UnsupportedAppRequirementReasons = type;
        Py_INCREF(state->type_UnsupportedAppRequirementReasons);


        Py_RETURN_NONE;
    }

    // ----- AnalyticsInfo class --------------------
    static constexpr const char* const type_name_AnalyticsInfo = "AnalyticsInfo";

    static PyObject* _new_AnalyticsInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AnalyticsInfo);
        return nullptr;
    }

    static PyObject* AnalyticsInfo_GetSystemPropertiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.AnalyticsInfo", L"GetSystemPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::System::Profile::AnalyticsInfo::GetSystemPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnalyticsInfo_get_DeviceForm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsInfo", L"DeviceForm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::AnalyticsInfo::DeviceForm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsInfo_get_VersionInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsInfo", L"VersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::AnalyticsInfo::VersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnalyticsInfo[] = {
        { "get_system_properties_async", reinterpret_cast<PyCFunction>(AnalyticsInfo_GetSystemPropertiesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnalyticsInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_AnalyticsInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnalyticsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnalyticsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnalyticsInfo) },
        { },
    };

    static PyType_Spec type_spec_AnalyticsInfo =
    {
        "_winsdk_Windows_System_Profile.AnalyticsInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnalyticsInfo
    };

    static PyGetSetDef getset_AnalyticsInfo_Meta[] = {
        { "device_form", reinterpret_cast<getter>(AnalyticsInfo_get_DeviceForm), nullptr, nullptr, nullptr },
        { "version_info", reinterpret_cast<getter>(AnalyticsInfo_get_VersionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AnalyticsInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnalyticsInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_AnalyticsInfo_Meta =
    {
        "_winsdk_Windows_System_Profile.AnalyticsInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AnalyticsInfo_Meta
    };

    // ----- AnalyticsVersionInfo class --------------------
    static constexpr const char* const type_name_AnalyticsVersionInfo = "AnalyticsVersionInfo";

    static PyObject* _new_AnalyticsVersionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AnalyticsVersionInfo);
        return nullptr;
    }

    static void _dealloc_AnalyticsVersionInfo(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnalyticsVersionInfo_get_DeviceFamily(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"DeviceFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsVersionInfo_get_DeviceFamilyVersion(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"DeviceFamilyVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceFamilyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsVersionInfo_get_ProductName(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"ProductName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnalyticsVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::AnalyticsVersionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnalyticsVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::AnalyticsVersionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnalyticsVersionInfo[] = {
        { "_assign_array_", _assign_array_AnalyticsVersionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnalyticsVersionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnalyticsVersionInfo[] = {
        { "device_family", reinterpret_cast<getter>(AnalyticsVersionInfo_get_DeviceFamily), nullptr, nullptr, nullptr },
        { "device_family_version", reinterpret_cast<getter>(AnalyticsVersionInfo_get_DeviceFamilyVersion), nullptr, nullptr, nullptr },
        { "product_name", reinterpret_cast<getter>(AnalyticsVersionInfo_get_ProductName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AnalyticsVersionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnalyticsVersionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnalyticsVersionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnalyticsVersionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnalyticsVersionInfo) },
        { },
    };

    static PyType_Spec type_spec_AnalyticsVersionInfo =
    {
        "_winsdk_Windows_System_Profile.AnalyticsVersionInfo",
        sizeof(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnalyticsVersionInfo
    };

    // ----- AppApplicability class --------------------
    static constexpr const char* const type_name_AppApplicability = "AppApplicability";

    static PyObject* _new_AppApplicability(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppApplicability);
        return nullptr;
    }

    static PyObject* AppApplicability_GetUnsupportedAppRequirements(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.AppApplicability", L"GetUnsupportedAppRequirements", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::System::Profile::AppApplicability::GetUnsupportedAppRequirements(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppApplicability[] = {
        { "get_unsupported_app_requirements", reinterpret_cast<PyCFunction>(AppApplicability_GetUnsupportedAppRequirements), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppApplicability[] = {
        { }
    };

    static PyType_Slot _type_slots_AppApplicability[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppApplicability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppApplicability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppApplicability) },
        { },
    };

    static PyType_Spec type_spec_AppApplicability =
    {
        "_winsdk_Windows_System_Profile.AppApplicability",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppApplicability
    };

    // ----- EducationSettings class --------------------
    static constexpr const char* const type_name_EducationSettings = "EducationSettings";

    static PyObject* _new_EducationSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EducationSettings);
        return nullptr;
    }

    static PyObject* EducationSettings_get_IsEducationEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.EducationSettings", L"IsEducationEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::EducationSettings::IsEducationEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EducationSettings[] = {
        { }
    };

    static PyGetSetDef _getset_EducationSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_EducationSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EducationSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EducationSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EducationSettings) },
        { },
    };

    static PyType_Spec type_spec_EducationSettings =
    {
        "_winsdk_Windows_System_Profile.EducationSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EducationSettings
    };

    static PyGetSetDef getset_EducationSettings_Meta[] = {
        { "is_education_environment", reinterpret_cast<getter>(EducationSettings_get_IsEducationEnvironment), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_EducationSettings_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EducationSettings_Meta) },
        { }
    };

    static PyType_Spec type_spec_EducationSettings_Meta =
    {
        "_winsdk_Windows_System_Profile.EducationSettings_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EducationSettings_Meta
    };

    // ----- HardwareIdentification class --------------------
    static constexpr const char* const type_name_HardwareIdentification = "HardwareIdentification";

    static PyObject* _new_HardwareIdentification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HardwareIdentification);
        return nullptr;
    }

    static PyObject* HardwareIdentification_GetPackageSpecificToken(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.HardwareIdentification", L"GetPackageSpecificToken", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::System::Profile::HardwareIdentification::GetPackageSpecificToken(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_HardwareIdentification[] = {
        { "get_package_specific_token", reinterpret_cast<PyCFunction>(HardwareIdentification_GetPackageSpecificToken), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HardwareIdentification[] = {
        { }
    };

    static PyType_Slot _type_slots_HardwareIdentification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HardwareIdentification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HardwareIdentification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HardwareIdentification) },
        { },
    };

    static PyType_Spec type_spec_HardwareIdentification =
    {
        "_winsdk_Windows_System_Profile.HardwareIdentification",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HardwareIdentification
    };

    // ----- HardwareToken class --------------------
    static constexpr const char* const type_name_HardwareToken = "HardwareToken";

    static PyObject* _new_HardwareToken(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HardwareToken);
        return nullptr;
    }

    static void _dealloc_HardwareToken(py::wrapper::Windows::System::Profile::HardwareToken* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HardwareToken_get_Certificate(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Certificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HardwareToken_get_Id(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HardwareToken_get_Signature(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Signature"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Signature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HardwareToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::HardwareToken>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HardwareToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::HardwareToken>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HardwareToken[] = {
        { "_assign_array_", _assign_array_HardwareToken, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HardwareToken), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HardwareToken[] = {
        { "certificate", reinterpret_cast<getter>(HardwareToken_get_Certificate), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HardwareToken_get_Id), nullptr, nullptr, nullptr },
        { "signature", reinterpret_cast<getter>(HardwareToken_get_Signature), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HardwareToken[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HardwareToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HardwareToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HardwareToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HardwareToken) },
        { },
    };

    static PyType_Spec type_spec_HardwareToken =
    {
        "_winsdk_Windows_System_Profile.HardwareToken",
        sizeof(py::wrapper::Windows::System::Profile::HardwareToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HardwareToken
    };

    // ----- KnownRetailInfoProperties class --------------------
    static constexpr const char* const type_name_KnownRetailInfoProperties = "KnownRetailInfoProperties";

    static PyObject* _new_KnownRetailInfoProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownRetailInfoProperties);
        return nullptr;
    }

    static PyObject* KnownRetailInfoProperties_get_BatteryLifeDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"BatteryLifeDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::BatteryLifeDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_DisplayDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"DisplayDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::DisplayDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_DisplayModelName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"DisplayModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::DisplayModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_FormFactor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"FormFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::FormFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_FrontCameraDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"FrontCameraDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::FrontCameraDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_GraphicsDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"GraphicsDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::GraphicsDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasNfc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasNfc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::HasNfc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasOpticalDrive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasOpticalDrive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::HasOpticalDrive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasSdSlot(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasSdSlot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::HasSdSlot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_IsFeatured(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"IsFeatured"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::IsFeatured());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_IsOfficeInstalled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"IsOfficeInstalled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::IsOfficeInstalled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ManufacturerName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ManufacturerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ManufacturerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Memory(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Memory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::Memory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ModelName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Price(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ProcessorDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ProcessorDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ProcessorDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_RearCameraDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"RearCameraDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::RearCameraDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_RetailAccessCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"RetailAccessCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::RetailAccessCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ScreenSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ScreenSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ScreenSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_StorageDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"StorageDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::StorageDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Weight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Weight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_WindowsEdition(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"WindowsEdition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::WindowsEdition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRetailInfoProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownRetailInfoProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRetailInfoProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRetailInfoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRetailInfoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRetailInfoProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownRetailInfoProperties =
    {
        "_winsdk_Windows_System_Profile.KnownRetailInfoProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRetailInfoProperties
    };

    static PyGetSetDef getset_KnownRetailInfoProperties_Meta[] = {
        { "battery_life_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_BatteryLifeDescription), nullptr, nullptr, nullptr },
        { "display_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_DisplayDescription), nullptr, nullptr, nullptr },
        { "display_model_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_DisplayModelName), nullptr, nullptr, nullptr },
        { "form_factor", reinterpret_cast<getter>(KnownRetailInfoProperties_get_FormFactor), nullptr, nullptr, nullptr },
        { "front_camera_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_FrontCameraDescription), nullptr, nullptr, nullptr },
        { "graphics_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_GraphicsDescription), nullptr, nullptr, nullptr },
        { "has_nfc", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasNfc), nullptr, nullptr, nullptr },
        { "has_optical_drive", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasOpticalDrive), nullptr, nullptr, nullptr },
        { "has_sd_slot", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasSdSlot), nullptr, nullptr, nullptr },
        { "is_featured", reinterpret_cast<getter>(KnownRetailInfoProperties_get_IsFeatured), nullptr, nullptr, nullptr },
        { "is_office_installed", reinterpret_cast<getter>(KnownRetailInfoProperties_get_IsOfficeInstalled), nullptr, nullptr, nullptr },
        { "manufacturer_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ManufacturerName), nullptr, nullptr, nullptr },
        { "memory", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Memory), nullptr, nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ModelName), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Price), nullptr, nullptr, nullptr },
        { "processor_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ProcessorDescription), nullptr, nullptr, nullptr },
        { "rear_camera_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_RearCameraDescription), nullptr, nullptr, nullptr },
        { "retail_access_code", reinterpret_cast<getter>(KnownRetailInfoProperties_get_RetailAccessCode), nullptr, nullptr, nullptr },
        { "screen_size", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ScreenSize), nullptr, nullptr, nullptr },
        { "storage_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_StorageDescription), nullptr, nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Weight), nullptr, nullptr, nullptr },
        { "windows_edition", reinterpret_cast<getter>(KnownRetailInfoProperties_get_WindowsEdition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownRetailInfoProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRetailInfoProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownRetailInfoProperties_Meta =
    {
        "_winsdk_Windows_System_Profile.KnownRetailInfoProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRetailInfoProperties_Meta
    };

    // ----- PlatformDiagnosticsAndUsageDataSettings class --------------------
    static constexpr const char* const type_name_PlatformDiagnosticsAndUsageDataSettings = "PlatformDiagnosticsAndUsageDataSettings";

    static PyObject* _new_PlatformDiagnosticsAndUsageDataSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PlatformDiagnosticsAndUsageDataSettings);
        return nullptr;
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_CanCollectDiagnostics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CanCollectDiagnostics", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::Profile::PlatformDataCollectionLevel>(args, 0);

                return py::convert(winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CanCollectDiagnostics(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_get_CollectionLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_add_CollectionLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_remove_CollectionLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlatformDiagnosticsAndUsageDataSettings[] = {
        { "can_collect_diagnostics", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_CanCollectDiagnostics), METH_VARARGS | METH_STATIC, nullptr },
        { "add_collection_level_changed", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_add_CollectionLevelChanged), METH_O | METH_STATIC, nullptr },
        { "remove_collection_level_changed", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_remove_CollectionLevelChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlatformDiagnosticsAndUsageDataSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_PlatformDiagnosticsAndUsageDataSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlatformDiagnosticsAndUsageDataSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlatformDiagnosticsAndUsageDataSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlatformDiagnosticsAndUsageDataSettings) },
        { },
    };

    static PyType_Spec type_spec_PlatformDiagnosticsAndUsageDataSettings =
    {
        "_winsdk_Windows_System_Profile.PlatformDiagnosticsAndUsageDataSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlatformDiagnosticsAndUsageDataSettings
    };

    static PyGetSetDef getset_PlatformDiagnosticsAndUsageDataSettings_Meta[] = {
        { "collection_level", reinterpret_cast<getter>(PlatformDiagnosticsAndUsageDataSettings_get_CollectionLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_PlatformDiagnosticsAndUsageDataSettings_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlatformDiagnosticsAndUsageDataSettings_Meta) },
        { }
    };

    static PyType_Spec type_spec_PlatformDiagnosticsAndUsageDataSettings_Meta =
    {
        "_winsdk_Windows_System_Profile.PlatformDiagnosticsAndUsageDataSettings_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlatformDiagnosticsAndUsageDataSettings_Meta
    };

    // ----- RetailInfo class --------------------
    static constexpr const char* const type_name_RetailInfo = "RetailInfo";

    static PyObject* _new_RetailInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RetailInfo);
        return nullptr;
    }

    static PyObject* RetailInfo_get_IsDemoModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.RetailInfo", L"IsDemoModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::RetailInfo::IsDemoModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RetailInfo_get_Properties(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.RetailInfo", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::RetailInfo::Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RetailInfo[] = {
        { }
    };

    static PyGetSetDef _getset_RetailInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_RetailInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RetailInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RetailInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RetailInfo) },
        { },
    };

    static PyType_Spec type_spec_RetailInfo =
    {
        "_winsdk_Windows_System_Profile.RetailInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RetailInfo
    };

    static PyGetSetDef getset_RetailInfo_Meta[] = {
        { "is_demo_mode_enabled", reinterpret_cast<getter>(RetailInfo_get_IsDemoModeEnabled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(RetailInfo_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_RetailInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RetailInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_RetailInfo_Meta =
    {
        "_winsdk_Windows_System_Profile.RetailInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RetailInfo_Meta
    };

    // ----- SharedModeSettings class --------------------
    static constexpr const char* const type_name_SharedModeSettings = "SharedModeSettings";

    static PyObject* _new_SharedModeSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SharedModeSettings);
        return nullptr;
    }

    static PyObject* SharedModeSettings_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SharedModeSettings", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SharedModeSettings::IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SharedModeSettings_get_ShouldAvoidLocalStorage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SharedModeSettings", L"ShouldAvoidLocalStorage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SharedModeSettings::ShouldAvoidLocalStorage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedModeSettings[] = {
        { }
    };

    static PyGetSetDef _getset_SharedModeSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_SharedModeSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedModeSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedModeSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedModeSettings) },
        { },
    };

    static PyType_Spec type_spec_SharedModeSettings =
    {
        "_winsdk_Windows_System_Profile.SharedModeSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedModeSettings
    };

    static PyGetSetDef getset_SharedModeSettings_Meta[] = {
        { "is_enabled", reinterpret_cast<getter>(SharedModeSettings_get_IsEnabled), nullptr, nullptr, nullptr },
        { "should_avoid_local_storage", reinterpret_cast<getter>(SharedModeSettings_get_ShouldAvoidLocalStorage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SharedModeSettings_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SharedModeSettings_Meta) },
        { }
    };

    static PyType_Spec type_spec_SharedModeSettings_Meta =
    {
        "_winsdk_Windows_System_Profile.SharedModeSettings_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SharedModeSettings_Meta
    };

    // ----- SmartAppControlPolicy class --------------------
    static constexpr const char* const type_name_SmartAppControlPolicy = "SmartAppControlPolicy";

    static PyObject* _new_SmartAppControlPolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SmartAppControlPolicy);
        return nullptr;
    }

    static PyObject* SmartAppControlPolicy_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SmartAppControlPolicy::IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartAppControlPolicy_add_Changed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::SmartAppControlPolicy::Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartAppControlPolicy_remove_Changed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::SmartAppControlPolicy::Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartAppControlPolicy[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(SmartAppControlPolicy_add_Changed), METH_O | METH_STATIC, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(SmartAppControlPolicy_remove_Changed), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartAppControlPolicy[] = {
        { }
    };

    static PyType_Slot _type_slots_SmartAppControlPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartAppControlPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartAppControlPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartAppControlPolicy) },
        { },
    };

    static PyType_Spec type_spec_SmartAppControlPolicy =
    {
        "_winsdk_Windows_System_Profile.SmartAppControlPolicy",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartAppControlPolicy
    };

    static PyGetSetDef getset_SmartAppControlPolicy_Meta[] = {
        { "is_enabled", reinterpret_cast<getter>(SmartAppControlPolicy_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SmartAppControlPolicy_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartAppControlPolicy_Meta) },
        { }
    };

    static PyType_Spec type_spec_SmartAppControlPolicy_Meta =
    {
        "_winsdk_Windows_System_Profile.SmartAppControlPolicy_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartAppControlPolicy_Meta
    };

    // ----- SystemIdentification class --------------------
    static constexpr const char* const type_name_SystemIdentification = "SystemIdentification";

    static PyObject* _new_SystemIdentification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemIdentification);
        return nullptr;
    }

    static PyObject* SystemIdentification_GetSystemIdForPublisher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.SystemIdentification", L"GetSystemIdForPublisher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Profile::SystemIdentification::GetSystemIdForPublisher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemIdentification_GetSystemIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.SystemIdentification", L"GetSystemIdForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::Profile::SystemIdentification::GetSystemIdForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemIdentification[] = {
        { "get_system_id_for_publisher", reinterpret_cast<PyCFunction>(SystemIdentification_GetSystemIdForPublisher), METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_id_for_user", reinterpret_cast<PyCFunction>(SystemIdentification_GetSystemIdForUser), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemIdentification[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemIdentification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemIdentification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemIdentification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemIdentification) },
        { },
    };

    static PyType_Spec type_spec_SystemIdentification =
    {
        "_winsdk_Windows_System_Profile.SystemIdentification",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemIdentification
    };

    // ----- SystemIdentificationInfo class --------------------
    static constexpr const char* const type_name_SystemIdentificationInfo = "SystemIdentificationInfo";

    static PyObject* _new_SystemIdentificationInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemIdentificationInfo);
        return nullptr;
    }

    static void _dealloc_SystemIdentificationInfo(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemIdentificationInfo_get_Id(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemIdentificationInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemIdentificationInfo_get_Source(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemIdentificationInfo", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemIdentificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::SystemIdentificationInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemIdentificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::SystemIdentificationInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemIdentificationInfo[] = {
        { "_assign_array_", _assign_array_SystemIdentificationInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemIdentificationInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemIdentificationInfo[] = {
        { "id", reinterpret_cast<getter>(SystemIdentificationInfo_get_Id), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SystemIdentificationInfo_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemIdentificationInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemIdentificationInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemIdentificationInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemIdentificationInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemIdentificationInfo) },
        { },
    };

    static PyType_Spec type_spec_SystemIdentificationInfo =
    {
        "_winsdk_Windows_System_Profile.SystemIdentificationInfo",
        sizeof(py::wrapper::Windows::System::Profile::SystemIdentificationInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemIdentificationInfo
    };

    // ----- SystemSetupInfo class --------------------
    static constexpr const char* const type_name_SystemSetupInfo = "SystemSetupInfo";

    static PyObject* _new_SystemSetupInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemSetupInfo);
        return nullptr;
    }

    static PyObject* SystemSetupInfo_get_OutOfBoxExperienceState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemSetupInfo_add_OutOfBoxExperienceStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemSetupInfo_remove_OutOfBoxExperienceStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemSetupInfo[] = {
        { "add_out_of_box_experience_state_changed", reinterpret_cast<PyCFunction>(SystemSetupInfo_add_OutOfBoxExperienceStateChanged), METH_O | METH_STATIC, nullptr },
        { "remove_out_of_box_experience_state_changed", reinterpret_cast<PyCFunction>(SystemSetupInfo_remove_OutOfBoxExperienceStateChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemSetupInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemSetupInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemSetupInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemSetupInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemSetupInfo) },
        { },
    };

    static PyType_Spec type_spec_SystemSetupInfo =
    {
        "_winsdk_Windows_System_Profile.SystemSetupInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemSetupInfo
    };

    static PyGetSetDef getset_SystemSetupInfo_Meta[] = {
        { "out_of_box_experience_state", reinterpret_cast<getter>(SystemSetupInfo_get_OutOfBoxExperienceState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SystemSetupInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemSetupInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_SystemSetupInfo_Meta =
    {
        "_winsdk_Windows_System_Profile.SystemSetupInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemSetupInfo_Meta
    };

    // ----- UnsupportedAppRequirement class --------------------
    static constexpr const char* const type_name_UnsupportedAppRequirement = "UnsupportedAppRequirement";

    static PyObject* _new_UnsupportedAppRequirement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UnsupportedAppRequirement);
        return nullptr;
    }

    static void _dealloc_UnsupportedAppRequirement(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnsupportedAppRequirement_get_Reasons(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.UnsupportedAppRequirement", L"Reasons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reasons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnsupportedAppRequirement_get_Requirement(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.UnsupportedAppRequirement", L"Requirement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Requirement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnsupportedAppRequirement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::UnsupportedAppRequirement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnsupportedAppRequirement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::UnsupportedAppRequirement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnsupportedAppRequirement[] = {
        { "_assign_array_", _assign_array_UnsupportedAppRequirement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnsupportedAppRequirement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnsupportedAppRequirement[] = {
        { "reasons", reinterpret_cast<getter>(UnsupportedAppRequirement_get_Reasons), nullptr, nullptr, nullptr },
        { "requirement", reinterpret_cast<getter>(UnsupportedAppRequirement_get_Requirement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnsupportedAppRequirement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnsupportedAppRequirement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnsupportedAppRequirement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnsupportedAppRequirement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnsupportedAppRequirement) },
        { },
    };

    static PyType_Spec type_spec_UnsupportedAppRequirement =
    {
        "_winsdk_Windows_System_Profile.UnsupportedAppRequirement",
        sizeof(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnsupportedAppRequirement
    };

    // ----- WindowsIntegrityPolicy class --------------------
    static constexpr const char* const type_name_WindowsIntegrityPolicy = "WindowsIntegrityPolicy";

    static PyObject* _new_WindowsIntegrityPolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WindowsIntegrityPolicy);
        return nullptr;
    }

    static PyObject* WindowsIntegrityPolicy_get_CanDisable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"CanDisable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::CanDisable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsDisableSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsDisableSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsDisableSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsEnabledForTrial(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsEnabledForTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsEnabledForTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_add_PolicyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"PolicyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::PolicyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_remove_PolicyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"PolicyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::WindowsIntegrityPolicy::PolicyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsIntegrityPolicy[] = {
        { "add_policy_changed", reinterpret_cast<PyCFunction>(WindowsIntegrityPolicy_add_PolicyChanged), METH_O | METH_STATIC, nullptr },
        { "remove_policy_changed", reinterpret_cast<PyCFunction>(WindowsIntegrityPolicy_remove_PolicyChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsIntegrityPolicy[] = {
        { }
    };

    static PyType_Slot _type_slots_WindowsIntegrityPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsIntegrityPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsIntegrityPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsIntegrityPolicy) },
        { },
    };

    static PyType_Spec type_spec_WindowsIntegrityPolicy =
    {
        "_winsdk_Windows_System_Profile.WindowsIntegrityPolicy",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsIntegrityPolicy
    };

    static PyGetSetDef getset_WindowsIntegrityPolicy_Meta[] = {
        { "can_disable", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_CanDisable), nullptr, nullptr, nullptr },
        { "is_disable_supported", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsDisableSupported), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_enabled_for_trial", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsEnabledForTrial), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_WindowsIntegrityPolicy_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowsIntegrityPolicy_Meta) },
        { }
    };

    static PyType_Spec type_spec_WindowsIntegrityPolicy_Meta =
    {
        "_winsdk_Windows_System_Profile.WindowsIntegrityPolicy_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowsIntegrityPolicy_Meta
    };

    // ----- Windows.System.Profile Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System::Profile");

    static PyMethodDef module_methods[] = {
        {"_register_PlatformDataCollectionLevel", register_PlatformDataCollectionLevel, METH_O, "registers type"},
        {"_register_SystemIdentificationSource", register_SystemIdentificationSource, METH_O, "registers type"},
        {"_register_SystemOutOfBoxExperienceState", register_SystemOutOfBoxExperienceState, METH_O, "registers type"},
        {"_register_UnsupportedAppRequirementReasons", register_UnsupportedAppRequirementReasons, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PlatformDataCollectionLevel);
        Py_VISIT(state->type_SystemIdentificationSource);
        Py_VISIT(state->type_SystemOutOfBoxExperienceState);
        Py_VISIT(state->type_UnsupportedAppRequirementReasons);
        Py_VISIT(state->type_AnalyticsInfo);
        Py_VISIT(state->type_AnalyticsVersionInfo);
        Py_VISIT(state->type_AppApplicability);
        Py_VISIT(state->type_EducationSettings);
        Py_VISIT(state->type_HardwareIdentification);
        Py_VISIT(state->type_HardwareToken);
        Py_VISIT(state->type_KnownRetailInfoProperties);
        Py_VISIT(state->type_PlatformDiagnosticsAndUsageDataSettings);
        Py_VISIT(state->type_RetailInfo);
        Py_VISIT(state->type_SharedModeSettings);
        Py_VISIT(state->type_SmartAppControlPolicy);
        Py_VISIT(state->type_SystemIdentification);
        Py_VISIT(state->type_SystemIdentificationInfo);
        Py_VISIT(state->type_SystemSetupInfo);
        Py_VISIT(state->type_UnsupportedAppRequirement);
        Py_VISIT(state->type_WindowsIntegrityPolicy);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PlatformDataCollectionLevel);
        Py_CLEAR(state->type_SystemIdentificationSource);
        Py_CLEAR(state->type_SystemOutOfBoxExperienceState);
        Py_CLEAR(state->type_UnsupportedAppRequirementReasons);
        Py_CLEAR(state->type_AnalyticsInfo);
        Py_CLEAR(state->type_AnalyticsVersionInfo);
        Py_CLEAR(state->type_AppApplicability);
        Py_CLEAR(state->type_EducationSettings);
        Py_CLEAR(state->type_HardwareIdentification);
        Py_CLEAR(state->type_HardwareToken);
        Py_CLEAR(state->type_KnownRetailInfoProperties);
        Py_CLEAR(state->type_PlatformDiagnosticsAndUsageDataSettings);
        Py_CLEAR(state->type_RetailInfo);
        Py_CLEAR(state->type_SharedModeSettings);
        Py_CLEAR(state->type_SmartAppControlPolicy);
        Py_CLEAR(state->type_SystemIdentification);
        Py_CLEAR(state->type_SystemIdentificationInfo);
        Py_CLEAR(state->type_SystemSetupInfo);
        Py_CLEAR(state->type_UnsupportedAppRequirement);
        Py_CLEAR(state->type_WindowsIntegrityPolicy);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_System_Profile",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::System::Profile

PyMODINIT_FUNC PyInit__winsdk_Windows_System_Profile(void) noexcept
{
    using namespace py::cpp::Windows::System::Profile;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    py::pyobj_handle type_AnalyticsInfo_Meta{PyType_FromSpec(&type_spec_AnalyticsInfo_Meta)};
    if (!type_AnalyticsInfo_Meta)
    {
        return nullptr;
    }

    state->type_AnalyticsInfo = py::register_python_type(module.get(), type_name_AnalyticsInfo, &type_spec_AnalyticsInfo, nullptr, reinterpret_cast<PyTypeObject*>(type_AnalyticsInfo_Meta.get()));
    if (!state->type_AnalyticsInfo)
    {
        return nullptr;
    }

    state->type_AnalyticsVersionInfo = py::register_python_type(module.get(), type_name_AnalyticsVersionInfo, &type_spec_AnalyticsVersionInfo, bases.get(), nullptr);
    if (!state->type_AnalyticsVersionInfo)
    {
        return nullptr;
    }

    state->type_AppApplicability = py::register_python_type(module.get(), type_name_AppApplicability, &type_spec_AppApplicability, nullptr, nullptr);
    if (!state->type_AppApplicability)
    {
        return nullptr;
    }

    py::pyobj_handle type_EducationSettings_Meta{PyType_FromSpec(&type_spec_EducationSettings_Meta)};
    if (!type_EducationSettings_Meta)
    {
        return nullptr;
    }

    state->type_EducationSettings = py::register_python_type(module.get(), type_name_EducationSettings, &type_spec_EducationSettings, nullptr, reinterpret_cast<PyTypeObject*>(type_EducationSettings_Meta.get()));
    if (!state->type_EducationSettings)
    {
        return nullptr;
    }

    state->type_HardwareIdentification = py::register_python_type(module.get(), type_name_HardwareIdentification, &type_spec_HardwareIdentification, nullptr, nullptr);
    if (!state->type_HardwareIdentification)
    {
        return nullptr;
    }

    state->type_HardwareToken = py::register_python_type(module.get(), type_name_HardwareToken, &type_spec_HardwareToken, bases.get(), nullptr);
    if (!state->type_HardwareToken)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRetailInfoProperties_Meta{PyType_FromSpec(&type_spec_KnownRetailInfoProperties_Meta)};
    if (!type_KnownRetailInfoProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownRetailInfoProperties = py::register_python_type(module.get(), type_name_KnownRetailInfoProperties, &type_spec_KnownRetailInfoProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownRetailInfoProperties_Meta.get()));
    if (!state->type_KnownRetailInfoProperties)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlatformDiagnosticsAndUsageDataSettings_Meta{PyType_FromSpec(&type_spec_PlatformDiagnosticsAndUsageDataSettings_Meta)};
    if (!type_PlatformDiagnosticsAndUsageDataSettings_Meta)
    {
        return nullptr;
    }

    state->type_PlatformDiagnosticsAndUsageDataSettings = py::register_python_type(module.get(), type_name_PlatformDiagnosticsAndUsageDataSettings, &type_spec_PlatformDiagnosticsAndUsageDataSettings, nullptr, reinterpret_cast<PyTypeObject*>(type_PlatformDiagnosticsAndUsageDataSettings_Meta.get()));
    if (!state->type_PlatformDiagnosticsAndUsageDataSettings)
    {
        return nullptr;
    }

    py::pyobj_handle type_RetailInfo_Meta{PyType_FromSpec(&type_spec_RetailInfo_Meta)};
    if (!type_RetailInfo_Meta)
    {
        return nullptr;
    }

    state->type_RetailInfo = py::register_python_type(module.get(), type_name_RetailInfo, &type_spec_RetailInfo, nullptr, reinterpret_cast<PyTypeObject*>(type_RetailInfo_Meta.get()));
    if (!state->type_RetailInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_SharedModeSettings_Meta{PyType_FromSpec(&type_spec_SharedModeSettings_Meta)};
    if (!type_SharedModeSettings_Meta)
    {
        return nullptr;
    }

    state->type_SharedModeSettings = py::register_python_type(module.get(), type_name_SharedModeSettings, &type_spec_SharedModeSettings, nullptr, reinterpret_cast<PyTypeObject*>(type_SharedModeSettings_Meta.get()));
    if (!state->type_SharedModeSettings)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartAppControlPolicy_Meta{PyType_FromSpec(&type_spec_SmartAppControlPolicy_Meta)};
    if (!type_SmartAppControlPolicy_Meta)
    {
        return nullptr;
    }

    state->type_SmartAppControlPolicy = py::register_python_type(module.get(), type_name_SmartAppControlPolicy, &type_spec_SmartAppControlPolicy, nullptr, reinterpret_cast<PyTypeObject*>(type_SmartAppControlPolicy_Meta.get()));
    if (!state->type_SmartAppControlPolicy)
    {
        return nullptr;
    }

    state->type_SystemIdentification = py::register_python_type(module.get(), type_name_SystemIdentification, &type_spec_SystemIdentification, nullptr, nullptr);
    if (!state->type_SystemIdentification)
    {
        return nullptr;
    }

    state->type_SystemIdentificationInfo = py::register_python_type(module.get(), type_name_SystemIdentificationInfo, &type_spec_SystemIdentificationInfo, bases.get(), nullptr);
    if (!state->type_SystemIdentificationInfo)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemSetupInfo_Meta{PyType_FromSpec(&type_spec_SystemSetupInfo_Meta)};
    if (!type_SystemSetupInfo_Meta)
    {
        return nullptr;
    }

    state->type_SystemSetupInfo = py::register_python_type(module.get(), type_name_SystemSetupInfo, &type_spec_SystemSetupInfo, nullptr, reinterpret_cast<PyTypeObject*>(type_SystemSetupInfo_Meta.get()));
    if (!state->type_SystemSetupInfo)
    {
        return nullptr;
    }

    state->type_UnsupportedAppRequirement = py::register_python_type(module.get(), type_name_UnsupportedAppRequirement, &type_spec_UnsupportedAppRequirement, bases.get(), nullptr);
    if (!state->type_UnsupportedAppRequirement)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowsIntegrityPolicy_Meta{PyType_FromSpec(&type_spec_WindowsIntegrityPolicy_Meta)};
    if (!type_WindowsIntegrityPolicy_Meta)
    {
        return nullptr;
    }

    state->type_WindowsIntegrityPolicy = py::register_python_type(module.get(), type_name_WindowsIntegrityPolicy, &type_spec_WindowsIntegrityPolicy, nullptr, reinterpret_cast<PyTypeObject*>(type_WindowsIntegrityPolicy_Meta.get()));
    if (!state->type_WindowsIntegrityPolicy)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::System::Profile::PlatformDataCollectionLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlatformDataCollectionLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::PlatformDataCollectionLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::System::Profile::SystemIdentificationSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemIdentificationSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SystemIdentificationSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::System::Profile::SystemOutOfBoxExperienceState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemOutOfBoxExperienceState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SystemOutOfBoxExperienceState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::System::Profile::UnsupportedAppRequirementReasons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnsupportedAppRequirementReasons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::UnsupportedAppRequirementReasons is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::AnalyticsInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AnalyticsInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::AnalyticsInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::AnalyticsVersionInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AnalyticsVersionInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::AnalyticsVersionInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::AppApplicability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppApplicability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::AppApplicability is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::EducationSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EducationSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::EducationSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::HardwareIdentification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HardwareIdentification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::HardwareIdentification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::HardwareToken>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HardwareToken;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::HardwareToken is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::KnownRetailInfoProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownRetailInfoProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::KnownRetailInfoProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PlatformDiagnosticsAndUsageDataSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::RetailInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RetailInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::RetailInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::SharedModeSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SharedModeSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SharedModeSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::SmartAppControlPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SmartAppControlPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SmartAppControlPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::SystemIdentification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemIdentification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SystemIdentification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::SystemIdentificationInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemIdentificationInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SystemIdentificationInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::SystemSetupInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemSetupInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::SystemSetupInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::UnsupportedAppRequirement>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnsupportedAppRequirement;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::UnsupportedAppRequirement is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Profile::WindowsIntegrityPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Profile;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Profile");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WindowsIntegrityPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Profile::WindowsIntegrityPolicy is not registered");
        return nullptr;
    }

    return python_type;
}
