// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.UI.Text.Core.h"


PyObject* py::converter<winrt::Windows::UI::Text::Core::CoreTextRange>::convert(winrt::Windows::UI::Text::Core::CoreTextRange instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::Text::Core::CoreTextRange>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::Text::Core::CoreTextRange py::converter<winrt::Windows::UI::Text::Core::CoreTextRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::Text::Core::CoreTextRange>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Text::Core::CoreTextRange>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::Text::Core::CoreTextRange");
    throw python_exception();
}

namespace py::cpp::Windows::UI::Text::Core
{
    struct module_state
    {
        PyObject* type_CoreTextFormatUpdatingReason;
        PyObject* type_CoreTextFormatUpdatingResult;
        PyObject* type_CoreTextInputPaneDisplayPolicy;
        PyObject* type_CoreTextInputScope;
        PyObject* type_CoreTextSelectionUpdatingResult;
        PyObject* type_CoreTextTextUpdatingResult;
        PyTypeObject* type_CoreTextCompositionCompletedEventArgs;
        PyTypeObject* type_CoreTextCompositionSegment;
        PyTypeObject* type_CoreTextCompositionStartedEventArgs;
        PyTypeObject* type_CoreTextEditContext;
        PyTypeObject* type_CoreTextFormatUpdatingEventArgs;
        PyTypeObject* type_CoreTextLayoutBounds;
        PyTypeObject* type_CoreTextLayoutRequest;
        PyTypeObject* type_CoreTextLayoutRequestedEventArgs;
        PyTypeObject* type_CoreTextSelectionRequest;
        PyTypeObject* type_CoreTextSelectionRequestedEventArgs;
        PyTypeObject* type_CoreTextSelectionUpdatingEventArgs;
        PyTypeObject* type_CoreTextServicesConstants;
        PyTypeObject* type_CoreTextServicesManager;
        PyTypeObject* type_CoreTextTextRequest;
        PyTypeObject* type_CoreTextTextRequestedEventArgs;
        PyTypeObject* type_CoreTextTextUpdatingEventArgs;
        PyTypeObject* type_CoreTextRange;
    };

    static PyObject* register_CoreTextFormatUpdatingReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreTextFormatUpdatingReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreTextFormatUpdatingReason = type;
        Py_INCREF(state->type_CoreTextFormatUpdatingReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreTextFormatUpdatingResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreTextFormatUpdatingResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreTextFormatUpdatingResult = type;
        Py_INCREF(state->type_CoreTextFormatUpdatingResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreTextInputPaneDisplayPolicy(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreTextInputPaneDisplayPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreTextInputPaneDisplayPolicy = type;
        Py_INCREF(state->type_CoreTextInputPaneDisplayPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreTextInputScope(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreTextInputScope)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreTextInputScope = type;
        Py_INCREF(state->type_CoreTextInputScope);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreTextSelectionUpdatingResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreTextSelectionUpdatingResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreTextSelectionUpdatingResult = type;
        Py_INCREF(state->type_CoreTextSelectionUpdatingResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_CoreTextTextUpdatingResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CoreTextTextUpdatingResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CoreTextTextUpdatingResult = type;
        Py_INCREF(state->type_CoreTextTextUpdatingResult);


        Py_RETURN_NONE;
    }

    // ----- CoreTextCompositionCompletedEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextCompositionCompletedEventArgs = "CoreTextCompositionCompletedEventArgs";

    static PyObject* _new_CoreTextCompositionCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextCompositionCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionCompletedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_get_CompositionSegments(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"CompositionSegments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompositionSegments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionCompletedEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionCompletedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextCompositionCompletedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextCompositionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextCompositionCompletedEventArgs[] = {
        { "composition_segments", reinterpret_cast<getter>(CoreTextCompositionCompletedEventArgs_get_CompositionSegments), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextCompositionCompletedEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextCompositionCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextCompositionCompletedEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextCompositionCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionCompletedEventArgs
    };

    // ----- CoreTextCompositionSegment class --------------------
    static constexpr const char* const type_name_CoreTextCompositionSegment = "CoreTextCompositionSegment";

    static PyObject* _new_CoreTextCompositionSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextCompositionSegment);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionSegment(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionSegment_get_PreconversionString(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionSegment", L"PreconversionString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreconversionString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionSegment_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionSegment", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionSegment[] = {
        { "_assign_array_", _assign_array_CoreTextCompositionSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextCompositionSegment[] = {
        { "preconversion_string", reinterpret_cast<getter>(CoreTextCompositionSegment_get_PreconversionString), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextCompositionSegment_get_Range), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextCompositionSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionSegment) },
        { },
    };

    static PyType_Spec type_spec_CoreTextCompositionSegment =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextCompositionSegment",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionSegment
    };

    // ----- CoreTextCompositionStartedEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextCompositionStartedEventArgs = "CoreTextCompositionStartedEventArgs";

    static PyObject* _new_CoreTextCompositionStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextCompositionStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextCompositionStartedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextCompositionStartedEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextCompositionStartedEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextCompositionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextCompositionStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextCompositionStartedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextCompositionStartedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextCompositionStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextCompositionStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextCompositionStartedEventArgs[] = {
        { "is_canceled", reinterpret_cast<getter>(CoreTextCompositionStartedEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextCompositionStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextCompositionStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextCompositionStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextCompositionStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextCompositionStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextCompositionStartedEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextCompositionStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextCompositionStartedEventArgs
    };

    // ----- CoreTextEditContext class --------------------
    static constexpr const char* const type_name_CoreTextEditContext = "CoreTextEditContext";

    static PyObject* _new_CoreTextEditContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextEditContext);
        return nullptr;
    }

    static void _dealloc_CoreTextEditContext(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextEditContext_NotifyFocusEnter(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusEnter", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyFocusEnter();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyFocusLeave(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeave", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyFocusLeave();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyLayoutChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyLayoutChanged", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyLayoutChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifySelectionChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifySelectionChanged", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 0);

                self->obj.NotifySelectionChanged(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_NotifyTextChanged(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyTextChanged", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(args, 2);

                self->obj.NotifyTextChanged(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_get_Name(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_Name(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_IsReadOnly(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_IsReadOnly(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReadOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_InputScope(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_InputScope(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextInputScope>(arg);

            self->obj.InputScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_get_InputPaneDisplayPolicy(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputPaneDisplayPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputPaneDisplayPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextEditContext_put_InputPaneDisplayPolicy(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"InputPaneDisplayPolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextInputPaneDisplayPolicy>(arg);

            self->obj.InputPaneDisplayPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextEditContext_add_CompositionCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>>(arg);

            return py::convert(self->obj.CompositionCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_CompositionCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CompositionCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_CompositionStarted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>>(arg);

            return py::convert(self->obj.CompositionStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_CompositionStarted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"CompositionStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CompositionStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_FocusRemoved(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FocusRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FocusRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_FocusRemoved(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FocusRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_FormatUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FormatUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>>(arg);

            return py::convert(self->obj.FormatUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_FormatUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"FormatUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FormatUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_LayoutRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"LayoutRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>>(arg);

            return py::convert(self->obj.LayoutRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_LayoutRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"LayoutRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LayoutRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_SelectionRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>>(arg);

            return py::convert(self->obj.SelectionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_SelectionRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_SelectionUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>>(arg);

            return py::convert(self->obj.SelectionUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_SelectionUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"SelectionUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_TextRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>>(arg);

            return py::convert(self->obj.TextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_TextRequested(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_TextUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>>(arg);

            return py::convert(self->obj.TextUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_TextUpdating(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"TextUpdating"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_add_NotifyFocusLeaveCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeaveCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextEditContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NotifyFocusLeaveCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextEditContext_remove_NotifyFocusLeaveCompleted(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextEditContext", L"NotifyFocusLeaveCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NotifyFocusLeaveCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextEditContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextEditContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextEditContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextEditContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextEditContext[] = {
        { "notify_focus_enter", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyFocusEnter), METH_VARARGS, nullptr },
        { "notify_focus_leave", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyFocusLeave), METH_VARARGS, nullptr },
        { "notify_layout_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyLayoutChanged), METH_VARARGS, nullptr },
        { "notify_selection_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifySelectionChanged), METH_VARARGS, nullptr },
        { "notify_text_changed", reinterpret_cast<PyCFunction>(CoreTextEditContext_NotifyTextChanged), METH_VARARGS, nullptr },
        { "add_composition_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_CompositionCompleted), METH_O, nullptr },
        { "remove_composition_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_CompositionCompleted), METH_O, nullptr },
        { "add_composition_started", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_CompositionStarted), METH_O, nullptr },
        { "remove_composition_started", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_CompositionStarted), METH_O, nullptr },
        { "add_focus_removed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_FocusRemoved), METH_O, nullptr },
        { "remove_focus_removed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_FocusRemoved), METH_O, nullptr },
        { "add_format_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_FormatUpdating), METH_O, nullptr },
        { "remove_format_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_FormatUpdating), METH_O, nullptr },
        { "add_layout_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_LayoutRequested), METH_O, nullptr },
        { "remove_layout_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_LayoutRequested), METH_O, nullptr },
        { "add_selection_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_SelectionRequested), METH_O, nullptr },
        { "remove_selection_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_SelectionRequested), METH_O, nullptr },
        { "add_selection_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_SelectionUpdating), METH_O, nullptr },
        { "remove_selection_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_SelectionUpdating), METH_O, nullptr },
        { "add_text_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_TextRequested), METH_O, nullptr },
        { "remove_text_requested", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_TextRequested), METH_O, nullptr },
        { "add_text_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_TextUpdating), METH_O, nullptr },
        { "remove_text_updating", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_TextUpdating), METH_O, nullptr },
        { "add_notify_focus_leave_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_add_NotifyFocusLeaveCompleted), METH_O, nullptr },
        { "remove_notify_focus_leave_completed", reinterpret_cast<PyCFunction>(CoreTextEditContext_remove_NotifyFocusLeaveCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreTextEditContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextEditContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextEditContext[] = {
        { "name", reinterpret_cast<getter>(CoreTextEditContext_get_Name), reinterpret_cast<setter>(CoreTextEditContext_put_Name), nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(CoreTextEditContext_get_IsReadOnly), reinterpret_cast<setter>(CoreTextEditContext_put_IsReadOnly), nullptr, nullptr },
        { "input_scope", reinterpret_cast<getter>(CoreTextEditContext_get_InputScope), reinterpret_cast<setter>(CoreTextEditContext_put_InputScope), nullptr, nullptr },
        { "input_pane_display_policy", reinterpret_cast<getter>(CoreTextEditContext_get_InputPaneDisplayPolicy), reinterpret_cast<setter>(CoreTextEditContext_put_InputPaneDisplayPolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextEditContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextEditContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextEditContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextEditContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextEditContext) },
        { },
    };

    static PyType_Spec type_spec_CoreTextEditContext =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextEditContext",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextEditContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextEditContext
    };

    // ----- CoreTextFormatUpdatingEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextFormatUpdatingEventArgs = "CoreTextFormatUpdatingEventArgs";

    static PyObject* _new_CoreTextFormatUpdatingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextFormatUpdatingEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextFormatUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextFormatUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingResult>(arg);

            self->obj.Result(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_BackgroundColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"BackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_Reason(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_TextColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"TextColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_UnderlineColor(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"UnderlineColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnderlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextFormatUpdatingEventArgs_get_UnderlineType(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs", L"UnderlineType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnderlineType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextFormatUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextFormatUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextFormatUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextFormatUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextFormatUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextFormatUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextFormatUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextFormatUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_BackgroundColor), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Range), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { "text_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_TextColor), nullptr, nullptr, nullptr },
        { "underline_color", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_UnderlineColor), nullptr, nullptr, nullptr },
        { "underline_type", reinterpret_cast<getter>(CoreTextFormatUpdatingEventArgs_get_UnderlineType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextFormatUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextFormatUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextFormatUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextFormatUpdatingEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextFormatUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextFormatUpdatingEventArgs
    };

    // ----- CoreTextLayoutBounds class --------------------
    static constexpr const char* const type_name_CoreTextLayoutBounds = "CoreTextLayoutBounds";

    static PyObject* _new_CoreTextLayoutBounds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextLayoutBounds);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutBounds_get_TextBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"TextBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextLayoutBounds_put_TextBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"TextBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.TextBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextLayoutBounds_get_ControlBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"ControlBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextLayoutBounds_put_ControlBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutBounds", L"ControlBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.ControlBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutBounds[] = {
        { "_assign_array_", _assign_array_CoreTextLayoutBounds, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutBounds), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextLayoutBounds[] = {
        { "text_bounds", reinterpret_cast<getter>(CoreTextLayoutBounds_get_TextBounds), reinterpret_cast<setter>(CoreTextLayoutBounds_put_TextBounds), nullptr, nullptr },
        { "control_bounds", reinterpret_cast<getter>(CoreTextLayoutBounds_get_ControlBounds), reinterpret_cast<setter>(CoreTextLayoutBounds_put_ControlBounds), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextLayoutBounds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutBounds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutBounds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutBounds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutBounds) },
        { },
    };

    static PyType_Spec type_spec_CoreTextLayoutBounds =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextLayoutBounds",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutBounds
    };

    // ----- CoreTextLayoutRequest class --------------------
    static constexpr const char* const type_name_CoreTextLayoutRequest = "CoreTextLayoutRequest";

    static PyObject* _new_CoreTextLayoutRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextLayoutRequest);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutRequest(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_LayoutBounds(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"LayoutBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextLayoutRequest_get_LayoutBoundsVisualPixels(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequest", L"LayoutBoundsVisualPixels"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutBoundsVisualPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextLayoutRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextLayoutRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextLayoutRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(CoreTextLayoutRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "layout_bounds", reinterpret_cast<getter>(CoreTextLayoutRequest_get_LayoutBounds), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextLayoutRequest_get_Range), nullptr, nullptr, nullptr },
        { "layout_bounds_visual_pixels", reinterpret_cast<getter>(CoreTextLayoutRequest_get_LayoutBoundsVisualPixels), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextLayoutRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreTextLayoutRequest =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextLayoutRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutRequest
    };

    // ----- CoreTextLayoutRequestedEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextLayoutRequestedEventArgs = "CoreTextLayoutRequestedEventArgs";

    static PyObject* _new_CoreTextLayoutRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextLayoutRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextLayoutRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextLayoutRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextLayoutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextLayoutRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextLayoutRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextLayoutRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextLayoutRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextLayoutRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextLayoutRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextLayoutRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextLayoutRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextLayoutRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextLayoutRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextLayoutRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextLayoutRequestedEventArgs
    };

    // ----- CoreTextSelectionRequest class --------------------
    static constexpr const char* const type_name_CoreTextSelectionRequest = "CoreTextSelectionRequest";

    static PyObject* _new_CoreTextSelectionRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextSelectionRequest);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionRequest(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionRequest_get_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"Selection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextSelectionRequest_put_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"Selection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextRange>(arg);

            self->obj.Selection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextSelectionRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextSelectionRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextSelectionRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextSelectionRequest[] = {
        { "selection", reinterpret_cast<getter>(CoreTextSelectionRequest_get_Selection), reinterpret_cast<setter>(CoreTextSelectionRequest_put_Selection), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextSelectionRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextSelectionRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreTextSelectionRequest =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextSelectionRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionRequest
    };

    // ----- CoreTextSelectionRequestedEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextSelectionRequestedEventArgs = "CoreTextSelectionRequestedEventArgs";

    static PyObject* _new_CoreTextSelectionRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextSelectionRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextSelectionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextSelectionRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextSelectionRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextSelectionRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextSelectionRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextSelectionRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionRequestedEventArgs
    };

    // ----- CoreTextSelectionUpdatingEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextSelectionUpdatingEventArgs = "CoreTextSelectionUpdatingEventArgs";

    static PyObject* _new_CoreTextSelectionUpdatingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextSelectionUpdatingEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextSelectionUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextSelectionUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingResult>(arg);

            self->obj.Result(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextSelectionUpdatingEventArgs_get_Selection(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs", L"Selection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextSelectionUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextSelectionUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextSelectionUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextSelectionUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextSelectionUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextSelectionUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextSelectionUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextSelectionUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "selection", reinterpret_cast<getter>(CoreTextSelectionUpdatingEventArgs_get_Selection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextSelectionUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextSelectionUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextSelectionUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextSelectionUpdatingEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextSelectionUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextSelectionUpdatingEventArgs
    };

    // ----- CoreTextServicesConstants class --------------------
    static constexpr const char* const type_name_CoreTextServicesConstants = "CoreTextServicesConstants";

    static PyObject* _new_CoreTextServicesConstants(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextServicesConstants);
        return nullptr;
    }

    static PyObject* CoreTextServicesConstants_get_HiddenCharacter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextServicesConstants", L"HiddenCharacter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Text::Core::CoreTextServicesConstants::HiddenCharacter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextServicesConstants[] = {
        { }
    };

    static PyGetSetDef _getset_CoreTextServicesConstants[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreTextServicesConstants[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextServicesConstants) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextServicesConstants) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextServicesConstants) },
        { },
    };

    static PyType_Spec type_spec_CoreTextServicesConstants =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextServicesConstants",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextServicesConstants
    };

    static PyGetSetDef getset_CoreTextServicesConstants_Meta[] = {
        { "hidden_character", reinterpret_cast<getter>(CoreTextServicesConstants_get_HiddenCharacter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreTextServicesConstants_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreTextServicesConstants_Meta) },
        { }
    };

    static PyType_Spec type_spec_CoreTextServicesConstants_Meta =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextServicesConstants_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreTextServicesConstants_Meta
    };

    // ----- CoreTextServicesManager class --------------------
    static constexpr const char* const type_name_CoreTextServicesManager = "CoreTextServicesManager";

    static PyObject* _new_CoreTextServicesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextServicesManager);
        return nullptr;
    }

    static void _dealloc_CoreTextServicesManager(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextServicesManager_CreateEditContext(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"CreateEditContext", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateEditContext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Text::Core::CoreTextServicesManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_get_InputLanguage(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_add_InputLanguageChanged(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Text::Core::CoreTextServicesManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.InputLanguageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextServicesManager_remove_InputLanguageChanged(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Text.Core.CoreTextServicesManager", L"InputLanguageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputLanguageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextServicesManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextServicesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextServicesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextServicesManager[] = {
        { "create_edit_context", reinterpret_cast<PyCFunction>(CoreTextServicesManager_CreateEditContext), METH_VARARGS, nullptr },
        { "get_for_current_view", reinterpret_cast<PyCFunction>(CoreTextServicesManager_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "add_input_language_changed", reinterpret_cast<PyCFunction>(CoreTextServicesManager_add_InputLanguageChanged), METH_O, nullptr },
        { "remove_input_language_changed", reinterpret_cast<PyCFunction>(CoreTextServicesManager_remove_InputLanguageChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreTextServicesManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextServicesManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextServicesManager[] = {
        { "input_language", reinterpret_cast<getter>(CoreTextServicesManager_get_InputLanguage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextServicesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextServicesManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextServicesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextServicesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextServicesManager) },
        { },
    };

    static PyType_Spec type_spec_CoreTextServicesManager =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextServicesManager",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextServicesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextServicesManager
    };

    // ----- CoreTextTextRequest class --------------------
    static constexpr const char* const type_name_CoreTextTextRequest = "CoreTextTextRequest";

    static PyObject* _new_CoreTextTextRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextTextRequest);
        return nullptr;
    }

    static void _dealloc_CoreTextTextRequest(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextRequest_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextTextRequest_get_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextTextRequest_put_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextTextRequest_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextRequest_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequest", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextTextRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextTextRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextTextRequest[] = {
        { "text", reinterpret_cast<getter>(CoreTextTextRequest_get_Text), reinterpret_cast<setter>(CoreTextTextRequest_put_Text), nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextTextRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextTextRequest_get_Range), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextTextRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreTextTextRequest =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextTextRequest",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextRequest
    };

    // ----- CoreTextTextRequestedEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextTextRequestedEventArgs = "CoreTextTextRequestedEventArgs";

    static PyObject* _new_CoreTextTextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextTextRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextTextRequestedEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreTextTextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextTextRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreTextTextRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextTextRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextTextRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextTextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextRequestedEventArgs
    };

    // ----- CoreTextTextUpdatingEventArgs class --------------------
    static constexpr const char* const type_name_CoreTextTextUpdatingEventArgs = "CoreTextTextUpdatingEventArgs";

    static PyObject* _new_CoreTextTextUpdatingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreTextTextUpdatingEventArgs);
        return nullptr;
    }

    static void _dealloc_CoreTextTextUpdatingEventArgs(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreTextTextUpdatingEventArgs_GetDeferral(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Result(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextTextUpdatingEventArgs_put_Result(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Result"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingResult>(arg);

            self->obj.Result(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_InputLanguage(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"InputLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_IsCanceled(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_NewSelection(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"NewSelection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Range(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Range"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Range());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreTextTextUpdatingEventArgs_get_Text(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreTextTextUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreTextTextUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreTextTextUpdatingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreTextTextUpdatingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreTextTextUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreTextTextUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreTextTextUpdatingEventArgs[] = {
        { "result", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Result), reinterpret_cast<setter>(CoreTextTextUpdatingEventArgs_put_Result), nullptr, nullptr },
        { "input_language", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_InputLanguage), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { "new_selection", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_NewSelection), nullptr, nullptr, nullptr },
        { "range", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Range), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(CoreTextTextUpdatingEventArgs_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextTextUpdatingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextTextUpdatingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextTextUpdatingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreTextTextUpdatingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextTextUpdatingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreTextTextUpdatingEventArgs =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextTextUpdatingEventArgs",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextTextUpdatingEventArgs
    };

    // ----- CoreTextRange struct --------------------
    static constexpr const char* const type_name_CoreTextRange = "CoreTextRange";

    PyObject* _new_CoreTextRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Text::Core::CoreTextRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _StartCaretPosition{};
        int32_t _EndCaretPosition{};

        static const char* kwlist[] = {"start_caret_position", "end_caret_position", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_StartCaretPosition, &_EndCaretPosition))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Text::Core::CoreTextRange return_value{ _StartCaretPosition, _EndCaretPosition };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CoreTextRange(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self) noexcept
    {
    }

    static PyObject* CoreTextRange_get_StartCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartCaretPosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextRange_set_StartCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.StartCaretPosition = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreTextRange_get_EndCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndCaretPosition);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreTextRange_set_EndCaretPosition(py::wrapper::Windows::UI::Text::Core::CoreTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.EndCaretPosition = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CoreTextRange[] = {
        { "start_caret_position", reinterpret_cast<getter>(CoreTextRange_get_StartCaretPosition), reinterpret_cast<setter>(CoreTextRange_set_StartCaretPosition), nullptr, nullptr },
        { "end_caret_position", reinterpret_cast<getter>(CoreTextRange_get_EndCaretPosition), reinterpret_cast<setter>(CoreTextRange_set_EndCaretPosition), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreTextRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreTextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreTextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreTextRange) },
        { },
    };

    static PyType_Spec type_spec_CoreTextRange =
    {
        "_winsdk_Windows_UI_Text_Core.CoreTextRange",
        sizeof(py::wrapper::Windows::UI::Text::Core::CoreTextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreTextRange
    };

    // ----- Windows.UI.Text.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Text::Core");

    static PyMethodDef module_methods[] = {
        {"_register_CoreTextFormatUpdatingReason", register_CoreTextFormatUpdatingReason, METH_O, "registers type"},
        {"_register_CoreTextFormatUpdatingResult", register_CoreTextFormatUpdatingResult, METH_O, "registers type"},
        {"_register_CoreTextInputPaneDisplayPolicy", register_CoreTextInputPaneDisplayPolicy, METH_O, "registers type"},
        {"_register_CoreTextInputScope", register_CoreTextInputScope, METH_O, "registers type"},
        {"_register_CoreTextSelectionUpdatingResult", register_CoreTextSelectionUpdatingResult, METH_O, "registers type"},
        {"_register_CoreTextTextUpdatingResult", register_CoreTextTextUpdatingResult, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_CoreTextFormatUpdatingReason);
        Py_VISIT(state->type_CoreTextFormatUpdatingResult);
        Py_VISIT(state->type_CoreTextInputPaneDisplayPolicy);
        Py_VISIT(state->type_CoreTextInputScope);
        Py_VISIT(state->type_CoreTextSelectionUpdatingResult);
        Py_VISIT(state->type_CoreTextTextUpdatingResult);
        Py_VISIT(state->type_CoreTextCompositionCompletedEventArgs);
        Py_VISIT(state->type_CoreTextCompositionSegment);
        Py_VISIT(state->type_CoreTextCompositionStartedEventArgs);
        Py_VISIT(state->type_CoreTextEditContext);
        Py_VISIT(state->type_CoreTextFormatUpdatingEventArgs);
        Py_VISIT(state->type_CoreTextLayoutBounds);
        Py_VISIT(state->type_CoreTextLayoutRequest);
        Py_VISIT(state->type_CoreTextLayoutRequestedEventArgs);
        Py_VISIT(state->type_CoreTextSelectionRequest);
        Py_VISIT(state->type_CoreTextSelectionRequestedEventArgs);
        Py_VISIT(state->type_CoreTextSelectionUpdatingEventArgs);
        Py_VISIT(state->type_CoreTextServicesConstants);
        Py_VISIT(state->type_CoreTextServicesManager);
        Py_VISIT(state->type_CoreTextTextRequest);
        Py_VISIT(state->type_CoreTextTextRequestedEventArgs);
        Py_VISIT(state->type_CoreTextTextUpdatingEventArgs);
        Py_VISIT(state->type_CoreTextRange);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_CoreTextFormatUpdatingReason);
        Py_CLEAR(state->type_CoreTextFormatUpdatingResult);
        Py_CLEAR(state->type_CoreTextInputPaneDisplayPolicy);
        Py_CLEAR(state->type_CoreTextInputScope);
        Py_CLEAR(state->type_CoreTextSelectionUpdatingResult);
        Py_CLEAR(state->type_CoreTextTextUpdatingResult);
        Py_CLEAR(state->type_CoreTextCompositionCompletedEventArgs);
        Py_CLEAR(state->type_CoreTextCompositionSegment);
        Py_CLEAR(state->type_CoreTextCompositionStartedEventArgs);
        Py_CLEAR(state->type_CoreTextEditContext);
        Py_CLEAR(state->type_CoreTextFormatUpdatingEventArgs);
        Py_CLEAR(state->type_CoreTextLayoutBounds);
        Py_CLEAR(state->type_CoreTextLayoutRequest);
        Py_CLEAR(state->type_CoreTextLayoutRequestedEventArgs);
        Py_CLEAR(state->type_CoreTextSelectionRequest);
        Py_CLEAR(state->type_CoreTextSelectionRequestedEventArgs);
        Py_CLEAR(state->type_CoreTextSelectionUpdatingEventArgs);
        Py_CLEAR(state->type_CoreTextServicesConstants);
        Py_CLEAR(state->type_CoreTextServicesManager);
        Py_CLEAR(state->type_CoreTextTextRequest);
        Py_CLEAR(state->type_CoreTextTextRequestedEventArgs);
        Py_CLEAR(state->type_CoreTextTextUpdatingEventArgs);
        Py_CLEAR(state->type_CoreTextRange);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Text_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Text::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_Text_Core(void) noexcept
{
    using namespace py::cpp::Windows::UI::Text::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_CoreTextCompositionCompletedEventArgs = py::register_python_type(module.get(), type_name_CoreTextCompositionCompletedEventArgs, &type_spec_CoreTextCompositionCompletedEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextCompositionCompletedEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextCompositionSegment = py::register_python_type(module.get(), type_name_CoreTextCompositionSegment, &type_spec_CoreTextCompositionSegment, bases.get(), nullptr);
    if (!state->type_CoreTextCompositionSegment)
    {
        return nullptr;
    }

    state->type_CoreTextCompositionStartedEventArgs = py::register_python_type(module.get(), type_name_CoreTextCompositionStartedEventArgs, &type_spec_CoreTextCompositionStartedEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextCompositionStartedEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextEditContext = py::register_python_type(module.get(), type_name_CoreTextEditContext, &type_spec_CoreTextEditContext, bases.get(), nullptr);
    if (!state->type_CoreTextEditContext)
    {
        return nullptr;
    }

    state->type_CoreTextFormatUpdatingEventArgs = py::register_python_type(module.get(), type_name_CoreTextFormatUpdatingEventArgs, &type_spec_CoreTextFormatUpdatingEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextFormatUpdatingEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextLayoutBounds = py::register_python_type(module.get(), type_name_CoreTextLayoutBounds, &type_spec_CoreTextLayoutBounds, bases.get(), nullptr);
    if (!state->type_CoreTextLayoutBounds)
    {
        return nullptr;
    }

    state->type_CoreTextLayoutRequest = py::register_python_type(module.get(), type_name_CoreTextLayoutRequest, &type_spec_CoreTextLayoutRequest, bases.get(), nullptr);
    if (!state->type_CoreTextLayoutRequest)
    {
        return nullptr;
    }

    state->type_CoreTextLayoutRequestedEventArgs = py::register_python_type(module.get(), type_name_CoreTextLayoutRequestedEventArgs, &type_spec_CoreTextLayoutRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextLayoutRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextSelectionRequest = py::register_python_type(module.get(), type_name_CoreTextSelectionRequest, &type_spec_CoreTextSelectionRequest, bases.get(), nullptr);
    if (!state->type_CoreTextSelectionRequest)
    {
        return nullptr;
    }

    state->type_CoreTextSelectionRequestedEventArgs = py::register_python_type(module.get(), type_name_CoreTextSelectionRequestedEventArgs, &type_spec_CoreTextSelectionRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextSelectionRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextSelectionUpdatingEventArgs = py::register_python_type(module.get(), type_name_CoreTextSelectionUpdatingEventArgs, &type_spec_CoreTextSelectionUpdatingEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextSelectionUpdatingEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreTextServicesConstants_Meta{PyType_FromSpec(&type_spec_CoreTextServicesConstants_Meta)};
    if (!type_CoreTextServicesConstants_Meta)
    {
        return nullptr;
    }

    state->type_CoreTextServicesConstants = py::register_python_type(module.get(), type_name_CoreTextServicesConstants, &type_spec_CoreTextServicesConstants, nullptr, reinterpret_cast<PyTypeObject*>(type_CoreTextServicesConstants_Meta.get()));
    if (!state->type_CoreTextServicesConstants)
    {
        return nullptr;
    }

    state->type_CoreTextServicesManager = py::register_python_type(module.get(), type_name_CoreTextServicesManager, &type_spec_CoreTextServicesManager, bases.get(), nullptr);
    if (!state->type_CoreTextServicesManager)
    {
        return nullptr;
    }

    state->type_CoreTextTextRequest = py::register_python_type(module.get(), type_name_CoreTextTextRequest, &type_spec_CoreTextTextRequest, bases.get(), nullptr);
    if (!state->type_CoreTextTextRequest)
    {
        return nullptr;
    }

    state->type_CoreTextTextRequestedEventArgs = py::register_python_type(module.get(), type_name_CoreTextTextRequestedEventArgs, &type_spec_CoreTextTextRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextTextRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextTextUpdatingEventArgs = py::register_python_type(module.get(), type_name_CoreTextTextUpdatingEventArgs, &type_spec_CoreTextTextUpdatingEventArgs, bases.get(), nullptr);
    if (!state->type_CoreTextTextUpdatingEventArgs)
    {
        return nullptr;
    }

    state->type_CoreTextRange = py::register_python_type(module.get(), type_name_CoreTextRange, &type_spec_CoreTextRange, bases.get(), nullptr);
    if (!state->type_CoreTextRange)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextFormatUpdatingReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextFormatUpdatingResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Text::Core::CoreTextInputPaneDisplayPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextInputPaneDisplayPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextInputPaneDisplayPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Text::Core::CoreTextInputScope>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextInputScope;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextInputScope is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextSelectionUpdatingResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextTextUpdatingResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextTextUpdatingResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextCompositionCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextCompositionCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextCompositionSegment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextCompositionSegment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextCompositionSegment is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextCompositionStartedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextCompositionStartedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextEditContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextEditContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextEditContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextFormatUpdatingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextFormatUpdatingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextLayoutBounds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextLayoutBounds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextLayoutBounds is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextLayoutRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextLayoutRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextLayoutRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextLayoutRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextSelectionRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextSelectionRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextSelectionRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextSelectionRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextSelectionUpdatingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextSelectionUpdatingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextServicesConstants>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextServicesConstants;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextServicesConstants is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextServicesManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextServicesManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextServicesManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextTextRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextTextRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextTextRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextTextRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextTextRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextTextUpdatingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextTextUpdatingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::Core::CoreTextRange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Text::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Text::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreTextRange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Text::Core::CoreTextRange is not registered");
        return nullptr;
    }

    return python_type;
}
