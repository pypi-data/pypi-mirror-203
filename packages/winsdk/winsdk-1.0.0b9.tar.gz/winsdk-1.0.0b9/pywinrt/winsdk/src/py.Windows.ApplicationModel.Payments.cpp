// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.ApplicationModel.Payments.h"


namespace py::cpp::Windows::ApplicationModel::Payments
{
    struct module_state
    {
        PyObject* type_PaymentCanMakePaymentResultStatus;
        PyObject* type_PaymentOptionPresence;
        PyObject* type_PaymentRequestChangeKind;
        PyObject* type_PaymentRequestCompletionStatus;
        PyObject* type_PaymentRequestStatus;
        PyObject* type_PaymentShippingType;
        PyTypeObject* type_PaymentAddress;
        PyTypeObject* type_PaymentCanMakePaymentResult;
        PyTypeObject* type_PaymentCurrencyAmount;
        PyTypeObject* type_PaymentDetails;
        PyTypeObject* type_PaymentDetailsModifier;
        PyTypeObject* type_PaymentItem;
        PyTypeObject* type_PaymentMediator;
        PyTypeObject* type_PaymentMerchantInfo;
        PyTypeObject* type_PaymentMethodData;
        PyTypeObject* type_PaymentOptions;
        PyTypeObject* type_PaymentRequest;
        PyTypeObject* type_PaymentRequestChangedArgs;
        PyTypeObject* type_PaymentRequestChangedResult;
        PyTypeObject* type_PaymentRequestSubmitResult;
        PyTypeObject* type_PaymentResponse;
        PyTypeObject* type_PaymentShippingOption;
        PyTypeObject* type_PaymentToken;
    };

    static PyObject* register_PaymentCanMakePaymentResultStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PaymentCanMakePaymentResultStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PaymentCanMakePaymentResultStatus = type;
        Py_INCREF(state->type_PaymentCanMakePaymentResultStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PaymentOptionPresence(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PaymentOptionPresence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PaymentOptionPresence = type;
        Py_INCREF(state->type_PaymentOptionPresence);


        Py_RETURN_NONE;
    }

    static PyObject* register_PaymentRequestChangeKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PaymentRequestChangeKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PaymentRequestChangeKind = type;
        Py_INCREF(state->type_PaymentRequestChangeKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PaymentRequestCompletionStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PaymentRequestCompletionStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PaymentRequestCompletionStatus = type;
        Py_INCREF(state->type_PaymentRequestCompletionStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PaymentRequestStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PaymentRequestStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PaymentRequestStatus = type;
        Py_INCREF(state->type_PaymentRequestStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PaymentShippingType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PaymentShippingType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PaymentShippingType = type;
        Py_INCREF(state->type_PaymentShippingType);


        Py_RETURN_NONE;
    }

    // ----- PaymentAddress class --------------------
    static constexpr const char* const type_name_PaymentAddress = "PaymentAddress";

    static PyObject* _new_PaymentAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentAddress_get_SortingCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"SortingCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SortingCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_SortingCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"SortingCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SortingCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Region(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Region(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Recipient(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Recipient(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Recipient"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Recipient(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_PostalCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_PostalCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_PhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PhoneNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Organization(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Organization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Organization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Organization(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Organization"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Organization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_LanguageCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"LanguageCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LanguageCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_LanguageCode(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"LanguageCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LanguageCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_DependentLocality(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"DependentLocality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DependentLocality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_DependentLocality(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"DependentLocality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DependentLocality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Country(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_Country(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_City(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"City"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_City(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"City"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.City(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_AddressLines(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"AddressLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AddressLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentAddress_put_AddressLines(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"AddressLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(arg);

            self->obj.AddressLines(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentAddress_get_Properties(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentAddress", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentAddress[] = {
        { "_assign_array_", _assign_array_PaymentAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentAddress[] = {
        { "sorting_code", reinterpret_cast<getter>(PaymentAddress_get_SortingCode), reinterpret_cast<setter>(PaymentAddress_put_SortingCode), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(PaymentAddress_get_Region), reinterpret_cast<setter>(PaymentAddress_put_Region), nullptr, nullptr },
        { "recipient", reinterpret_cast<getter>(PaymentAddress_get_Recipient), reinterpret_cast<setter>(PaymentAddress_put_Recipient), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(PaymentAddress_get_PostalCode), reinterpret_cast<setter>(PaymentAddress_put_PostalCode), nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PaymentAddress_get_PhoneNumber), reinterpret_cast<setter>(PaymentAddress_put_PhoneNumber), nullptr, nullptr },
        { "organization", reinterpret_cast<getter>(PaymentAddress_get_Organization), reinterpret_cast<setter>(PaymentAddress_put_Organization), nullptr, nullptr },
        { "language_code", reinterpret_cast<getter>(PaymentAddress_get_LanguageCode), reinterpret_cast<setter>(PaymentAddress_put_LanguageCode), nullptr, nullptr },
        { "dependent_locality", reinterpret_cast<getter>(PaymentAddress_get_DependentLocality), reinterpret_cast<setter>(PaymentAddress_put_DependentLocality), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(PaymentAddress_get_Country), reinterpret_cast<setter>(PaymentAddress_put_Country), nullptr, nullptr },
        { "city", reinterpret_cast<getter>(PaymentAddress_get_City), reinterpret_cast<setter>(PaymentAddress_put_City), nullptr, nullptr },
        { "address_lines", reinterpret_cast<getter>(PaymentAddress_get_AddressLines), reinterpret_cast<setter>(PaymentAddress_put_AddressLines), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PaymentAddress_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentAddress) },
        { },
    };

    static PyType_Spec type_spec_PaymentAddress =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentAddress
    };

    // ----- PaymentCanMakePaymentResult class --------------------
    static constexpr const char* const type_name_PaymentCanMakePaymentResult = "PaymentCanMakePaymentResult";

    static PyObject* _new_PaymentCanMakePaymentResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResultStatus>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentCanMakePaymentResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentCanMakePaymentResult_get_Status(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCanMakePaymentResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentCanMakePaymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentCanMakePaymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentCanMakePaymentResult[] = {
        { "_assign_array_", _assign_array_PaymentCanMakePaymentResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentCanMakePaymentResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentCanMakePaymentResult[] = {
        { "status", reinterpret_cast<getter>(PaymentCanMakePaymentResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentCanMakePaymentResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentCanMakePaymentResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentCanMakePaymentResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentCanMakePaymentResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentCanMakePaymentResult) },
        { },
    };

    static PyType_Spec type_spec_PaymentCanMakePaymentResult =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentCanMakePaymentResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentCanMakePaymentResult
    };

    // ----- PaymentCurrencyAmount class --------------------
    static constexpr const char* const type_name_PaymentCurrencyAmount = "PaymentCurrencyAmount";

    static PyObject* _new_PaymentCurrencyAmount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentCurrencyAmount(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentCurrencyAmount_get_Value(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_Value(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentCurrencyAmount_get_CurrencySystem(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"CurrencySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrencySystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_CurrencySystem(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"CurrencySystem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CurrencySystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentCurrencyAmount_get_Currency(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Currency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Currency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentCurrencyAmount_put_Currency(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentCurrencyAmount", L"Currency"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Currency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentCurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentCurrencyAmount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentCurrencyAmount[] = {
        { "_assign_array_", _assign_array_PaymentCurrencyAmount, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentCurrencyAmount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentCurrencyAmount[] = {
        { "value", reinterpret_cast<getter>(PaymentCurrencyAmount_get_Value), reinterpret_cast<setter>(PaymentCurrencyAmount_put_Value), nullptr, nullptr },
        { "currency_system", reinterpret_cast<getter>(PaymentCurrencyAmount_get_CurrencySystem), reinterpret_cast<setter>(PaymentCurrencyAmount_put_CurrencySystem), nullptr, nullptr },
        { "currency", reinterpret_cast<getter>(PaymentCurrencyAmount_get_Currency), reinterpret_cast<setter>(PaymentCurrencyAmount_put_Currency), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentCurrencyAmount[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentCurrencyAmount) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentCurrencyAmount) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentCurrencyAmount) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentCurrencyAmount) },
        { },
    };

    static PyType_Spec type_spec_PaymentCurrencyAmount =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentCurrencyAmount",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentCurrencyAmount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentCurrencyAmount
    };

    // ----- PaymentDetails class --------------------
    static constexpr const char* const type_name_PaymentDetails = "PaymentDetails";

    static PyObject* _new_PaymentDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentDetails instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentDetails_get_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Total"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Total());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Total"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(arg);

            self->obj.Total(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_ShippingOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"ShippingOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_ShippingOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"ShippingOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>>(arg);

            self->obj.ShippingOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_Modifiers(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Modifiers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_Modifiers(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"Modifiers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>>(arg);

            self->obj.Modifiers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentDetails_get_DisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"DisplayItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentDetails_put_DisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetails", L"DisplayItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(arg);

            self->obj.DisplayItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentDetails[] = {
        { "_assign_array_", _assign_array_PaymentDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentDetails[] = {
        { "total", reinterpret_cast<getter>(PaymentDetails_get_Total), reinterpret_cast<setter>(PaymentDetails_put_Total), nullptr, nullptr },
        { "shipping_options", reinterpret_cast<getter>(PaymentDetails_get_ShippingOptions), reinterpret_cast<setter>(PaymentDetails_put_ShippingOptions), nullptr, nullptr },
        { "modifiers", reinterpret_cast<getter>(PaymentDetails_get_Modifiers), reinterpret_cast<setter>(PaymentDetails_put_Modifiers), nullptr, nullptr },
        { "display_items", reinterpret_cast<getter>(PaymentDetails_get_DisplayItems), reinterpret_cast<setter>(PaymentDetails_put_DisplayItems), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentDetails) },
        { },
    };

    static PyType_Spec type_spec_PaymentDetails =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentDetails
    };

    // ----- PaymentDetailsModifier class --------------------
    static constexpr const char* const type_name_PaymentDetailsModifier = "PaymentDetailsModifier";

    static PyObject* _new_PaymentDetailsModifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentItem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentItem>>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentDetailsModifier(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentDetailsModifier_get_AdditionalDisplayItems(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"AdditionalDisplayItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalDisplayItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_JsonData(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"JsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_SupportedMethodIds(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"SupportedMethodIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedMethodIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentDetailsModifier_get_Total(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentDetailsModifier", L"Total"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Total());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentDetailsModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentDetailsModifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentDetailsModifier[] = {
        { "_assign_array_", _assign_array_PaymentDetailsModifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentDetailsModifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentDetailsModifier[] = {
        { "additional_display_items", reinterpret_cast<getter>(PaymentDetailsModifier_get_AdditionalDisplayItems), nullptr, nullptr, nullptr },
        { "json_data", reinterpret_cast<getter>(PaymentDetailsModifier_get_JsonData), nullptr, nullptr, nullptr },
        { "supported_method_ids", reinterpret_cast<getter>(PaymentDetailsModifier_get_SupportedMethodIds), nullptr, nullptr, nullptr },
        { "total", reinterpret_cast<getter>(PaymentDetailsModifier_get_Total), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentDetailsModifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentDetailsModifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentDetailsModifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentDetailsModifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentDetailsModifier) },
        { },
    };

    static PyType_Spec type_spec_PaymentDetailsModifier =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentDetailsModifier",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentDetailsModifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentDetailsModifier
    };

    // ----- PaymentItem class --------------------
    static constexpr const char* const type_name_PaymentItem = "PaymentItem";

    static PyObject* _new_PaymentItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentItem instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentItem(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentItem_get_Pending(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Pending"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pending());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Pending(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Pending"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Pending(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentItem_get_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentItem_get_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Amount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentItem_put_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentItem", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(arg);

            self->obj.Amount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentItem[] = {
        { "_assign_array_", _assign_array_PaymentItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentItem[] = {
        { "pending", reinterpret_cast<getter>(PaymentItem_get_Pending), reinterpret_cast<setter>(PaymentItem_put_Pending), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(PaymentItem_get_Label), reinterpret_cast<setter>(PaymentItem_put_Label), nullptr, nullptr },
        { "amount", reinterpret_cast<getter>(PaymentItem_get_Amount), reinterpret_cast<setter>(PaymentItem_put_Amount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentItem) },
        { },
    };

    static PyType_Spec type_spec_PaymentItem =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentItem
    };

    // ----- PaymentMediator class --------------------
    static constexpr const char* const type_name_PaymentMediator = "PaymentMediator";

    static PyObject* _new_PaymentMediator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentMediator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMediator(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMediator_CanMakePaymentAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"CanMakePaymentAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);

                return py::convert(self->obj.CanMakePaymentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_GetSupportedMethodIdsAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"GetSupportedMethodIdsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedMethodIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentMediator_SubmitPaymentRequestAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"SubmitPaymentRequestAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);

                return py::convert(self->obj.SubmitPaymentRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentMediator", L"SubmitPaymentRequestAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedHandler>(args, 1);

                return py::convert(self->obj.SubmitPaymentRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMediator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMediator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMediator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMediator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMediator[] = {
        { "can_make_payment_async", reinterpret_cast<PyCFunction>(PaymentMediator_CanMakePaymentAsync), METH_VARARGS, nullptr },
        { "get_supported_method_ids_async", reinterpret_cast<PyCFunction>(PaymentMediator_GetSupportedMethodIdsAsync), METH_VARARGS, nullptr },
        { "submit_payment_request_async", reinterpret_cast<PyCFunction>(PaymentMediator_SubmitPaymentRequestAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentMediator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMediator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentMediator[] = {
        { }
    };

    static PyType_Slot _type_slots_PaymentMediator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMediator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMediator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMediator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMediator) },
        { },
    };

    static PyType_Spec type_spec_PaymentMediator =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentMediator",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMediator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMediator
    };

    // ----- PaymentMerchantInfo class --------------------
    static constexpr const char* const type_name_PaymentMerchantInfo = "PaymentMerchantInfo";

    static PyObject* _new_PaymentMerchantInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMerchantInfo(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMerchantInfo_get_PackageFullName(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMerchantInfo", L"PackageFullName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentMerchantInfo_get_Uri(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMerchantInfo", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMerchantInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMerchantInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMerchantInfo[] = {
        { "_assign_array_", _assign_array_PaymentMerchantInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMerchantInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentMerchantInfo[] = {
        { "package_full_name", reinterpret_cast<getter>(PaymentMerchantInfo_get_PackageFullName), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(PaymentMerchantInfo_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentMerchantInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMerchantInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMerchantInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMerchantInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMerchantInfo) },
        { },
    };

    static PyType_Spec type_spec_PaymentMerchantInfo =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentMerchantInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMerchantInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMerchantInfo
    };

    // ----- PaymentMethodData class --------------------
    static constexpr const char* const type_name_PaymentMethodData = "PaymentMethodData";

    static PyObject* _new_PaymentMethodData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentMethodData instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentMethodData instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentMethodData(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentMethodData_get_JsonData(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMethodData", L"JsonData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentMethodData_get_SupportedMethodIds(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentMethodData", L"SupportedMethodIds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedMethodIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentMethodData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentMethodData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentMethodData[] = {
        { "_assign_array_", _assign_array_PaymentMethodData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentMethodData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentMethodData[] = {
        { "json_data", reinterpret_cast<getter>(PaymentMethodData_get_JsonData), nullptr, nullptr, nullptr },
        { "supported_method_ids", reinterpret_cast<getter>(PaymentMethodData_get_SupportedMethodIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentMethodData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentMethodData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentMethodData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentMethodData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentMethodData) },
        { },
    };

    static PyType_Spec type_spec_PaymentMethodData =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentMethodData",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentMethodData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentMethodData
    };

    // ----- PaymentOptions class --------------------
    static constexpr const char* const type_name_PaymentOptions = "PaymentOptions";

    static PyObject* _new_PaymentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Payments::PaymentOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentOptions(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentOptions_get_ShippingType(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"ShippingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_ShippingType(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"ShippingType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentShippingType>(arg);

            self->obj.ShippingType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestShipping(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestShipping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestShipping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestShipping(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestShipping"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequestShipping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerPhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestPayerPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerPhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            self->obj.RequestPayerPhoneNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestPayerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            self->obj.RequestPayerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentOptions_get_RequestPayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestPayerEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentOptions_put_RequestPayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentOptions", L"RequestPayerEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>(arg);

            self->obj.RequestPayerEmail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentOptions[] = {
        { "_assign_array_", _assign_array_PaymentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentOptions[] = {
        { "shipping_type", reinterpret_cast<getter>(PaymentOptions_get_ShippingType), reinterpret_cast<setter>(PaymentOptions_put_ShippingType), nullptr, nullptr },
        { "request_shipping", reinterpret_cast<getter>(PaymentOptions_get_RequestShipping), reinterpret_cast<setter>(PaymentOptions_put_RequestShipping), nullptr, nullptr },
        { "request_payer_phone_number", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerPhoneNumber), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerPhoneNumber), nullptr, nullptr },
        { "request_payer_name", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerName), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerName), nullptr, nullptr },
        { "request_payer_email", reinterpret_cast<getter>(PaymentOptions_get_RequestPayerEmail), reinterpret_cast<setter>(PaymentOptions_put_RequestPayerEmail), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentOptions) },
        { },
    };

    static PyType_Spec type_spec_PaymentOptions =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentOptions
    };

    // ----- PaymentRequest class --------------------
    static constexpr const char* const type_name_PaymentRequest = "PaymentRequest";

    static PyObject* _new_PaymentRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptions>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentOptions>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentRequest instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentRequest(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequest_get_Details(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Details"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_MerchantInfo(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"MerchantInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MerchantInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_MethodData(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"MethodData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MethodData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_Options(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequest_get_Id(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequest", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequest[] = {
        { "_assign_array_", _assign_array_PaymentRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequest[] = {
        { "details", reinterpret_cast<getter>(PaymentRequest_get_Details), nullptr, nullptr, nullptr },
        { "merchant_info", reinterpret_cast<getter>(PaymentRequest_get_MerchantInfo), nullptr, nullptr, nullptr },
        { "method_data", reinterpret_cast<getter>(PaymentRequest_get_MethodData), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(PaymentRequest_get_Options), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PaymentRequest_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequest) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequest =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequest
    };

    // ----- PaymentRequestChangedArgs class --------------------
    static constexpr const char* const type_name_PaymentRequestChangedArgs = "PaymentRequestChangedArgs";

    static PyObject* _new_PaymentRequestChangedArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PaymentRequestChangedArgs);
        return nullptr;
    }

    static void _dealloc_PaymentRequestChangedArgs(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestChangedArgs_Acknowledge(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"Acknowledge", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>(args, 0);

                self->obj.Acknowledge(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_ChangeKind(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"ChangeKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_SelectedShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"SelectedShippingOption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedShippingOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestChangedArgs_get_ShippingAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedArgs", L"ShippingAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequestChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestChangedArgs[] = {
        { "acknowledge", reinterpret_cast<PyCFunction>(PaymentRequestChangedArgs_Acknowledge), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentRequestChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestChangedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequestChangedArgs[] = {
        { "change_kind", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_ChangeKind), nullptr, nullptr, nullptr },
        { "selected_shipping_option", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_SelectedShippingOption), nullptr, nullptr, nullptr },
        { "shipping_address", reinterpret_cast<getter>(PaymentRequestChangedArgs_get_ShippingAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequestChangedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestChangedArgs) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequestChangedArgs =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentRequestChangedArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestChangedArgs
    };

    // ----- PaymentRequestChangedResult class --------------------
    static constexpr const char* const type_name_PaymentRequestChangedResult = "PaymentRequestChangedResult";

    static PyObject* _new_PaymentRequestChangedResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentRequestChangedResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestChangedResult_get_UpdatedPaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"UpdatedPaymentDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdatedPaymentDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_UpdatedPaymentDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"UpdatedPaymentDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentDetails>(arg);

            self->obj.UpdatedPaymentDetails(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentRequestChangedResult_get_Message(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_Message(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Message(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentRequestChangedResult_get_ChangeAcceptedByMerchant(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"ChangeAcceptedByMerchant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeAcceptedByMerchant());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentRequestChangedResult_put_ChangeAcceptedByMerchant(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestChangedResult", L"ChangeAcceptedByMerchant"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ChangeAcceptedByMerchant(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentRequestChangedResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestChangedResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestChangedResult[] = {
        { "_assign_array_", _assign_array_PaymentRequestChangedResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestChangedResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequestChangedResult[] = {
        { "updated_payment_details", reinterpret_cast<getter>(PaymentRequestChangedResult_get_UpdatedPaymentDetails), reinterpret_cast<setter>(PaymentRequestChangedResult_put_UpdatedPaymentDetails), nullptr, nullptr },
        { "message", reinterpret_cast<getter>(PaymentRequestChangedResult_get_Message), reinterpret_cast<setter>(PaymentRequestChangedResult_put_Message), nullptr, nullptr },
        { "change_accepted_by_merchant", reinterpret_cast<getter>(PaymentRequestChangedResult_get_ChangeAcceptedByMerchant), reinterpret_cast<setter>(PaymentRequestChangedResult_put_ChangeAcceptedByMerchant), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequestChangedResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestChangedResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestChangedResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestChangedResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestChangedResult) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequestChangedResult =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentRequestChangedResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestChangedResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestChangedResult
    };

    // ----- PaymentRequestSubmitResult class --------------------
    static constexpr const char* const type_name_PaymentRequestSubmitResult = "PaymentRequestSubmitResult";

    static PyObject* _new_PaymentRequestSubmitResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PaymentRequestSubmitResult);
        return nullptr;
    }

    static void _dealloc_PaymentRequestSubmitResult(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentRequestSubmitResult_get_Response(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestSubmitResult", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentRequestSubmitResult_get_Status(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentRequestSubmitResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentRequestSubmitResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentRequestSubmitResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentRequestSubmitResult[] = {
        { "_assign_array_", _assign_array_PaymentRequestSubmitResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentRequestSubmitResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentRequestSubmitResult[] = {
        { "response", reinterpret_cast<getter>(PaymentRequestSubmitResult_get_Response), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PaymentRequestSubmitResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentRequestSubmitResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentRequestSubmitResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentRequestSubmitResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentRequestSubmitResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentRequestSubmitResult) },
        { },
    };

    static PyType_Spec type_spec_PaymentRequestSubmitResult =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentRequestSubmitResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentRequestSubmitResult
    };

    // ----- PaymentResponse class --------------------
    static constexpr const char* const type_name_PaymentResponse = "PaymentResponse";

    static PyObject* _new_PaymentResponse(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PaymentResponse);
        return nullptr;
    }

    static void _dealloc_PaymentResponse(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentResponse_CompleteAsync(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"CompleteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentRequestCompletionStatus>(args, 0);

                return py::convert(self->obj.CompleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerEmail(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayerEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerName(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PayerPhoneNumber(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PayerPhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PayerPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_PaymentToken(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"PaymentToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PaymentToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_ShippingAddress(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"ShippingAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentResponse_get_ShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentResponse", L"ShippingOption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShippingOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentResponse[] = {
        { "complete_async", reinterpret_cast<PyCFunction>(PaymentResponse_CompleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PaymentResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentResponse), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentResponse[] = {
        { "payer_email", reinterpret_cast<getter>(PaymentResponse_get_PayerEmail), nullptr, nullptr, nullptr },
        { "payer_name", reinterpret_cast<getter>(PaymentResponse_get_PayerName), nullptr, nullptr, nullptr },
        { "payer_phone_number", reinterpret_cast<getter>(PaymentResponse_get_PayerPhoneNumber), nullptr, nullptr, nullptr },
        { "payment_token", reinterpret_cast<getter>(PaymentResponse_get_PaymentToken), nullptr, nullptr, nullptr },
        { "shipping_address", reinterpret_cast<getter>(PaymentResponse_get_ShippingAddress), nullptr, nullptr, nullptr },
        { "shipping_option", reinterpret_cast<getter>(PaymentResponse_get_ShippingOption), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentResponse[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentResponse) },
        { },
    };

    static PyType_Spec type_spec_PaymentResponse =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentResponse",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentResponse
    };

    // ----- PaymentShippingOption class --------------------
    static constexpr const char* const type_name_PaymentShippingOption = "PaymentShippingOption";

    static PyObject* _new_PaymentShippingOption(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                winrt::Windows::ApplicationModel::Payments::PaymentShippingOption instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentShippingOption(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentShippingOption_get_Tag(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Tag(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Label(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_IsSelected(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_IsSelected(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSelected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PaymentShippingOption_get_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Amount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PaymentShippingOption_put_Amount(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentShippingOption", L"Amount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>(arg);

            self->obj.Amount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PaymentShippingOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentShippingOption(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentShippingOption[] = {
        { "_assign_array_", _assign_array_PaymentShippingOption, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentShippingOption), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentShippingOption[] = {
        { "tag", reinterpret_cast<getter>(PaymentShippingOption_get_Tag), reinterpret_cast<setter>(PaymentShippingOption_put_Tag), nullptr, nullptr },
        { "label", reinterpret_cast<getter>(PaymentShippingOption_get_Label), reinterpret_cast<setter>(PaymentShippingOption_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(PaymentShippingOption_get_IsSelected), reinterpret_cast<setter>(PaymentShippingOption_put_IsSelected), nullptr, nullptr },
        { "amount", reinterpret_cast<getter>(PaymentShippingOption_get_Amount), reinterpret_cast<setter>(PaymentShippingOption_put_Amount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentShippingOption[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentShippingOption) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentShippingOption) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentShippingOption) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentShippingOption) },
        { },
    };

    static PyType_Spec type_spec_PaymentShippingOption =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentShippingOption",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentShippingOption),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentShippingOption
    };

    // ----- PaymentToken class --------------------
    static constexpr const char* const type_name_PaymentToken = "PaymentToken";

    static PyObject* _new_PaymentToken(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Payments::PaymentToken instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Payments::PaymentToken instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentToken(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PaymentToken_get_JsonDetails(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentToken", L"JsonDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.JsonDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PaymentToken_get_PaymentMethodId(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Payments.PaymentToken", L"PaymentMethodId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PaymentMethodId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PaymentToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Payments::PaymentToken>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PaymentToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Payments::PaymentToken>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentToken[] = {
        { "_assign_array_", _assign_array_PaymentToken, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PaymentToken), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PaymentToken[] = {
        { "json_details", reinterpret_cast<getter>(PaymentToken_get_JsonDetails), nullptr, nullptr, nullptr },
        { "payment_method_id", reinterpret_cast<getter>(PaymentToken_get_PaymentMethodId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PaymentToken[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PaymentToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PaymentToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PaymentToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PaymentToken) },
        { },
    };

    static PyType_Spec type_spec_PaymentToken =
    {
        "_winsdk_Windows_ApplicationModel_Payments.PaymentToken",
        sizeof(py::wrapper::Windows::ApplicationModel::Payments::PaymentToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentToken
    };

    // ----- Windows.ApplicationModel.Payments Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Payments");

    static PyMethodDef module_methods[] = {
        {"_register_PaymentCanMakePaymentResultStatus", register_PaymentCanMakePaymentResultStatus, METH_O, "registers type"},
        {"_register_PaymentOptionPresence", register_PaymentOptionPresence, METH_O, "registers type"},
        {"_register_PaymentRequestChangeKind", register_PaymentRequestChangeKind, METH_O, "registers type"},
        {"_register_PaymentRequestCompletionStatus", register_PaymentRequestCompletionStatus, METH_O, "registers type"},
        {"_register_PaymentRequestStatus", register_PaymentRequestStatus, METH_O, "registers type"},
        {"_register_PaymentShippingType", register_PaymentShippingType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PaymentCanMakePaymentResultStatus);
        Py_VISIT(state->type_PaymentOptionPresence);
        Py_VISIT(state->type_PaymentRequestChangeKind);
        Py_VISIT(state->type_PaymentRequestCompletionStatus);
        Py_VISIT(state->type_PaymentRequestStatus);
        Py_VISIT(state->type_PaymentShippingType);
        Py_VISIT(state->type_PaymentAddress);
        Py_VISIT(state->type_PaymentCanMakePaymentResult);
        Py_VISIT(state->type_PaymentCurrencyAmount);
        Py_VISIT(state->type_PaymentDetails);
        Py_VISIT(state->type_PaymentDetailsModifier);
        Py_VISIT(state->type_PaymentItem);
        Py_VISIT(state->type_PaymentMediator);
        Py_VISIT(state->type_PaymentMerchantInfo);
        Py_VISIT(state->type_PaymentMethodData);
        Py_VISIT(state->type_PaymentOptions);
        Py_VISIT(state->type_PaymentRequest);
        Py_VISIT(state->type_PaymentRequestChangedArgs);
        Py_VISIT(state->type_PaymentRequestChangedResult);
        Py_VISIT(state->type_PaymentRequestSubmitResult);
        Py_VISIT(state->type_PaymentResponse);
        Py_VISIT(state->type_PaymentShippingOption);
        Py_VISIT(state->type_PaymentToken);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PaymentCanMakePaymentResultStatus);
        Py_CLEAR(state->type_PaymentOptionPresence);
        Py_CLEAR(state->type_PaymentRequestChangeKind);
        Py_CLEAR(state->type_PaymentRequestCompletionStatus);
        Py_CLEAR(state->type_PaymentRequestStatus);
        Py_CLEAR(state->type_PaymentShippingType);
        Py_CLEAR(state->type_PaymentAddress);
        Py_CLEAR(state->type_PaymentCanMakePaymentResult);
        Py_CLEAR(state->type_PaymentCurrencyAmount);
        Py_CLEAR(state->type_PaymentDetails);
        Py_CLEAR(state->type_PaymentDetailsModifier);
        Py_CLEAR(state->type_PaymentItem);
        Py_CLEAR(state->type_PaymentMediator);
        Py_CLEAR(state->type_PaymentMerchantInfo);
        Py_CLEAR(state->type_PaymentMethodData);
        Py_CLEAR(state->type_PaymentOptions);
        Py_CLEAR(state->type_PaymentRequest);
        Py_CLEAR(state->type_PaymentRequestChangedArgs);
        Py_CLEAR(state->type_PaymentRequestChangedResult);
        Py_CLEAR(state->type_PaymentRequestSubmitResult);
        Py_CLEAR(state->type_PaymentResponse);
        Py_CLEAR(state->type_PaymentShippingOption);
        Py_CLEAR(state->type_PaymentToken);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Payments",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Payments

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Payments(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_PaymentAddress = py::register_python_type(module.get(), type_name_PaymentAddress, &type_spec_PaymentAddress, bases.get(), nullptr);
    if (!state->type_PaymentAddress)
    {
        return nullptr;
    }

    state->type_PaymentCanMakePaymentResult = py::register_python_type(module.get(), type_name_PaymentCanMakePaymentResult, &type_spec_PaymentCanMakePaymentResult, bases.get(), nullptr);
    if (!state->type_PaymentCanMakePaymentResult)
    {
        return nullptr;
    }

    state->type_PaymentCurrencyAmount = py::register_python_type(module.get(), type_name_PaymentCurrencyAmount, &type_spec_PaymentCurrencyAmount, bases.get(), nullptr);
    if (!state->type_PaymentCurrencyAmount)
    {
        return nullptr;
    }

    state->type_PaymentDetails = py::register_python_type(module.get(), type_name_PaymentDetails, &type_spec_PaymentDetails, bases.get(), nullptr);
    if (!state->type_PaymentDetails)
    {
        return nullptr;
    }

    state->type_PaymentDetailsModifier = py::register_python_type(module.get(), type_name_PaymentDetailsModifier, &type_spec_PaymentDetailsModifier, bases.get(), nullptr);
    if (!state->type_PaymentDetailsModifier)
    {
        return nullptr;
    }

    state->type_PaymentItem = py::register_python_type(module.get(), type_name_PaymentItem, &type_spec_PaymentItem, bases.get(), nullptr);
    if (!state->type_PaymentItem)
    {
        return nullptr;
    }

    state->type_PaymentMediator = py::register_python_type(module.get(), type_name_PaymentMediator, &type_spec_PaymentMediator, bases.get(), nullptr);
    if (!state->type_PaymentMediator)
    {
        return nullptr;
    }

    state->type_PaymentMerchantInfo = py::register_python_type(module.get(), type_name_PaymentMerchantInfo, &type_spec_PaymentMerchantInfo, bases.get(), nullptr);
    if (!state->type_PaymentMerchantInfo)
    {
        return nullptr;
    }

    state->type_PaymentMethodData = py::register_python_type(module.get(), type_name_PaymentMethodData, &type_spec_PaymentMethodData, bases.get(), nullptr);
    if (!state->type_PaymentMethodData)
    {
        return nullptr;
    }

    state->type_PaymentOptions = py::register_python_type(module.get(), type_name_PaymentOptions, &type_spec_PaymentOptions, bases.get(), nullptr);
    if (!state->type_PaymentOptions)
    {
        return nullptr;
    }

    state->type_PaymentRequest = py::register_python_type(module.get(), type_name_PaymentRequest, &type_spec_PaymentRequest, bases.get(), nullptr);
    if (!state->type_PaymentRequest)
    {
        return nullptr;
    }

    state->type_PaymentRequestChangedArgs = py::register_python_type(module.get(), type_name_PaymentRequestChangedArgs, &type_spec_PaymentRequestChangedArgs, bases.get(), nullptr);
    if (!state->type_PaymentRequestChangedArgs)
    {
        return nullptr;
    }

    state->type_PaymentRequestChangedResult = py::register_python_type(module.get(), type_name_PaymentRequestChangedResult, &type_spec_PaymentRequestChangedResult, bases.get(), nullptr);
    if (!state->type_PaymentRequestChangedResult)
    {
        return nullptr;
    }

    state->type_PaymentRequestSubmitResult = py::register_python_type(module.get(), type_name_PaymentRequestSubmitResult, &type_spec_PaymentRequestSubmitResult, bases.get(), nullptr);
    if (!state->type_PaymentRequestSubmitResult)
    {
        return nullptr;
    }

    state->type_PaymentResponse = py::register_python_type(module.get(), type_name_PaymentResponse, &type_spec_PaymentResponse, bases.get(), nullptr);
    if (!state->type_PaymentResponse)
    {
        return nullptr;
    }

    state->type_PaymentShippingOption = py::register_python_type(module.get(), type_name_PaymentShippingOption, &type_spec_PaymentShippingOption, bases.get(), nullptr);
    if (!state->type_PaymentShippingOption)
    {
        return nullptr;
    }

    state->type_PaymentToken = py::register_python_type(module.get(), type_name_PaymentToken, &type_spec_PaymentToken, bases.get(), nullptr);
    if (!state->type_PaymentToken)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResultStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentCanMakePaymentResultStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResultStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentOptionPresence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentOptionPresence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangeKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequestChangeKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequestChangeKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestCompletionStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequestCompletionStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequestCompletionStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequestStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequestStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Payments::PaymentShippingType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentShippingType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentShippingType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentAddress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentAddress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentAddress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentCanMakePaymentResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentCanMakePaymentResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentCurrencyAmount;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentCurrencyAmount is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentDetailsModifier;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentDetailsModifier is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentItem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentItem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentItem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentMediator>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentMediator;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentMediator is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentMerchantInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentMerchantInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentMethodData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentMethodData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentMethodData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequestChangedArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequestChangedResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequestChangedResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentRequestSubmitResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentRequestSubmitResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentResponse>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentResponse;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentResponse is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentShippingOption>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentShippingOption;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentShippingOption is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Payments::PaymentToken>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Payments;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Payments");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PaymentToken;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Payments::PaymentToken is not registered");
        return nullptr;
    }

    return python_type;
}
