// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.UI.UIAutomation.Core.h"


PyObject* py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::convert(winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::convert(winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId");
    throw python_exception();
}

namespace py::cpp::Windows::UI::UIAutomation::Core
{
    struct module_state
    {
        PyObject* type_AutomationRemoteOperationStatus;
        PyTypeObject* type_AutomationRemoteOperationResult;
        PyTypeObject* type_CoreAutomationRegistrar;
        PyTypeObject* type_CoreAutomationRemoteOperation;
        PyTypeObject* type_CoreAutomationRemoteOperationContext;
        PyTypeObject* type_RemoteAutomationClientSession;
        PyTypeObject* type_RemoteAutomationConnectionRequestedEventArgs;
        PyTypeObject* type_RemoteAutomationDisconnectedEventArgs;
        PyTypeObject* type_RemoteAutomationServer;
        PyTypeObject* type_RemoteAutomationWindow;
        PyTypeObject* type_ICoreAutomationConnectionBoundObjectProvider;
        PyTypeObject* type_ICoreAutomationRemoteOperationExtensionProvider;
        PyTypeObject* type_AutomationAnnotationTypeRegistration;
        PyTypeObject* type_AutomationRemoteOperationOperandId;
    };

    static PyObject* register_AutomationRemoteOperationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AutomationRemoteOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AutomationRemoteOperationStatus = type;
        Py_INCREF(state->type_AutomationRemoteOperationStatus);


        Py_RETURN_NONE;
    }

    // ----- AutomationRemoteOperationResult class --------------------
    static constexpr const char* const type_name_AutomationRemoteOperationResult = "AutomationRemoteOperationResult";

    static PyObject* _new_AutomationRemoteOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AutomationRemoteOperationResult);
        return nullptr;
    }

    static void _dealloc_AutomationRemoteOperationResult(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationRemoteOperationResult_GetOperand(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"GetOperand", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.GetOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_HasOperand(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"HasOperand", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.HasOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_ErrorLocation(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"ErrorLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_ExtendedError(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_Status(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationRemoteOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationRemoteOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationRemoteOperationResult[] = {
        { "get_operand", reinterpret_cast<PyCFunction>(AutomationRemoteOperationResult_GetOperand), METH_VARARGS, nullptr },
        { "has_operand", reinterpret_cast<PyCFunction>(AutomationRemoteOperationResult_HasOperand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutomationRemoteOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationRemoteOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationRemoteOperationResult[] = {
        { "error_location", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_ErrorLocation), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationRemoteOperationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationRemoteOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationRemoteOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationRemoteOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationRemoteOperationResult) },
        { },
    };

    static PyType_Spec type_spec_AutomationRemoteOperationResult =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.AutomationRemoteOperationResult",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationRemoteOperationResult
    };

    // ----- CoreAutomationRegistrar class --------------------
    static constexpr const char* const type_name_CoreAutomationRegistrar = "CoreAutomationRegistrar";

    static PyObject* _new_CoreAutomationRegistrar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreAutomationRegistrar);
        return nullptr;
    }

    static PyObject* CoreAutomationRegistrar_RegisterAnnotationType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRegistrar", L"RegisterAnnotationType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar::RegisterAnnotationType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRegistrar_UnregisterAnnotationType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRegistrar", L"UnregisterAnnotationType", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar::UnregisterAnnotationType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRegistrar[] = {
        { "register_annotation_type", reinterpret_cast<PyCFunction>(CoreAutomationRegistrar_RegisterAnnotationType), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister_annotation_type", reinterpret_cast<PyCFunction>(CoreAutomationRegistrar_UnregisterAnnotationType), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRegistrar[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRegistrar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAutomationRegistrar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAutomationRegistrar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAutomationRegistrar) },
        { },
    };

    static PyType_Spec type_spec_CoreAutomationRegistrar =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.CoreAutomationRegistrar",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRegistrar
    };

    // ----- CoreAutomationRemoteOperation class --------------------
    static constexpr const char* const type_name_CoreAutomationRemoteOperation = "CoreAutomationRemoteOperation";

    static PyObject* _new_CoreAutomationRemoteOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreAutomationRemoteOperation(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAutomationRemoteOperation_AddToResults(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"AddToResults", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                self->obj.AddToResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_Execute(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"Execute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.Execute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportConnectionBoundObject(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"ImportConnectionBoundObject", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationConnectionBoundObject>(args, 1);

                self->obj.ImportConnectionBoundObject(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportElement(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"ImportElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationElement>(args, 1);

                self->obj.ImportElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportTextRange(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"ImportTextRange", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationTextRange>(args, 1);

                self->obj.ImportTextRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_IsOpcodeSupported(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"IsOpcodeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsOpcodeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreAutomationRemoteOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreAutomationRemoteOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRemoteOperation[] = {
        { "add_to_results", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_AddToResults), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_Execute), METH_VARARGS, nullptr },
        { "import_connection_bound_object", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportConnectionBoundObject), METH_VARARGS, nullptr },
        { "import_element", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportElement), METH_VARARGS, nullptr },
        { "import_text_range", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportTextRange), METH_VARARGS, nullptr },
        { "is_opcode_supported", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_IsOpcodeSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreAutomationRemoteOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAutomationRemoteOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRemoteOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRemoteOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAutomationRemoteOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreAutomationRemoteOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAutomationRemoteOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAutomationRemoteOperation) },
        { },
    };

    static PyType_Spec type_spec_CoreAutomationRemoteOperation =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.CoreAutomationRemoteOperation",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRemoteOperation
    };

    // ----- CoreAutomationRemoteOperationContext class --------------------
    static constexpr const char* const type_name_CoreAutomationRemoteOperationContext = "CoreAutomationRemoteOperationContext";

    static PyObject* _new_CoreAutomationRemoteOperationContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreAutomationRemoteOperationContext);
        return nullptr;
    }

    static void _dealloc_CoreAutomationRemoteOperationContext(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAutomationRemoteOperationContext_GetOperand(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperationContext", L"GetOperand", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.GetOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperationContext_SetOperand(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperationContext", L"SetOperand", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetOperand(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperationContext", L"SetOperand", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.SetOperand(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreAutomationRemoteOperationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreAutomationRemoteOperationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRemoteOperationContext[] = {
        { "get_operand", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperationContext_GetOperand), METH_VARARGS, nullptr },
        { "set_operand", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperationContext_SetOperand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreAutomationRemoteOperationContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAutomationRemoteOperationContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRemoteOperationContext[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRemoteOperationContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAutomationRemoteOperationContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreAutomationRemoteOperationContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAutomationRemoteOperationContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAutomationRemoteOperationContext) },
        { },
    };

    static PyType_Spec type_spec_CoreAutomationRemoteOperationContext =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.CoreAutomationRemoteOperationContext",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRemoteOperationContext
    };

    // ----- RemoteAutomationClientSession class --------------------
    static constexpr const char* const type_name_RemoteAutomationClientSession = "RemoteAutomationClientSession";

    static PyObject* _new_RemoteAutomationClientSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteAutomationClientSession(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationClientSession_CreateWindowAsync(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"CreateWindowAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.CreateWindowAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_Start(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_Stop(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_get_SessionId(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"SessionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_add_ConnectionRequested(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"ConnectionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession, winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_remove_ConnectionRequested(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"ConnectionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_add_Disconnected(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession, winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_remove_Disconnected(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationClientSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationClientSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationClientSession[] = {
        { "create_window_async", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_CreateWindowAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_Stop), METH_VARARGS, nullptr },
        { "add_connection_requested", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_add_ConnectionRequested), METH_O, nullptr },
        { "remove_connection_requested", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_remove_ConnectionRequested), METH_O, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_remove_Disconnected), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteAutomationClientSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationClientSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationClientSession[] = {
        { "session_id", reinterpret_cast<getter>(RemoteAutomationClientSession_get_SessionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationClientSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationClientSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationClientSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationClientSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationClientSession) },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationClientSession =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationClientSession",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationClientSession
    };

    // ----- RemoteAutomationConnectionRequestedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteAutomationConnectionRequestedEventArgs = "RemoteAutomationConnectionRequestedEventArgs";

    static PyObject* _new_RemoteAutomationConnectionRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationConnectionRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationConnectionRequestedEventArgs(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationConnectionRequestedEventArgs_get_LocalPipeName(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationConnectionRequestedEventArgs", L"LocalPipeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalPipeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationConnectionRequestedEventArgs_get_RemoteProcessId(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationConnectionRequestedEventArgs", L"RemoteProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationConnectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationConnectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationConnectionRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteAutomationConnectionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationConnectionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationConnectionRequestedEventArgs[] = {
        { "local_pipe_name", reinterpret_cast<getter>(RemoteAutomationConnectionRequestedEventArgs_get_LocalPipeName), nullptr, nullptr, nullptr },
        { "remote_process_id", reinterpret_cast<getter>(RemoteAutomationConnectionRequestedEventArgs_get_RemoteProcessId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationConnectionRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationConnectionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationConnectionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationConnectionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationConnectionRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationConnectionRequestedEventArgs =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationConnectionRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationConnectionRequestedEventArgs
    };

    // ----- RemoteAutomationDisconnectedEventArgs class --------------------
    static constexpr const char* const type_name_RemoteAutomationDisconnectedEventArgs = "RemoteAutomationDisconnectedEventArgs";

    static PyObject* _new_RemoteAutomationDisconnectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationDisconnectedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationDisconnectedEventArgs(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationDisconnectedEventArgs_get_LocalPipeName(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationDisconnectedEventArgs", L"LocalPipeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalPipeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteAutomationDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationDisconnectedEventArgs[] = {
        { "local_pipe_name", reinterpret_cast<getter>(RemoteAutomationDisconnectedEventArgs_get_LocalPipeName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationDisconnectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationDisconnectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationDisconnectedEventArgs =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationDisconnectedEventArgs
    };

    // ----- RemoteAutomationServer class --------------------
    static constexpr const char* const type_name_RemoteAutomationServer = "RemoteAutomationServer";

    static PyObject* _new_RemoteAutomationServer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationServer);
        return nullptr;
    }

    static PyObject* RemoteAutomationServer_ReportSession(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationServer", L"ReportSession", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer::ReportSession(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationServer[] = {
        { "report_session", reinterpret_cast<PyCFunction>(RemoteAutomationServer_ReportSession), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationServer[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationServer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationServer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationServer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationServer) },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationServer =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationServer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationServer
    };

    // ----- RemoteAutomationWindow class --------------------
    static constexpr const char* const type_name_RemoteAutomationWindow = "RemoteAutomationWindow";

    static PyObject* _new_RemoteAutomationWindow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationWindow);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationWindow(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationWindow_UnregisterAsync(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationWindow", L"UnregisterAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnregisterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationWindow_get_AutomationProvider(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationWindow", L"AutomationProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationWindow[] = {
        { "unregister_async", reinterpret_cast<PyCFunction>(RemoteAutomationWindow_UnregisterAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteAutomationWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationWindow[] = {
        { "automation_provider", reinterpret_cast<getter>(RemoteAutomationWindow_get_AutomationProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationWindow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationWindow) },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationWindow =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationWindow",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationWindow
    };

    // ----- ICoreAutomationConnectionBoundObjectProvider interface --------------------
    static constexpr const char* const type_name_ICoreAutomationConnectionBoundObjectProvider = "ICoreAutomationConnectionBoundObjectProvider";

    static PyObject* _new_ICoreAutomationConnectionBoundObjectProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICoreAutomationConnectionBoundObjectProvider);
        return nullptr;
    }

    static void _dealloc_ICoreAutomationConnectionBoundObjectProvider(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAutomationConnectionBoundObjectProvider_get_IsComThreadingRequired(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.ICoreAutomationConnectionBoundObjectProvider", L"IsComThreadingRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComThreadingRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreAutomationConnectionBoundObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreAutomationConnectionBoundObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAutomationConnectionBoundObjectProvider[] = {
        { "_assign_array_", _assign_array_ICoreAutomationConnectionBoundObjectProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAutomationConnectionBoundObjectProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAutomationConnectionBoundObjectProvider[] = {
        { "is_com_threading_required", reinterpret_cast<getter>(ICoreAutomationConnectionBoundObjectProvider_get_IsComThreadingRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreAutomationConnectionBoundObjectProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreAutomationConnectionBoundObjectProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreAutomationConnectionBoundObjectProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreAutomationConnectionBoundObjectProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreAutomationConnectionBoundObjectProvider) },
        { },
    };

    static PyType_Spec type_spec_ICoreAutomationConnectionBoundObjectProvider =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.ICoreAutomationConnectionBoundObjectProvider",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAutomationConnectionBoundObjectProvider
    };

    // ----- ICoreAutomationRemoteOperationExtensionProvider interface --------------------
    static constexpr const char* const type_name_ICoreAutomationRemoteOperationExtensionProvider = "ICoreAutomationRemoteOperationExtensionProvider";

    static PyObject* _new_ICoreAutomationRemoteOperationExtensionProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICoreAutomationRemoteOperationExtensionProvider);
        return nullptr;
    }

    static void _dealloc_ICoreAutomationRemoteOperationExtensionProvider(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAutomationRemoteOperationExtensionProvider_CallExtension(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.ICoreAutomationRemoteOperationExtensionProvider", L"CallExtension", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId, false>>(args, 2);

                self->obj.CallExtension(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreAutomationRemoteOperationExtensionProvider_IsExtensionSupported(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.ICoreAutomationRemoteOperationExtensionProvider", L"IsExtensionSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.IsExtensionSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreAutomationRemoteOperationExtensionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreAutomationRemoteOperationExtensionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { "call_extension", reinterpret_cast<PyCFunction>(ICoreAutomationRemoteOperationExtensionProvider_CallExtension), METH_VARARGS, nullptr },
        { "is_extension_supported", reinterpret_cast<PyCFunction>(ICoreAutomationRemoteOperationExtensionProvider_IsExtensionSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICoreAutomationRemoteOperationExtensionProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAutomationRemoteOperationExtensionProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ICoreAutomationRemoteOperationExtensionProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreAutomationRemoteOperationExtensionProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreAutomationRemoteOperationExtensionProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreAutomationRemoteOperationExtensionProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreAutomationRemoteOperationExtensionProvider) },
        { },
    };

    static PyType_Spec type_spec_ICoreAutomationRemoteOperationExtensionProvider =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.ICoreAutomationRemoteOperationExtensionProvider",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAutomationRemoteOperationExtensionProvider
    };

    // ----- AutomationAnnotationTypeRegistration struct --------------------
    static constexpr const char* const type_name_AutomationAnnotationTypeRegistration = "AutomationAnnotationTypeRegistration";

    PyObject* _new_AutomationAnnotationTypeRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _LocalId{};

        static const char* kwlist[] = {"local_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_LocalId))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration return_value{ _LocalId };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_AutomationAnnotationTypeRegistration(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self) noexcept
    {
    }

    static PyObject* AutomationAnnotationTypeRegistration_get_LocalId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationAnnotationTypeRegistration_set_LocalId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LocalId = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_AutomationAnnotationTypeRegistration[] = {
        { "local_id", reinterpret_cast<getter>(AutomationAnnotationTypeRegistration_get_LocalId), reinterpret_cast<setter>(AutomationAnnotationTypeRegistration_set_LocalId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationAnnotationTypeRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationAnnotationTypeRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationAnnotationTypeRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationAnnotationTypeRegistration) },
        { },
    };

    static PyType_Spec type_spec_AutomationAnnotationTypeRegistration =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.AutomationAnnotationTypeRegistration",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationAnnotationTypeRegistration
    };

    // ----- AutomationRemoteOperationOperandId struct --------------------
    static constexpr const char* const type_name_AutomationRemoteOperationOperandId = "AutomationRemoteOperationOperandId";

    PyObject* _new_AutomationRemoteOperationOperandId(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId return_value{ _Value };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_AutomationRemoteOperationOperandId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self) noexcept
    {
    }

    static PyObject* AutomationRemoteOperationOperandId_get_Value(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationRemoteOperationOperandId_set_Value(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_AutomationRemoteOperationOperandId[] = {
        { "value", reinterpret_cast<getter>(AutomationRemoteOperationOperandId_get_Value), reinterpret_cast<setter>(AutomationRemoteOperationOperandId_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationRemoteOperationOperandId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationRemoteOperationOperandId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationRemoteOperationOperandId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationRemoteOperationOperandId) },
        { },
    };

    static PyType_Spec type_spec_AutomationRemoteOperationOperandId =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.AutomationRemoteOperationOperandId",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationRemoteOperationOperandId
    };

    // ----- Windows.UI.UIAutomation.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::UIAutomation::Core");

    static PyMethodDef module_methods[] = {
        {"_register_AutomationRemoteOperationStatus", register_AutomationRemoteOperationStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AutomationRemoteOperationStatus);
        Py_VISIT(state->type_AutomationRemoteOperationResult);
        Py_VISIT(state->type_CoreAutomationRegistrar);
        Py_VISIT(state->type_CoreAutomationRemoteOperation);
        Py_VISIT(state->type_CoreAutomationRemoteOperationContext);
        Py_VISIT(state->type_RemoteAutomationClientSession);
        Py_VISIT(state->type_RemoteAutomationConnectionRequestedEventArgs);
        Py_VISIT(state->type_RemoteAutomationDisconnectedEventArgs);
        Py_VISIT(state->type_RemoteAutomationServer);
        Py_VISIT(state->type_RemoteAutomationWindow);
        Py_VISIT(state->type_ICoreAutomationConnectionBoundObjectProvider);
        Py_VISIT(state->type_ICoreAutomationRemoteOperationExtensionProvider);
        Py_VISIT(state->type_AutomationAnnotationTypeRegistration);
        Py_VISIT(state->type_AutomationRemoteOperationOperandId);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AutomationRemoteOperationStatus);
        Py_CLEAR(state->type_AutomationRemoteOperationResult);
        Py_CLEAR(state->type_CoreAutomationRegistrar);
        Py_CLEAR(state->type_CoreAutomationRemoteOperation);
        Py_CLEAR(state->type_CoreAutomationRemoteOperationContext);
        Py_CLEAR(state->type_RemoteAutomationClientSession);
        Py_CLEAR(state->type_RemoteAutomationConnectionRequestedEventArgs);
        Py_CLEAR(state->type_RemoteAutomationDisconnectedEventArgs);
        Py_CLEAR(state->type_RemoteAutomationServer);
        Py_CLEAR(state->type_RemoteAutomationWindow);
        Py_CLEAR(state->type_ICoreAutomationConnectionBoundObjectProvider);
        Py_CLEAR(state->type_ICoreAutomationRemoteOperationExtensionProvider);
        Py_CLEAR(state->type_AutomationAnnotationTypeRegistration);
        Py_CLEAR(state->type_AutomationRemoteOperationOperandId);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_UIAutomation_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::UIAutomation::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_UIAutomation_Core(void) noexcept
{
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AutomationRemoteOperationResult = py::register_python_type(module.get(), type_name_AutomationRemoteOperationResult, &type_spec_AutomationRemoteOperationResult, bases.get(), nullptr);
    if (!state->type_AutomationRemoteOperationResult)
    {
        return nullptr;
    }

    state->type_CoreAutomationRegistrar = py::register_python_type(module.get(), type_name_CoreAutomationRegistrar, &type_spec_CoreAutomationRegistrar, nullptr, nullptr);
    if (!state->type_CoreAutomationRegistrar)
    {
        return nullptr;
    }

    state->type_CoreAutomationRemoteOperation = py::register_python_type(module.get(), type_name_CoreAutomationRemoteOperation, &type_spec_CoreAutomationRemoteOperation, bases.get(), nullptr);
    if (!state->type_CoreAutomationRemoteOperation)
    {
        return nullptr;
    }

    state->type_CoreAutomationRemoteOperationContext = py::register_python_type(module.get(), type_name_CoreAutomationRemoteOperationContext, &type_spec_CoreAutomationRemoteOperationContext, bases.get(), nullptr);
    if (!state->type_CoreAutomationRemoteOperationContext)
    {
        return nullptr;
    }

    state->type_RemoteAutomationClientSession = py::register_python_type(module.get(), type_name_RemoteAutomationClientSession, &type_spec_RemoteAutomationClientSession, bases.get(), nullptr);
    if (!state->type_RemoteAutomationClientSession)
    {
        return nullptr;
    }

    state->type_RemoteAutomationConnectionRequestedEventArgs = py::register_python_type(module.get(), type_name_RemoteAutomationConnectionRequestedEventArgs, &type_spec_RemoteAutomationConnectionRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_RemoteAutomationConnectionRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_RemoteAutomationDisconnectedEventArgs = py::register_python_type(module.get(), type_name_RemoteAutomationDisconnectedEventArgs, &type_spec_RemoteAutomationDisconnectedEventArgs, bases.get(), nullptr);
    if (!state->type_RemoteAutomationDisconnectedEventArgs)
    {
        return nullptr;
    }

    state->type_RemoteAutomationServer = py::register_python_type(module.get(), type_name_RemoteAutomationServer, &type_spec_RemoteAutomationServer, nullptr, nullptr);
    if (!state->type_RemoteAutomationServer)
    {
        return nullptr;
    }

    state->type_RemoteAutomationWindow = py::register_python_type(module.get(), type_name_RemoteAutomationWindow, &type_spec_RemoteAutomationWindow, bases.get(), nullptr);
    if (!state->type_RemoteAutomationWindow)
    {
        return nullptr;
    }

    state->type_ICoreAutomationConnectionBoundObjectProvider = py::register_python_type(module.get(), type_name_ICoreAutomationConnectionBoundObjectProvider, &type_spec_ICoreAutomationConnectionBoundObjectProvider, bases.get(), nullptr);
    if (!state->type_ICoreAutomationConnectionBoundObjectProvider)
    {
        return nullptr;
    }

    state->type_ICoreAutomationRemoteOperationExtensionProvider = py::register_python_type(module.get(), type_name_ICoreAutomationRemoteOperationExtensionProvider, &type_spec_ICoreAutomationRemoteOperationExtensionProvider, bases.get(), nullptr);
    if (!state->type_ICoreAutomationRemoteOperationExtensionProvider)
    {
        return nullptr;
    }

    state->type_AutomationAnnotationTypeRegistration = py::register_python_type(module.get(), type_name_AutomationAnnotationTypeRegistration, &type_spec_AutomationAnnotationTypeRegistration, bases.get(), nullptr);
    if (!state->type_AutomationAnnotationTypeRegistration)
    {
        return nullptr;
    }

    state->type_AutomationRemoteOperationOperandId = py::register_python_type(module.get(), type_name_AutomationRemoteOperationOperandId, &type_spec_AutomationRemoteOperationOperandId, bases.get(), nullptr);
    if (!state->type_AutomationRemoteOperationOperandId)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationRemoteOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationRemoteOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAutomationRegistrar;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAutomationRemoteOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAutomationRemoteOperationContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationClientSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationConnectionRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationDisconnectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationServer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationWindow;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreAutomationConnectionBoundObjectProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreAutomationRemoteOperationExtensionProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationAnnotationTypeRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationRemoteOperationOperandId;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId is not registered");
        return nullptr;
    }

    return python_type;
}
