// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Phone.PersonalInformation.h"


namespace py::cpp::Windows::Phone::PersonalInformation
{
    struct module_state
    {
        PyObject* type_ContactChangeType;
        PyObject* type_ContactQueryResultOrdering;
        PyObject* type_ContactStoreApplicationAccessMode;
        PyObject* type_ContactStoreSystemAccessMode;
        PyObject* type_VCardFormat;
        PyTypeObject* type_ContactAddress;
        PyTypeObject* type_ContactChangeRecord;
        PyTypeObject* type_ContactInformation;
        PyTypeObject* type_ContactQueryOptions;
        PyTypeObject* type_ContactQueryResult;
        PyTypeObject* type_ContactStore;
        PyTypeObject* type_KnownContactProperties;
        PyTypeObject* type_StoredContact;
        PyTypeObject* type_IContactInformation;
        PyTypeObject* type_IContactInformation2;
    };

    static PyObject* register_ContactChangeType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ContactChangeType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ContactChangeType = type;
        Py_INCREF(state->type_ContactChangeType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ContactQueryResultOrdering(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ContactQueryResultOrdering)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ContactQueryResultOrdering = type;
        Py_INCREF(state->type_ContactQueryResultOrdering);


        Py_RETURN_NONE;
    }

    static PyObject* register_ContactStoreApplicationAccessMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ContactStoreApplicationAccessMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ContactStoreApplicationAccessMode = type;
        Py_INCREF(state->type_ContactStoreApplicationAccessMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ContactStoreSystemAccessMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ContactStoreSystemAccessMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ContactStoreSystemAccessMode = type;
        Py_INCREF(state->type_ContactStoreSystemAccessMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_VCardFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VCardFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VCardFormat = type;
        Py_INCREF(state->type_VCardFormat);


        Py_RETURN_NONE;
    }

    // ----- ContactAddress class --------------------
    static constexpr const char* const type_name_ContactAddress = "ContactAddress";

    static PyObject* _new_ContactAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Phone::PersonalInformation::ContactAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAddress(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactAddress_get_StreetAddress(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"StreetAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreetAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_StreetAddress(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"StreetAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StreetAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Region(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Region(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_PostalCode(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_PostalCode(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"PostalCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Locality(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Locality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Locality(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Locality"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Locality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Country(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Country(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactAddress", L"Country"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAddress[] = {
        { "_assign_array_", _assign_array_ContactAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAddress[] = {
        { "street_address", reinterpret_cast<getter>(ContactAddress_get_StreetAddress), reinterpret_cast<setter>(ContactAddress_put_StreetAddress), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(ContactAddress_get_Region), reinterpret_cast<setter>(ContactAddress_put_Region), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(ContactAddress_get_PostalCode), reinterpret_cast<setter>(ContactAddress_put_PostalCode), nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ContactAddress_get_Locality), reinterpret_cast<setter>(ContactAddress_put_Locality), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(ContactAddress_get_Country), reinterpret_cast<setter>(ContactAddress_put_Country), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactAddress) },
        { },
    };

    static PyType_Spec type_spec_ContactAddress =
    {
        "_winsdk_Windows_Phone_PersonalInformation.ContactAddress",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAddress
    };

    // ----- ContactChangeRecord class --------------------
    static constexpr const char* const type_name_ContactChangeRecord = "ContactChangeRecord";

    static PyObject* _new_ContactChangeRecord(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactChangeRecord);
        return nullptr;
    }

    static void _dealloc_ContactChangeRecord(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactChangeRecord_get_ChangeType(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"ChangeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChangeRecord_get_Id(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChangeRecord_get_RemoteId(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChangeRecord_get_RevisionNumber(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactChangeRecord", L"RevisionNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevisionNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactChangeRecord(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactChangeRecord(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeRecord[] = {
        { "_assign_array_", _assign_array_ContactChangeRecord, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangeRecord), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangeRecord[] = {
        { "change_type", reinterpret_cast<getter>(ContactChangeRecord_get_ChangeType), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactChangeRecord_get_Id), nullptr, nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ContactChangeRecord_get_RemoteId), nullptr, nullptr, nullptr },
        { "revision_number", reinterpret_cast<getter>(ContactChangeRecord_get_RevisionNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactChangeRecord[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactChangeRecord) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactChangeRecord) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactChangeRecord) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactChangeRecord) },
        { },
    };

    static PyType_Spec type_spec_ContactChangeRecord =
    {
        "_winsdk_Windows_Phone_PersonalInformation.ContactChangeRecord",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactChangeRecord),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeRecord
    };

    // ----- ContactInformation class --------------------
    static constexpr const char* const type_name_ContactInformation = "ContactInformation";

    static PyObject* _new_ContactInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Phone::PersonalInformation::ContactInformation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactInformation(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactInformation_GetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GetDisplayPictureAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDisplayPictureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_GetPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GetPropertiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_ParseVcardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"ParseVcardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(winrt::Windows::Phone::PersonalInformation::ContactInformation::ParseVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_SetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"SetDisplayPictureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.SetDisplayPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_ToVcardAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"ToVcardAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToVcardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"ToVcardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::VCardFormat>(args, 0);

                return py::convert(self->obj.ToVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificPrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_GivenName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_GivenName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactInformation_put_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactInformation_get_DisplayPicture(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactInformation", L"DisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInformation[] = {
        { "get_display_picture_async", reinterpret_cast<PyCFunction>(ContactInformation_GetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(ContactInformation_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "parse_vcard_async", reinterpret_cast<PyCFunction>(ContactInformation_ParseVcardAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "set_display_picture_async", reinterpret_cast<PyCFunction>(ContactInformation_SetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "to_vcard_async", reinterpret_cast<PyCFunction>(ContactInformation_ToVcardAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactInformation[] = {
        { "honorific_suffix", reinterpret_cast<getter>(ContactInformation_get_HonorificSuffix), reinterpret_cast<setter>(ContactInformation_put_HonorificSuffix), nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(ContactInformation_get_HonorificPrefix), reinterpret_cast<setter>(ContactInformation_put_HonorificPrefix), nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(ContactInformation_get_GivenName), reinterpret_cast<setter>(ContactInformation_put_GivenName), nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(ContactInformation_get_FamilyName), reinterpret_cast<setter>(ContactInformation_put_FamilyName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ContactInformation_get_DisplayName), reinterpret_cast<setter>(ContactInformation_put_DisplayName), nullptr, nullptr },
        { "display_picture", reinterpret_cast<getter>(ContactInformation_get_DisplayPicture), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactInformation) },
        { },
    };

    static PyType_Spec type_spec_ContactInformation =
    {
        "_winsdk_Windows_Phone_PersonalInformation.ContactInformation",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInformation
    };

    // ----- ContactQueryOptions class --------------------
    static constexpr const char* const type_name_ContactQueryOptions = "ContactQueryOptions";

    static PyObject* _new_ContactQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Phone::PersonalInformation::ContactQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactQueryOptions(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactQueryOptions_get_OrderBy(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactQueryOptions", L"OrderBy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrderBy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_OrderBy(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactQueryOptions", L"OrderBy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactQueryResultOrdering>(arg);

            self->obj.OrderBy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredFields(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactQueryOptions", L"DesiredFields"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryOptions[] = {
        { "_assign_array_", _assign_array_ContactQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryOptions[] = {
        { "order_by", reinterpret_cast<getter>(ContactQueryOptions_get_OrderBy), reinterpret_cast<setter>(ContactQueryOptions_put_OrderBy), nullptr, nullptr },
        { "desired_fields", reinterpret_cast<getter>(ContactQueryOptions_get_DesiredFields), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactQueryOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactQueryOptions) },
        { },
    };

    static PyType_Spec type_spec_ContactQueryOptions =
    {
        "_winsdk_Windows_Phone_PersonalInformation.ContactQueryOptions",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryOptions
    };

    // ----- ContactQueryResult class --------------------
    static constexpr const char* const type_name_ContactQueryResult = "ContactQueryResult";

    static PyObject* _new_ContactQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactQueryResult);
        return nullptr;
    }

    static void _dealloc_ContactQueryResult(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactQueryResult_GetContactCountAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetContactCountAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetContactCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactQueryResult_GetContactsAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetContactsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetContactsAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactQueryResult_GetCurrentQueryOptions(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactQueryResult", L"GetCurrentQueryOptions", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentQueryOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryResult[] = {
        { "get_contact_count_async", reinterpret_cast<PyCFunction>(ContactQueryResult_GetContactCountAsync), METH_VARARGS, nullptr },
        { "get_contacts_async", reinterpret_cast<PyCFunction>(ContactQueryResult_GetContactsAsync), METH_VARARGS, nullptr },
        { "get_current_query_options", reinterpret_cast<PyCFunction>(ContactQueryResult_GetCurrentQueryOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactQueryResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryResult[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactQueryResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactQueryResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactQueryResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactQueryResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactQueryResult) },
        { },
    };

    static PyType_Spec type_spec_ContactQueryResult =
    {
        "_winsdk_Windows_Phone_PersonalInformation.ContactQueryResult",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryResult
    };

    // ----- ContactStore class --------------------
    static constexpr const char* const type_name_ContactStore = "ContactStore";

    static PyObject* _new_ContactStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactStore);
        return nullptr;
    }

    static void _dealloc_ContactStore(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactStore_CreateContactQuery(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateContactQuery", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateContactQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateContactQuery", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.CreateContactQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_CreateMeContactAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateMeContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateMeContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_CreateOrOpenAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateOrOpenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::PersonalInformation::ContactStore::CreateOrOpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"CreateOrOpenAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStoreSystemAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStoreApplicationAccessMode>(args, 1);

                return py::convert(winrt::Windows::Phone::PersonalInformation::ContactStore::CreateOrOpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_DeleteAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"DeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_DeleteContactAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"DeleteContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactByIdAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"FindContactByIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactByIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactByRemoteIdAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"FindContactByRemoteIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactByRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetChangesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"GetChangesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetChangesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_LoadExtendedPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"LoadExtendedPropertiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.LoadExtendedPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_SaveExtendedPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"SaveExtendedPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);

                return py::convert(self->obj.SaveExtendedPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_RevisionNumber(py::wrapper::Windows::Phone::PersonalInformation::ContactStore* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.ContactStore", L"RevisionNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RevisionNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::ContactStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::ContactStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStore[] = {
        { "create_contact_query", reinterpret_cast<PyCFunction>(ContactStore_CreateContactQuery), METH_VARARGS, nullptr },
        { "create_me_contact_async", reinterpret_cast<PyCFunction>(ContactStore_CreateMeContactAsync), METH_VARARGS, nullptr },
        { "create_or_open_async", reinterpret_cast<PyCFunction>(ContactStore_CreateOrOpenAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(ContactStore_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_contact_async", reinterpret_cast<PyCFunction>(ContactStore_DeleteContactAsync), METH_VARARGS, nullptr },
        { "find_contact_by_id_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactByIdAsync), METH_VARARGS, nullptr },
        { "find_contact_by_remote_id_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_changes_async", reinterpret_cast<PyCFunction>(ContactStore_GetChangesAsync), METH_VARARGS, nullptr },
        { "load_extended_properties_async", reinterpret_cast<PyCFunction>(ContactStore_LoadExtendedPropertiesAsync), METH_VARARGS, nullptr },
        { "save_extended_properties_async", reinterpret_cast<PyCFunction>(ContactStore_SaveExtendedPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStore[] = {
        { "revision_number", reinterpret_cast<getter>(ContactStore_get_RevisionNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactStore) },
        { },
    };

    static PyType_Spec type_spec_ContactStore =
    {
        "_winsdk_Windows_Phone_PersonalInformation.ContactStore",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::ContactStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStore
    };

    // ----- KnownContactProperties class --------------------
    static constexpr const char* const type_name_KnownContactProperties = "KnownContactProperties";

    static PyObject* _new_KnownContactProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownContactProperties);
        return nullptr;
    }

    static PyObject* KnownContactProperties_get_AdditionalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AdditionalName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AdditionalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Address(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Address"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_AlternateMobileTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AlternateMobileTelephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AlternateMobileTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_AlternateTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AlternateTelephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AlternateTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_AlternateWorkTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"AlternateWorkTelephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::AlternateWorkTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Anniversary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Anniversary"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Anniversary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Birthdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Birthdate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Birthdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Children(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_CompanyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"CompanyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::CompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_CompanyTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"CompanyTelephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::CompanyTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_DisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Email(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Email"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Email());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_FamilyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_GivenName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_HomeFax(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"HomeFax"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::HomeFax());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_HonorificPrefix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_HonorificSuffix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_JobTitle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"JobTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::JobTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Manager(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Manager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Manager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_MobileTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"MobileTelephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::MobileTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Nickname(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Nickname"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Notes(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Notes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Notes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_OfficeLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"OfficeLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::OfficeLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_OtherAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"OtherAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::OtherAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_OtherEmail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"OtherEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::OtherEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_SignificantOther(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"SignificantOther"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::SignificantOther());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Telephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Telephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Telephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_Url(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"Url"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::Url());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkAddress(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkEmail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkEmail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkEmail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkFax(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkFax"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkFax());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_WorkTelephone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"WorkTelephone"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::WorkTelephone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_YomiCompanyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"YomiCompanyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::YomiCompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_YomiFamilyName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"YomiFamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::YomiFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactProperties_get_YomiGivenName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.KnownContactProperties", L"YomiGivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::PersonalInformation::KnownContactProperties::YomiGivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownContactProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownContactProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownContactProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownContactProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownContactProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownContactProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownContactProperties =
    {
        "_winsdk_Windows_Phone_PersonalInformation.KnownContactProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownContactProperties
    };

    static PyGetSetDef getset_KnownContactProperties_Meta[] = {
        { "additional_name", reinterpret_cast<getter>(KnownContactProperties_get_AdditionalName), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(KnownContactProperties_get_Address), nullptr, nullptr, nullptr },
        { "alternate_mobile_telephone", reinterpret_cast<getter>(KnownContactProperties_get_AlternateMobileTelephone), nullptr, nullptr, nullptr },
        { "alternate_telephone", reinterpret_cast<getter>(KnownContactProperties_get_AlternateTelephone), nullptr, nullptr, nullptr },
        { "alternate_work_telephone", reinterpret_cast<getter>(KnownContactProperties_get_AlternateWorkTelephone), nullptr, nullptr, nullptr },
        { "anniversary", reinterpret_cast<getter>(KnownContactProperties_get_Anniversary), nullptr, nullptr, nullptr },
        { "birthdate", reinterpret_cast<getter>(KnownContactProperties_get_Birthdate), nullptr, nullptr, nullptr },
        { "children", reinterpret_cast<getter>(KnownContactProperties_get_Children), nullptr, nullptr, nullptr },
        { "company_name", reinterpret_cast<getter>(KnownContactProperties_get_CompanyName), nullptr, nullptr, nullptr },
        { "company_telephone", reinterpret_cast<getter>(KnownContactProperties_get_CompanyTelephone), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(KnownContactProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "email", reinterpret_cast<getter>(KnownContactProperties_get_Email), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(KnownContactProperties_get_FamilyName), nullptr, nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(KnownContactProperties_get_GivenName), nullptr, nullptr, nullptr },
        { "home_fax", reinterpret_cast<getter>(KnownContactProperties_get_HomeFax), nullptr, nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(KnownContactProperties_get_HonorificPrefix), nullptr, nullptr, nullptr },
        { "honorific_suffix", reinterpret_cast<getter>(KnownContactProperties_get_HonorificSuffix), nullptr, nullptr, nullptr },
        { "job_title", reinterpret_cast<getter>(KnownContactProperties_get_JobTitle), nullptr, nullptr, nullptr },
        { "manager", reinterpret_cast<getter>(KnownContactProperties_get_Manager), nullptr, nullptr, nullptr },
        { "mobile_telephone", reinterpret_cast<getter>(KnownContactProperties_get_MobileTelephone), nullptr, nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(KnownContactProperties_get_Nickname), nullptr, nullptr, nullptr },
        { "notes", reinterpret_cast<getter>(KnownContactProperties_get_Notes), nullptr, nullptr, nullptr },
        { "office_location", reinterpret_cast<getter>(KnownContactProperties_get_OfficeLocation), nullptr, nullptr, nullptr },
        { "other_address", reinterpret_cast<getter>(KnownContactProperties_get_OtherAddress), nullptr, nullptr, nullptr },
        { "other_email", reinterpret_cast<getter>(KnownContactProperties_get_OtherEmail), nullptr, nullptr, nullptr },
        { "significant_other", reinterpret_cast<getter>(KnownContactProperties_get_SignificantOther), nullptr, nullptr, nullptr },
        { "telephone", reinterpret_cast<getter>(KnownContactProperties_get_Telephone), nullptr, nullptr, nullptr },
        { "url", reinterpret_cast<getter>(KnownContactProperties_get_Url), nullptr, nullptr, nullptr },
        { "work_address", reinterpret_cast<getter>(KnownContactProperties_get_WorkAddress), nullptr, nullptr, nullptr },
        { "work_email", reinterpret_cast<getter>(KnownContactProperties_get_WorkEmail), nullptr, nullptr, nullptr },
        { "work_fax", reinterpret_cast<getter>(KnownContactProperties_get_WorkFax), nullptr, nullptr, nullptr },
        { "work_telephone", reinterpret_cast<getter>(KnownContactProperties_get_WorkTelephone), nullptr, nullptr, nullptr },
        { "yomi_company_name", reinterpret_cast<getter>(KnownContactProperties_get_YomiCompanyName), nullptr, nullptr, nullptr },
        { "yomi_family_name", reinterpret_cast<getter>(KnownContactProperties_get_YomiFamilyName), nullptr, nullptr, nullptr },
        { "yomi_given_name", reinterpret_cast<getter>(KnownContactProperties_get_YomiGivenName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownContactProperties_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownContactProperties_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownContactProperties_Meta =
    {
        "_winsdk_Windows_Phone_PersonalInformation.KnownContactProperties_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownContactProperties_Meta
    };

    // ----- StoredContact class --------------------
    static constexpr const char* const type_name_StoredContact = "StoredContact";

    static PyObject* _new_StoredContact(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStore>(args, 0);

                winrt::Windows::Phone::PersonalInformation::StoredContact instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactStore>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::PersonalInformation::ContactInformation>(args, 1);

                winrt::Windows::Phone::PersonalInformation::StoredContact instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoredContact(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StoredContact_GetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GetDisplayPictureAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDisplayPictureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_GetExtendedPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GetExtendedPropertiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetExtendedPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_GetPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GetPropertiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_ReplaceExistingContactAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"ReplaceExistingContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReplaceExistingContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_SaveAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"SaveAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_SetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"SetDisplayPictureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.SetDisplayPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_ToVcardAsync(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"ToVcardAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToVcardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"ToVcardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::VCardFormat>(args, 0);

                return py::convert(self->obj.ToVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoredContact_get_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificPrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_GivenName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_GivenName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_DisplayPicture(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoredContact_get_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayPictureDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayPictureDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"DisplayPictureDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_RemoteId(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StoredContact_put_RemoteId(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StoredContact_get_Id(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoredContact_get_Store(py::wrapper::Windows::Phone::PersonalInformation::StoredContact* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.StoredContact", L"Store"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Store());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StoredContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::StoredContact>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StoredContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::StoredContact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoredContact[] = {
        { "get_display_picture_async", reinterpret_cast<PyCFunction>(StoredContact_GetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "get_extended_properties_async", reinterpret_cast<PyCFunction>(StoredContact_GetExtendedPropertiesAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(StoredContact_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "replace_existing_contact_async", reinterpret_cast<PyCFunction>(StoredContact_ReplaceExistingContactAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(StoredContact_SaveAsync), METH_VARARGS, nullptr },
        { "set_display_picture_async", reinterpret_cast<PyCFunction>(StoredContact_SetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "to_vcard_async", reinterpret_cast<PyCFunction>(StoredContact_ToVcardAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StoredContact, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoredContact), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoredContact[] = {
        { "honorific_suffix", reinterpret_cast<getter>(StoredContact_get_HonorificSuffix), reinterpret_cast<setter>(StoredContact_put_HonorificSuffix), nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(StoredContact_get_HonorificPrefix), reinterpret_cast<setter>(StoredContact_put_HonorificPrefix), nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(StoredContact_get_GivenName), reinterpret_cast<setter>(StoredContact_put_GivenName), nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(StoredContact_get_FamilyName), reinterpret_cast<setter>(StoredContact_put_FamilyName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StoredContact_get_DisplayName), reinterpret_cast<setter>(StoredContact_put_DisplayName), nullptr, nullptr },
        { "display_picture", reinterpret_cast<getter>(StoredContact_get_DisplayPicture), nullptr, nullptr, nullptr },
        { "display_picture_date", reinterpret_cast<getter>(StoredContact_get_DisplayPictureDate), reinterpret_cast<setter>(StoredContact_put_DisplayPictureDate), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(StoredContact_get_RemoteId), reinterpret_cast<setter>(StoredContact_put_RemoteId), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StoredContact_get_Id), nullptr, nullptr, nullptr },
        { "store", reinterpret_cast<getter>(StoredContact_get_Store), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoredContact[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StoredContact) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StoredContact) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StoredContact) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StoredContact) },
        { },
    };

    static PyType_Spec type_spec_StoredContact =
    {
        "_winsdk_Windows_Phone_PersonalInformation.StoredContact",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::StoredContact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoredContact
    };

    // ----- IContactInformation interface --------------------
    static constexpr const char* const type_name_IContactInformation = "IContactInformation";

    static PyObject* _new_IContactInformation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IContactInformation);
        return nullptr;
    }

    static void _dealloc_IContactInformation(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactInformation_GetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GetDisplayPictureAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDisplayPictureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_GetPropertiesAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GetPropertiesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_SetDisplayPictureAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"SetDisplayPictureAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.SetDisplayPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_ToVcardAsync(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"ToVcardAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToVcardAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"ToVcardAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::PersonalInformation::VCardFormat>(args, 0);

                return py::convert(self->obj.ToVcardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContactInformation_get_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_DisplayName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_DisplayPicture(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"DisplayPicture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactInformation_get_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_FamilyName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"FamilyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_GivenName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_GivenName(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"GivenName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.GivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificPrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_HonorificPrefix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificPrefix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificPrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContactInformation_get_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HonorificSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation_put_HonorificSuffix(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation", L"HonorificSuffix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::IContactInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::IContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInformation[] = {
        { "get_display_picture_async", reinterpret_cast<PyCFunction>(IContactInformation_GetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "get_properties_async", reinterpret_cast<PyCFunction>(IContactInformation_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "set_display_picture_async", reinterpret_cast<PyCFunction>(IContactInformation_SetDisplayPictureAsync), METH_VARARGS, nullptr },
        { "to_vcard_async", reinterpret_cast<PyCFunction>(IContactInformation_ToVcardAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContactInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactInformation[] = {
        { "display_name", reinterpret_cast<getter>(IContactInformation_get_DisplayName), reinterpret_cast<setter>(IContactInformation_put_DisplayName), nullptr, nullptr },
        { "display_picture", reinterpret_cast<getter>(IContactInformation_get_DisplayPicture), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(IContactInformation_get_FamilyName), reinterpret_cast<setter>(IContactInformation_put_FamilyName), nullptr, nullptr },
        { "given_name", reinterpret_cast<getter>(IContactInformation_get_GivenName), reinterpret_cast<setter>(IContactInformation_put_GivenName), nullptr, nullptr },
        { "honorific_prefix", reinterpret_cast<getter>(IContactInformation_get_HonorificPrefix), reinterpret_cast<setter>(IContactInformation_put_HonorificPrefix), nullptr, nullptr },
        { "honorific_suffix", reinterpret_cast<getter>(IContactInformation_get_HonorificSuffix), reinterpret_cast<setter>(IContactInformation_put_HonorificSuffix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactInformation) },
        { },
    };

    static PyType_Spec type_spec_IContactInformation =
    {
        "_winsdk_Windows_Phone_PersonalInformation.IContactInformation",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInformation
    };

    // ----- IContactInformation2 interface --------------------
    static constexpr const char* const type_name_IContactInformation2 = "IContactInformation2";

    static PyObject* _new_IContactInformation2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IContactInformation2);
        return nullptr;
    }

    static void _dealloc_IContactInformation2(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactInformation2_get_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation2", L"DisplayPictureDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayPictureDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContactInformation2_put_DisplayPictureDate(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.PersonalInformation.IContactInformation2", L"DisplayPictureDate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IContactInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::PersonalInformation::IContactInformation2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContactInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::PersonalInformation::IContactInformation2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInformation2[] = {
        { "_assign_array_", _assign_array_IContactInformation2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactInformation2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactInformation2[] = {
        { "display_picture_date", reinterpret_cast<getter>(IContactInformation2_get_DisplayPictureDate), reinterpret_cast<setter>(IContactInformation2_put_DisplayPictureDate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactInformation2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContactInformation2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContactInformation2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContactInformation2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContactInformation2) },
        { },
    };

    static PyType_Spec type_spec_IContactInformation2 =
    {
        "_winsdk_Windows_Phone_PersonalInformation.IContactInformation2",
        sizeof(py::wrapper::Windows::Phone::PersonalInformation::IContactInformation2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInformation2
    };

    // ----- Windows.Phone.PersonalInformation Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Phone::PersonalInformation");

    static PyMethodDef module_methods[] = {
        {"_register_ContactChangeType", register_ContactChangeType, METH_O, "registers type"},
        {"_register_ContactQueryResultOrdering", register_ContactQueryResultOrdering, METH_O, "registers type"},
        {"_register_ContactStoreApplicationAccessMode", register_ContactStoreApplicationAccessMode, METH_O, "registers type"},
        {"_register_ContactStoreSystemAccessMode", register_ContactStoreSystemAccessMode, METH_O, "registers type"},
        {"_register_VCardFormat", register_VCardFormat, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ContactChangeType);
        Py_VISIT(state->type_ContactQueryResultOrdering);
        Py_VISIT(state->type_ContactStoreApplicationAccessMode);
        Py_VISIT(state->type_ContactStoreSystemAccessMode);
        Py_VISIT(state->type_VCardFormat);
        Py_VISIT(state->type_ContactAddress);
        Py_VISIT(state->type_ContactChangeRecord);
        Py_VISIT(state->type_ContactInformation);
        Py_VISIT(state->type_ContactQueryOptions);
        Py_VISIT(state->type_ContactQueryResult);
        Py_VISIT(state->type_ContactStore);
        Py_VISIT(state->type_KnownContactProperties);
        Py_VISIT(state->type_StoredContact);
        Py_VISIT(state->type_IContactInformation);
        Py_VISIT(state->type_IContactInformation2);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ContactChangeType);
        Py_CLEAR(state->type_ContactQueryResultOrdering);
        Py_CLEAR(state->type_ContactStoreApplicationAccessMode);
        Py_CLEAR(state->type_ContactStoreSystemAccessMode);
        Py_CLEAR(state->type_VCardFormat);
        Py_CLEAR(state->type_ContactAddress);
        Py_CLEAR(state->type_ContactChangeRecord);
        Py_CLEAR(state->type_ContactInformation);
        Py_CLEAR(state->type_ContactQueryOptions);
        Py_CLEAR(state->type_ContactQueryResult);
        Py_CLEAR(state->type_ContactStore);
        Py_CLEAR(state->type_KnownContactProperties);
        Py_CLEAR(state->type_StoredContact);
        Py_CLEAR(state->type_IContactInformation);
        Py_CLEAR(state->type_IContactInformation2);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Phone_PersonalInformation",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Phone::PersonalInformation

PyMODINIT_FUNC PyInit__winsdk_Windows_Phone_PersonalInformation(void) noexcept
{
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ContactAddress = py::register_python_type(module.get(), type_name_ContactAddress, &type_spec_ContactAddress, bases.get(), nullptr);
    if (!state->type_ContactAddress)
    {
        return nullptr;
    }

    state->type_ContactChangeRecord = py::register_python_type(module.get(), type_name_ContactChangeRecord, &type_spec_ContactChangeRecord, bases.get(), nullptr);
    if (!state->type_ContactChangeRecord)
    {
        return nullptr;
    }

    state->type_ContactInformation = py::register_python_type(module.get(), type_name_ContactInformation, &type_spec_ContactInformation, bases.get(), nullptr);
    if (!state->type_ContactInformation)
    {
        return nullptr;
    }

    state->type_ContactQueryOptions = py::register_python_type(module.get(), type_name_ContactQueryOptions, &type_spec_ContactQueryOptions, bases.get(), nullptr);
    if (!state->type_ContactQueryOptions)
    {
        return nullptr;
    }

    state->type_ContactQueryResult = py::register_python_type(module.get(), type_name_ContactQueryResult, &type_spec_ContactQueryResult, bases.get(), nullptr);
    if (!state->type_ContactQueryResult)
    {
        return nullptr;
    }

    state->type_ContactStore = py::register_python_type(module.get(), type_name_ContactStore, &type_spec_ContactStore, bases.get(), nullptr);
    if (!state->type_ContactStore)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownContactProperties_Meta{PyType_FromSpec(&type_spec_KnownContactProperties_Meta)};
    if (!type_KnownContactProperties_Meta)
    {
        return nullptr;
    }

    state->type_KnownContactProperties = py::register_python_type(module.get(), type_name_KnownContactProperties, &type_spec_KnownContactProperties, nullptr, reinterpret_cast<PyTypeObject*>(type_KnownContactProperties_Meta.get()));
    if (!state->type_KnownContactProperties)
    {
        return nullptr;
    }

    state->type_StoredContact = py::register_python_type(module.get(), type_name_StoredContact, &type_spec_StoredContact, bases.get(), nullptr);
    if (!state->type_StoredContact)
    {
        return nullptr;
    }

    state->type_IContactInformation = py::register_python_type(module.get(), type_name_IContactInformation, &type_spec_IContactInformation, bases.get(), nullptr);
    if (!state->type_IContactInformation)
    {
        return nullptr;
    }

    state->type_IContactInformation2 = py::register_python_type(module.get(), type_name_IContactInformation2, &type_spec_IContactInformation2, bases.get(), nullptr);
    if (!state->type_IContactInformation2)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Phone::PersonalInformation::ContactChangeType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactChangeType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactChangeType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::PersonalInformation::ContactQueryResultOrdering>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactQueryResultOrdering;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactQueryResultOrdering is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::PersonalInformation::ContactStoreApplicationAccessMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactStoreApplicationAccessMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactStoreApplicationAccessMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::PersonalInformation::ContactStoreSystemAccessMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactStoreSystemAccessMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactStoreSystemAccessMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Phone::PersonalInformation::VCardFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VCardFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::VCardFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::ContactAddress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactAddress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactAddress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::ContactChangeRecord>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactChangeRecord;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactChangeRecord is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::ContactInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::ContactQueryOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactQueryOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactQueryOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::ContactQueryResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactQueryResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactQueryResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::ContactStore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactStore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::ContactStore is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::KnownContactProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownContactProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::KnownContactProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::StoredContact>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StoredContact;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::StoredContact is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::IContactInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::IContactInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Phone::PersonalInformation::IContactInformation2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Phone::PersonalInformation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Phone::PersonalInformation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactInformation2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Phone::PersonalInformation::IContactInformation2 is not registered");
        return nullptr;
    }

    return python_type;
}
