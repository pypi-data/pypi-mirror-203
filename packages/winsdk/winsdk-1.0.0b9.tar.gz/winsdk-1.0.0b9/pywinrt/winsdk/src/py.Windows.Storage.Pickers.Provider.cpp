// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Storage.Pickers.Provider.h"


namespace py::cpp::Windows::Storage::Pickers::Provider
{
    struct module_state
    {
        PyObject* type_AddFileResult;
        PyObject* type_FileSelectionMode;
        PyObject* type_SetFileNameResult;
        PyTypeObject* type_FileOpenPickerUI;
        PyTypeObject* type_FileRemovedEventArgs;
        PyTypeObject* type_FileSavePickerUI;
        PyTypeObject* type_PickerClosingDeferral;
        PyTypeObject* type_PickerClosingEventArgs;
        PyTypeObject* type_PickerClosingOperation;
        PyTypeObject* type_TargetFileRequest;
        PyTypeObject* type_TargetFileRequestDeferral;
        PyTypeObject* type_TargetFileRequestedEventArgs;
    };

    static PyObject* register_AddFileResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AddFileResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AddFileResult = type;
        Py_INCREF(state->type_AddFileResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_FileSelectionMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FileSelectionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FileSelectionMode = type;
        Py_INCREF(state->type_FileSelectionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_SetFileNameResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SetFileNameResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SetFileNameResult = type;
        Py_INCREF(state->type_SetFileNameResult);


        Py_RETURN_NONE;
    }

    // ----- FileOpenPickerUI class --------------------
    static constexpr const char* const type_name_FileOpenPickerUI = "FileOpenPickerUI";

    static PyObject* _new_FileOpenPickerUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileOpenPickerUI);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerUI(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerUI_AddFile(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"AddFile", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.AddFile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_CanAddFile(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"CanAddFile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CanAddFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_ContainsFile(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"ContainsFile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ContainsFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_RemoveFile(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"RemoveFile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_get_Title(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileOpenPickerUI_put_Title(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileOpenPickerUI_get_AllowedFileTypes(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"AllowedFileTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedFileTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_get_SelectionMode(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"SelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_get_SettingsIdentifier(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"SettingsIdentifier"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SettingsIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_add_Closing(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI, winrt::Windows::Storage::Pickers::Provider::PickerClosingEventArgs>>(arg);

            return py::convert(self->obj.Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_remove_Closing(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"Closing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_add_FileRemoved(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"FileRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI, winrt::Windows::Storage::Pickers::Provider::FileRemovedEventArgs>>(arg);

            return py::convert(self->obj.FileRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerUI_remove_FileRemoved(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileOpenPickerUI", L"FileRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileOpenPickerUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileOpenPickerUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerUI[] = {
        { "add_file", reinterpret_cast<PyCFunction>(FileOpenPickerUI_AddFile), METH_VARARGS, nullptr },
        { "can_add_file", reinterpret_cast<PyCFunction>(FileOpenPickerUI_CanAddFile), METH_VARARGS, nullptr },
        { "contains_file", reinterpret_cast<PyCFunction>(FileOpenPickerUI_ContainsFile), METH_VARARGS, nullptr },
        { "remove_file", reinterpret_cast<PyCFunction>(FileOpenPickerUI_RemoveFile), METH_VARARGS, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(FileOpenPickerUI_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(FileOpenPickerUI_remove_Closing), METH_O, nullptr },
        { "add_file_removed", reinterpret_cast<PyCFunction>(FileOpenPickerUI_add_FileRemoved), METH_O, nullptr },
        { "remove_file_removed", reinterpret_cast<PyCFunction>(FileOpenPickerUI_remove_FileRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_FileOpenPickerUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileOpenPickerUI[] = {
        { "title", reinterpret_cast<getter>(FileOpenPickerUI_get_Title), reinterpret_cast<setter>(FileOpenPickerUI_put_Title), nullptr, nullptr },
        { "allowed_file_types", reinterpret_cast<getter>(FileOpenPickerUI_get_AllowedFileTypes), nullptr, nullptr, nullptr },
        { "selection_mode", reinterpret_cast<getter>(FileOpenPickerUI_get_SelectionMode), nullptr, nullptr, nullptr },
        { "settings_identifier", reinterpret_cast<getter>(FileOpenPickerUI_get_SettingsIdentifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileOpenPickerUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileOpenPickerUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileOpenPickerUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileOpenPickerUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileOpenPickerUI) },
        { },
    };

    static PyType_Spec type_spec_FileOpenPickerUI =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.FileOpenPickerUI",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::FileOpenPickerUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerUI
    };

    // ----- FileRemovedEventArgs class --------------------
    static constexpr const char* const type_name_FileRemovedEventArgs = "FileRemovedEventArgs";

    static PyObject* _new_FileRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileRemovedEventArgs(py::wrapper::Windows::Storage::Pickers::Provider::FileRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileRemovedEventArgs_get_Id(py::wrapper::Windows::Storage::Pickers::Provider::FileRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileRemovedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::FileRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::FileRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_FileRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileRemovedEventArgs[] = {
        { "id", reinterpret_cast<getter>(FileRemovedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FileRemovedEventArgs =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.FileRemovedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::FileRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileRemovedEventArgs
    };

    // ----- FileSavePickerUI class --------------------
    static constexpr const char* const type_name_FileSavePickerUI = "FileSavePickerUI";

    static PyObject* _new_FileSavePickerUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileSavePickerUI);
        return nullptr;
    }

    static void _dealloc_FileSavePickerUI(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerUI_TrySetFileName(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"TrySetFileName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TrySetFileName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_get_Title(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileSavePickerUI_put_Title(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileSavePickerUI_get_AllowedFileTypes(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"AllowedFileTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedFileTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_get_FileName(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"FileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_get_SettingsIdentifier(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"SettingsIdentifier"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SettingsIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_add_FileNameChanged(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"FileNameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FileNameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_remove_FileNameChanged(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"FileNameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileNameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_add_TargetFileRequested(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"TargetFileRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI, winrt::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs>>(arg);

            return py::convert(self->obj.TargetFileRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerUI_remove_TargetFileRequested(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Pickers.Provider.FileSavePickerUI", L"TargetFileRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetFileRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileSavePickerUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileSavePickerUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerUI[] = {
        { "try_set_file_name", reinterpret_cast<PyCFunction>(FileSavePickerUI_TrySetFileName), METH_VARARGS, nullptr },
        { "add_file_name_changed", reinterpret_cast<PyCFunction>(FileSavePickerUI_add_FileNameChanged), METH_O, nullptr },
        { "remove_file_name_changed", reinterpret_cast<PyCFunction>(FileSavePickerUI_remove_FileNameChanged), METH_O, nullptr },
        { "add_target_file_requested", reinterpret_cast<PyCFunction>(FileSavePickerUI_add_TargetFileRequested), METH_O, nullptr },
        { "remove_target_file_requested", reinterpret_cast<PyCFunction>(FileSavePickerUI_remove_TargetFileRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_FileSavePickerUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileSavePickerUI[] = {
        { "title", reinterpret_cast<getter>(FileSavePickerUI_get_Title), reinterpret_cast<setter>(FileSavePickerUI_put_Title), nullptr, nullptr },
        { "allowed_file_types", reinterpret_cast<getter>(FileSavePickerUI_get_AllowedFileTypes), nullptr, nullptr, nullptr },
        { "file_name", reinterpret_cast<getter>(FileSavePickerUI_get_FileName), nullptr, nullptr, nullptr },
        { "settings_identifier", reinterpret_cast<getter>(FileSavePickerUI_get_SettingsIdentifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileSavePickerUI[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileSavePickerUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileSavePickerUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileSavePickerUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileSavePickerUI) },
        { },
    };

    static PyType_Spec type_spec_FileSavePickerUI =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.FileSavePickerUI",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::FileSavePickerUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerUI
    };

    // ----- PickerClosingDeferral class --------------------
    static constexpr const char* const type_name_PickerClosingDeferral = "PickerClosingDeferral";

    static PyObject* _new_PickerClosingDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PickerClosingDeferral);
        return nullptr;
    }

    static void _dealloc_PickerClosingDeferral(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerClosingDeferral_Complete(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.PickerClosingDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerClosingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::PickerClosingDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerClosingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::PickerClosingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerClosingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(PickerClosingDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PickerClosingDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerClosingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerClosingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerClosingDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerClosingDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerClosingDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerClosingDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerClosingDeferral) },
        { },
    };

    static PyType_Spec type_spec_PickerClosingDeferral =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.PickerClosingDeferral",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerClosingDeferral
    };

    // ----- PickerClosingEventArgs class --------------------
    static constexpr const char* const type_name_PickerClosingEventArgs = "PickerClosingEventArgs";

    static PyObject* _new_PickerClosingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PickerClosingEventArgs);
        return nullptr;
    }

    static void _dealloc_PickerClosingEventArgs(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerClosingEventArgs_get_ClosingOperation(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.PickerClosingEventArgs", L"ClosingOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClosingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerClosingEventArgs_get_IsCanceled(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.PickerClosingEventArgs", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::PickerClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::PickerClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerClosingEventArgs[] = {
        { "_assign_array_", _assign_array_PickerClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerClosingEventArgs[] = {
        { "closing_operation", reinterpret_cast<getter>(PickerClosingEventArgs_get_ClosingOperation), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(PickerClosingEventArgs_get_IsCanceled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PickerClosingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerClosingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PickerClosingEventArgs =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.PickerClosingEventArgs",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerClosingEventArgs
    };

    // ----- PickerClosingOperation class --------------------
    static constexpr const char* const type_name_PickerClosingOperation = "PickerClosingOperation";

    static PyObject* _new_PickerClosingOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PickerClosingOperation);
        return nullptr;
    }

    static void _dealloc_PickerClosingOperation(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerClosingOperation_GetDeferral(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.PickerClosingOperation", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerClosingOperation_get_Deadline(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.PickerClosingOperation", L"Deadline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerClosingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::PickerClosingOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerClosingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::PickerClosingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerClosingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PickerClosingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PickerClosingOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerClosingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerClosingOperation[] = {
        { "deadline", reinterpret_cast<getter>(PickerClosingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PickerClosingOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerClosingOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerClosingOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerClosingOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerClosingOperation) },
        { },
    };

    static PyType_Spec type_spec_PickerClosingOperation =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.PickerClosingOperation",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::PickerClosingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerClosingOperation
    };

    // ----- TargetFileRequest class --------------------
    static constexpr const char* const type_name_TargetFileRequest = "TargetFileRequest";

    static PyObject* _new_TargetFileRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TargetFileRequest);
        return nullptr;
    }

    static void _dealloc_TargetFileRequest(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TargetFileRequest_GetDeferral(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.TargetFileRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TargetFileRequest_get_TargetFile(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.TargetFileRequest", L"TargetFile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TargetFileRequest_put_TargetFile(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.TargetFileRequest", L"TargetFile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(arg);

            self->obj.TargetFile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TargetFileRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::TargetFileRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TargetFileRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::TargetFileRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TargetFileRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(TargetFileRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TargetFileRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TargetFileRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TargetFileRequest[] = {
        { "target_file", reinterpret_cast<getter>(TargetFileRequest_get_TargetFile), reinterpret_cast<setter>(TargetFileRequest_put_TargetFile), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TargetFileRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TargetFileRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TargetFileRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TargetFileRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TargetFileRequest) },
        { },
    };

    static PyType_Spec type_spec_TargetFileRequest =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.TargetFileRequest",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TargetFileRequest
    };

    // ----- TargetFileRequestDeferral class --------------------
    static constexpr const char* const type_name_TargetFileRequestDeferral = "TargetFileRequestDeferral";

    static PyObject* _new_TargetFileRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TargetFileRequestDeferral);
        return nullptr;
    }

    static void _dealloc_TargetFileRequestDeferral(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TargetFileRequestDeferral_Complete(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Pickers.Provider.TargetFileRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_TargetFileRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TargetFileRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TargetFileRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(TargetFileRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TargetFileRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TargetFileRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TargetFileRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_TargetFileRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TargetFileRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TargetFileRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TargetFileRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TargetFileRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_TargetFileRequestDeferral =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.TargetFileRequestDeferral",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TargetFileRequestDeferral
    };

    // ----- TargetFileRequestedEventArgs class --------------------
    static constexpr const char* const type_name_TargetFileRequestedEventArgs = "TargetFileRequestedEventArgs";

    static PyObject* _new_TargetFileRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TargetFileRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_TargetFileRequestedEventArgs(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TargetFileRequestedEventArgs_get_Request(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TargetFileRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TargetFileRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TargetFileRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_TargetFileRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TargetFileRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TargetFileRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(TargetFileRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TargetFileRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TargetFileRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TargetFileRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TargetFileRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TargetFileRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_TargetFileRequestedEventArgs =
    {
        "_winsdk_Windows_Storage_Pickers_Provider.TargetFileRequestedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TargetFileRequestedEventArgs
    };

    // ----- Windows.Storage.Pickers.Provider Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Storage::Pickers::Provider");

    static PyMethodDef module_methods[] = {
        {"_register_AddFileResult", register_AddFileResult, METH_O, "registers type"},
        {"_register_FileSelectionMode", register_FileSelectionMode, METH_O, "registers type"},
        {"_register_SetFileNameResult", register_SetFileNameResult, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AddFileResult);
        Py_VISIT(state->type_FileSelectionMode);
        Py_VISIT(state->type_SetFileNameResult);
        Py_VISIT(state->type_FileOpenPickerUI);
        Py_VISIT(state->type_FileRemovedEventArgs);
        Py_VISIT(state->type_FileSavePickerUI);
        Py_VISIT(state->type_PickerClosingDeferral);
        Py_VISIT(state->type_PickerClosingEventArgs);
        Py_VISIT(state->type_PickerClosingOperation);
        Py_VISIT(state->type_TargetFileRequest);
        Py_VISIT(state->type_TargetFileRequestDeferral);
        Py_VISIT(state->type_TargetFileRequestedEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AddFileResult);
        Py_CLEAR(state->type_FileSelectionMode);
        Py_CLEAR(state->type_SetFileNameResult);
        Py_CLEAR(state->type_FileOpenPickerUI);
        Py_CLEAR(state->type_FileRemovedEventArgs);
        Py_CLEAR(state->type_FileSavePickerUI);
        Py_CLEAR(state->type_PickerClosingDeferral);
        Py_CLEAR(state->type_PickerClosingEventArgs);
        Py_CLEAR(state->type_PickerClosingOperation);
        Py_CLEAR(state->type_TargetFileRequest);
        Py_CLEAR(state->type_TargetFileRequestDeferral);
        Py_CLEAR(state->type_TargetFileRequestedEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Storage_Pickers_Provider",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Storage::Pickers::Provider

PyMODINIT_FUNC PyInit__winsdk_Windows_Storage_Pickers_Provider(void) noexcept
{
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_FileOpenPickerUI = py::register_python_type(module.get(), type_name_FileOpenPickerUI, &type_spec_FileOpenPickerUI, bases.get(), nullptr);
    if (!state->type_FileOpenPickerUI)
    {
        return nullptr;
    }

    state->type_FileRemovedEventArgs = py::register_python_type(module.get(), type_name_FileRemovedEventArgs, &type_spec_FileRemovedEventArgs, bases.get(), nullptr);
    if (!state->type_FileRemovedEventArgs)
    {
        return nullptr;
    }

    state->type_FileSavePickerUI = py::register_python_type(module.get(), type_name_FileSavePickerUI, &type_spec_FileSavePickerUI, bases.get(), nullptr);
    if (!state->type_FileSavePickerUI)
    {
        return nullptr;
    }

    state->type_PickerClosingDeferral = py::register_python_type(module.get(), type_name_PickerClosingDeferral, &type_spec_PickerClosingDeferral, bases.get(), nullptr);
    if (!state->type_PickerClosingDeferral)
    {
        return nullptr;
    }

    state->type_PickerClosingEventArgs = py::register_python_type(module.get(), type_name_PickerClosingEventArgs, &type_spec_PickerClosingEventArgs, bases.get(), nullptr);
    if (!state->type_PickerClosingEventArgs)
    {
        return nullptr;
    }

    state->type_PickerClosingOperation = py::register_python_type(module.get(), type_name_PickerClosingOperation, &type_spec_PickerClosingOperation, bases.get(), nullptr);
    if (!state->type_PickerClosingOperation)
    {
        return nullptr;
    }

    state->type_TargetFileRequest = py::register_python_type(module.get(), type_name_TargetFileRequest, &type_spec_TargetFileRequest, bases.get(), nullptr);
    if (!state->type_TargetFileRequest)
    {
        return nullptr;
    }

    state->type_TargetFileRequestDeferral = py::register_python_type(module.get(), type_name_TargetFileRequestDeferral, &type_spec_TargetFileRequestDeferral, bases.get(), nullptr);
    if (!state->type_TargetFileRequestDeferral)
    {
        return nullptr;
    }

    state->type_TargetFileRequestedEventArgs = py::register_python_type(module.get(), type_name_TargetFileRequestedEventArgs, &type_spec_TargetFileRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_TargetFileRequestedEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Storage::Pickers::Provider::AddFileResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AddFileResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::AddFileResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Pickers::Provider::FileSelectionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileSelectionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::FileSelectionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Pickers::Provider::SetFileNameResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SetFileNameResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::SetFileNameResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileOpenPickerUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::FileOpenPickerUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::FileRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::FileRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileSavePickerUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::FileSavePickerUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::PickerClosingDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PickerClosingDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::PickerClosingDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::PickerClosingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PickerClosingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::PickerClosingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::PickerClosingOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PickerClosingOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::PickerClosingOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::TargetFileRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TargetFileRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::TargetFileRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TargetFileRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::TargetFileRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Pickers::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Pickers::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TargetFileRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Pickers::Provider::TargetFileRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
