// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Media.Miracast.h"


namespace py::cpp::Windows::Media::Miracast
{
    struct module_state
    {
        PyObject* type_MiracastReceiverApplySettingsStatus;
        PyObject* type_MiracastReceiverAuthorizationMethod;
        PyObject* type_MiracastReceiverDisconnectReason;
        PyObject* type_MiracastReceiverGameControllerDeviceUsageMode;
        PyObject* type_MiracastReceiverListeningStatus;
        PyObject* type_MiracastReceiverSessionStartStatus;
        PyObject* type_MiracastReceiverWiFiStatus;
        PyObject* type_MiracastTransmitterAuthorizationStatus;
        PyTypeObject* type_MiracastReceiver;
        PyTypeObject* type_MiracastReceiverApplySettingsResult;
        PyTypeObject* type_MiracastReceiverConnection;
        PyTypeObject* type_MiracastReceiverConnectionCreatedEventArgs;
        PyTypeObject* type_MiracastReceiverCursorImageChannel;
        PyTypeObject* type_MiracastReceiverCursorImageChannelSettings;
        PyTypeObject* type_MiracastReceiverDisconnectedEventArgs;
        PyTypeObject* type_MiracastReceiverGameControllerDevice;
        PyTypeObject* type_MiracastReceiverInputDevices;
        PyTypeObject* type_MiracastReceiverKeyboardDevice;
        PyTypeObject* type_MiracastReceiverMediaSourceCreatedEventArgs;
        PyTypeObject* type_MiracastReceiverSession;
        PyTypeObject* type_MiracastReceiverSessionStartResult;
        PyTypeObject* type_MiracastReceiverSettings;
        PyTypeObject* type_MiracastReceiverStatus;
        PyTypeObject* type_MiracastReceiverStreamControl;
        PyTypeObject* type_MiracastReceiverVideoStreamSettings;
        PyTypeObject* type_MiracastTransmitter;
    };

    static PyObject* register_MiracastReceiverApplySettingsStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverApplySettingsStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverApplySettingsStatus = type;
        Py_INCREF(state->type_MiracastReceiverApplySettingsStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastReceiverAuthorizationMethod(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverAuthorizationMethod)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverAuthorizationMethod = type;
        Py_INCREF(state->type_MiracastReceiverAuthorizationMethod);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastReceiverDisconnectReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverDisconnectReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverDisconnectReason = type;
        Py_INCREF(state->type_MiracastReceiverDisconnectReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastReceiverGameControllerDeviceUsageMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverGameControllerDeviceUsageMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverGameControllerDeviceUsageMode = type;
        Py_INCREF(state->type_MiracastReceiverGameControllerDeviceUsageMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastReceiverListeningStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverListeningStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverListeningStatus = type;
        Py_INCREF(state->type_MiracastReceiverListeningStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastReceiverSessionStartStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverSessionStartStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverSessionStartStatus = type;
        Py_INCREF(state->type_MiracastReceiverSessionStartStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastReceiverWiFiStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastReceiverWiFiStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastReceiverWiFiStatus = type;
        Py_INCREF(state->type_MiracastReceiverWiFiStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MiracastTransmitterAuthorizationStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MiracastTransmitterAuthorizationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MiracastTransmitterAuthorizationStatus = type;
        Py_INCREF(state->type_MiracastTransmitterAuthorizationStatus);


        Py_RETURN_NONE;
    }

    // ----- MiracastReceiver class --------------------
    static constexpr const char* const type_name_MiracastReceiver = "MiracastReceiver";

    static PyObject* _new_MiracastReceiver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Miracast::MiracastReceiver instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MiracastReceiver(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiver_ClearKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"ClearKnownTransmitters", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClearKnownTransmitters();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_CreateSession(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"CreateSession", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                return py::convert(self->obj.CreateSession(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_CreateSessionAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"CreateSessionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::CoreApplicationView>(args, 0);

                return py::convert(self->obj.CreateSessionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_DisconnectAllAndApplySettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"DisconnectAllAndApplySettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverSettings>(args, 0);

                return py::convert(self->obj.DisconnectAllAndApplySettings(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_DisconnectAllAndApplySettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"DisconnectAllAndApplySettingsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverSettings>(args, 0);

                return py::convert(self->obj.DisconnectAllAndApplySettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetCurrentSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetCurrentSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetCurrentSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetCurrentSettingsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCurrentSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetDefaultSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetDefaultSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDefaultSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_GetStatusAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"GetStatusAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_RemoveKnownTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiver", L"RemoveKnownTransmitter", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastTransmitter>(args, 0);

                self->obj.RemoveKnownTransmitter(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_add_StatusChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiver", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiver_remove_StatusChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiver* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiver", L"StatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiver[] = {
        { "clear_known_transmitters", reinterpret_cast<PyCFunction>(MiracastReceiver_ClearKnownTransmitters), METH_VARARGS, nullptr },
        { "create_session", reinterpret_cast<PyCFunction>(MiracastReceiver_CreateSession), METH_VARARGS, nullptr },
        { "create_session_async", reinterpret_cast<PyCFunction>(MiracastReceiver_CreateSessionAsync), METH_VARARGS, nullptr },
        { "disconnect_all_and_apply_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_DisconnectAllAndApplySettings), METH_VARARGS, nullptr },
        { "disconnect_all_and_apply_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiver_DisconnectAllAndApplySettingsAsync), METH_VARARGS, nullptr },
        { "get_current_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_GetCurrentSettings), METH_VARARGS, nullptr },
        { "get_current_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiver_GetCurrentSettingsAsync), METH_VARARGS, nullptr },
        { "get_default_settings", reinterpret_cast<PyCFunction>(MiracastReceiver_GetDefaultSettings), METH_VARARGS, nullptr },
        { "get_status", reinterpret_cast<PyCFunction>(MiracastReceiver_GetStatus), METH_VARARGS, nullptr },
        { "get_status_async", reinterpret_cast<PyCFunction>(MiracastReceiver_GetStatusAsync), METH_VARARGS, nullptr },
        { "remove_known_transmitter", reinterpret_cast<PyCFunction>(MiracastReceiver_RemoveKnownTransmitter), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(MiracastReceiver_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(MiracastReceiver_remove_StatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiver), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiver[] = {
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiver[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiver) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiver =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiver",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiver
    };

    // ----- MiracastReceiverApplySettingsResult class --------------------
    static constexpr const char* const type_name_MiracastReceiverApplySettingsResult = "MiracastReceiverApplySettingsResult";

    static PyObject* _new_MiracastReceiverApplySettingsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverApplySettingsResult);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverApplySettingsResult(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverApplySettingsResult_get_ExtendedError(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverApplySettingsResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverApplySettingsResult_get_Status(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverApplySettingsResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverApplySettingsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverApplySettingsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverApplySettingsResult[] = {
        { "_assign_array_", _assign_array_MiracastReceiverApplySettingsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverApplySettingsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverApplySettingsResult[] = {
        { "extended_error", reinterpret_cast<getter>(MiracastReceiverApplySettingsResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MiracastReceiverApplySettingsResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverApplySettingsResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverApplySettingsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverApplySettingsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverApplySettingsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverApplySettingsResult) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverApplySettingsResult =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverApplySettingsResult",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverApplySettingsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverApplySettingsResult
    };

    // ----- MiracastReceiverConnection class --------------------
    static constexpr const char* const type_name_MiracastReceiverConnection = "MiracastReceiverConnection";

    static PyObject* _new_MiracastReceiverConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverConnection);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverConnection_Close(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Disconnect(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Disconnect", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>(args, 0);

                self->obj.Disconnect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Disconnect", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Disconnect(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Pause(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_PauseAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"PauseAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.PauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_Resume(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_ResumeAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"ResumeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_CursorImageChannel(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"CursorImageChannel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CursorImageChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_InputDevices(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"InputDevices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_StreamControl(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"StreamControl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreamControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnection_get_Transmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnection", L"Transmitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transmitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MiracastReceiverConnection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Close), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Disconnect), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Pause), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_Resume), METH_VARARGS, nullptr },
        { "resume_async", reinterpret_cast<PyCFunction>(MiracastReceiverConnection_ResumeAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MiracastReceiverConnection), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MiracastReceiverConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverConnection[] = {
        { "cursor_image_channel", reinterpret_cast<getter>(MiracastReceiverConnection_get_CursorImageChannel), nullptr, nullptr, nullptr },
        { "input_devices", reinterpret_cast<getter>(MiracastReceiverConnection_get_InputDevices), nullptr, nullptr, nullptr },
        { "stream_control", reinterpret_cast<getter>(MiracastReceiverConnection_get_StreamControl), nullptr, nullptr, nullptr },
        { "transmitter", reinterpret_cast<getter>(MiracastReceiverConnection_get_Transmitter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverConnection) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverConnection =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverConnection",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverConnection
    };

    // ----- MiracastReceiverConnectionCreatedEventArgs class --------------------
    static constexpr const char* const type_name_MiracastReceiverConnectionCreatedEventArgs = "MiracastReceiverConnectionCreatedEventArgs";

    static PyObject* _new_MiracastReceiverConnectionCreatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverConnectionCreatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverConnectionCreatedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_GetDeferral(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverConnectionCreatedEventArgs_get_Pin(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverConnectionCreatedEventArgs", L"Pin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverConnectionCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverConnectionCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverConnectionCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MiracastReceiverConnectionCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverConnectionCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverConnectionCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverConnectionCreatedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverConnectionCreatedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { "pin", reinterpret_cast<getter>(MiracastReceiverConnectionCreatedEventArgs_get_Pin), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverConnectionCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverConnectionCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverConnectionCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverConnectionCreatedEventArgs =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverConnectionCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverConnectionCreatedEventArgs
    };

    // ----- MiracastReceiverCursorImageChannel class --------------------
    static constexpr const char* const type_name_MiracastReceiverCursorImageChannel = "MiracastReceiverCursorImageChannel";

    static PyObject* _new_MiracastReceiverCursorImageChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverCursorImageChannel);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverCursorImageChannel(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_ImageStream(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStream"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImageStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"MaxImageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxImageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_get_Position(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_add_ImageStreamChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStreamChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ImageStreamChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_remove_ImageStreamChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"ImageStreamChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageStreamChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_add_PositionChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannel_remove_PositionChanged(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannel", L"PositionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverCursorImageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverCursorImageChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverCursorImageChannel[] = {
        { "add_image_stream_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_add_ImageStreamChanged), METH_O, nullptr },
        { "remove_image_stream_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_remove_ImageStreamChanged), METH_O, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(MiracastReceiverCursorImageChannel_remove_PositionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverCursorImageChannel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverCursorImageChannel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverCursorImageChannel[] = {
        { "image_stream", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_ImageStream), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_IsEnabled), nullptr, nullptr, nullptr },
        { "max_image_size", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_MaxImageSize), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MiracastReceiverCursorImageChannel_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverCursorImageChannel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverCursorImageChannel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverCursorImageChannel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverCursorImageChannel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverCursorImageChannel) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverCursorImageChannel =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverCursorImageChannel",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverCursorImageChannel
    };

    // ----- MiracastReceiverCursorImageChannelSettings class --------------------
    static constexpr const char* const type_name_MiracastReceiverCursorImageChannelSettings = "MiracastReceiverCursorImageChannelSettings";

    static PyObject* _new_MiracastReceiverCursorImageChannelSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverCursorImageChannelSettings);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverCursorImageChannelSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverCursorImageChannelSettings_get_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"MaxImageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxImageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverCursorImageChannelSettings_put_MaxImageSize(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"MaxImageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            self->obj.MaxImageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverCursorImageChannelSettings_get_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverCursorImageChannelSettings_put_IsEnabled(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverCursorImageChannelSettings", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverCursorImageChannelSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverCursorImageChannelSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverCursorImageChannelSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverCursorImageChannelSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverCursorImageChannelSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverCursorImageChannelSettings[] = {
        { "max_image_size", reinterpret_cast<getter>(MiracastReceiverCursorImageChannelSettings_get_MaxImageSize), reinterpret_cast<setter>(MiracastReceiverCursorImageChannelSettings_put_MaxImageSize), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MiracastReceiverCursorImageChannelSettings_get_IsEnabled), reinterpret_cast<setter>(MiracastReceiverCursorImageChannelSettings_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverCursorImageChannelSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverCursorImageChannelSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverCursorImageChannelSettings) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverCursorImageChannelSettings =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverCursorImageChannelSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverCursorImageChannelSettings
    };

    // ----- MiracastReceiverDisconnectedEventArgs class --------------------
    static constexpr const char* const type_name_MiracastReceiverDisconnectedEventArgs = "MiracastReceiverDisconnectedEventArgs";

    static PyObject* _new_MiracastReceiverDisconnectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverDisconnectedEventArgs);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverDisconnectedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverDisconnectedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverDisconnectedEventArgs", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_MiracastReceiverDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverDisconnectedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverDisconnectedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverDisconnectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverDisconnectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverDisconnectedEventArgs =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverDisconnectedEventArgs
    };

    // ----- MiracastReceiverGameControllerDevice class --------------------
    static constexpr const char* const type_name_MiracastReceiverGameControllerDevice = "MiracastReceiverGameControllerDevice";

    static PyObject* _new_MiracastReceiverGameControllerDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverGameControllerDevice);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverGameControllerDevice(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransmitInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverGameControllerDevice_put_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransmitInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_Mode(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverGameControllerDevice_put_Mode(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Mode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDeviceUsageMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_IsRequestedByTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"IsRequestedByTransmitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequestedByTransmitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_get_IsTransmittingInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"IsTransmittingInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmittingInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_add_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverGameControllerDevice_remove_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverGameControllerDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverGameControllerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverGameControllerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverGameControllerDevice[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(MiracastReceiverGameControllerDevice_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MiracastReceiverGameControllerDevice_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverGameControllerDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverGameControllerDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverGameControllerDevice[] = {
        { "transmit_input", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_TransmitInput), reinterpret_cast<setter>(MiracastReceiverGameControllerDevice_put_TransmitInput), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_Mode), reinterpret_cast<setter>(MiracastReceiverGameControllerDevice_put_Mode), nullptr, nullptr },
        { "is_requested_by_transmitter", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_IsRequestedByTransmitter), nullptr, nullptr, nullptr },
        { "is_transmitting_input", reinterpret_cast<getter>(MiracastReceiverGameControllerDevice_get_IsTransmittingInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverGameControllerDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverGameControllerDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverGameControllerDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverGameControllerDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverGameControllerDevice) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverGameControllerDevice =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverGameControllerDevice",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverGameControllerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverGameControllerDevice
    };

    // ----- MiracastReceiverInputDevices class --------------------
    static constexpr const char* const type_name_MiracastReceiverInputDevices = "MiracastReceiverInputDevices";

    static PyObject* _new_MiracastReceiverInputDevices(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverInputDevices);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverInputDevices(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverInputDevices_get_GameController(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverInputDevices", L"GameController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GameController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverInputDevices_get_Keyboard(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverInputDevices", L"Keyboard"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Keyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverInputDevices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverInputDevices(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverInputDevices[] = {
        { "_assign_array_", _assign_array_MiracastReceiverInputDevices, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverInputDevices), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverInputDevices[] = {
        { "game_controller", reinterpret_cast<getter>(MiracastReceiverInputDevices_get_GameController), nullptr, nullptr, nullptr },
        { "keyboard", reinterpret_cast<getter>(MiracastReceiverInputDevices_get_Keyboard), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverInputDevices[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverInputDevices) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverInputDevices) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverInputDevices) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverInputDevices) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverInputDevices =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverInputDevices",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverInputDevices),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverInputDevices
    };

    // ----- MiracastReceiverKeyboardDevice class --------------------
    static constexpr const char* const type_name_MiracastReceiverKeyboardDevice = "MiracastReceiverKeyboardDevice";

    static PyObject* _new_MiracastReceiverKeyboardDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverKeyboardDevice);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverKeyboardDevice(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransmitInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverKeyboardDevice_put_TransmitInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"TransmitInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransmitInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_IsRequestedByTransmitter(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"IsRequestedByTransmitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequestedByTransmitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_get_IsTransmittingInput(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"IsTransmittingInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransmittingInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_add_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverKeyboardDevice_remove_Changed(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverKeyboardDevice", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverKeyboardDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverKeyboardDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverKeyboardDevice[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(MiracastReceiverKeyboardDevice_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MiracastReceiverKeyboardDevice_remove_Changed), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverKeyboardDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverKeyboardDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverKeyboardDevice[] = {
        { "transmit_input", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_TransmitInput), reinterpret_cast<setter>(MiracastReceiverKeyboardDevice_put_TransmitInput), nullptr, nullptr },
        { "is_requested_by_transmitter", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_IsRequestedByTransmitter), nullptr, nullptr, nullptr },
        { "is_transmitting_input", reinterpret_cast<getter>(MiracastReceiverKeyboardDevice_get_IsTransmittingInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverKeyboardDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverKeyboardDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverKeyboardDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverKeyboardDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverKeyboardDevice) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverKeyboardDevice =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverKeyboardDevice",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverKeyboardDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverKeyboardDevice
    };

    // ----- MiracastReceiverMediaSourceCreatedEventArgs class --------------------
    static constexpr const char* const type_name_MiracastReceiverMediaSourceCreatedEventArgs = "MiracastReceiverMediaSourceCreatedEventArgs";

    static PyObject* _new_MiracastReceiverMediaSourceCreatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverMediaSourceCreatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverMediaSourceCreatedEventArgs(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_GetDeferral(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_Connection(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_CursorImageChannelSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"CursorImageChannelSettings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CursorImageChannelSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverMediaSourceCreatedEventArgs_get_MediaSource(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverMediaSourceCreatedEventArgs", L"MediaSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverMediaSourceCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverMediaSourceCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MiracastReceiverMediaSourceCreatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverMediaSourceCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverMediaSourceCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverMediaSourceCreatedEventArgs[] = {
        { "connection", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_Connection), nullptr, nullptr, nullptr },
        { "cursor_image_channel_settings", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_CursorImageChannelSettings), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MiracastReceiverMediaSourceCreatedEventArgs_get_MediaSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverMediaSourceCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverMediaSourceCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverMediaSourceCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverMediaSourceCreatedEventArgs =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverMediaSourceCreatedEventArgs",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverMediaSourceCreatedEventArgs
    };

    // ----- MiracastReceiverSession class --------------------
    static constexpr const char* const type_name_MiracastReceiverSession = "MiracastReceiverSession";

    static PyObject* _new_MiracastReceiverSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverSession);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSession_Close(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_Start(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Start());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_StartAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_get_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MaxSimultaneousConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSimultaneousConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSession_put_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MaxSimultaneousConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxSimultaneousConnections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSession_get_AllowConnectionTakeover(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"AllowConnectionTakeover"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowConnectionTakeover());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSession_put_AllowConnectionTakeover(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"AllowConnectionTakeover"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowConnectionTakeover(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSession_add_ConnectionCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"ConnectionCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_ConnectionCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"ConnectionCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_add_Disconnected(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_Disconnected(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"Disconnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_add_MediaSourceCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MediaSourceCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Miracast::MiracastReceiverSession, winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>>(arg);

            return py::convert(self->obj.MediaSourceCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSession_remove_MediaSourceCreated(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Miracast.MiracastReceiverSession", L"MediaSourceCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaSourceCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MiracastReceiverSession(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSession[] = {
        { "close", reinterpret_cast<PyCFunction>(MiracastReceiverSession_Close), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MiracastReceiverSession_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(MiracastReceiverSession_StartAsync), METH_VARARGS, nullptr },
        { "add_connection_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_ConnectionCreated), METH_O, nullptr },
        { "remove_connection_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_ConnectionCreated), METH_O, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_Disconnected), METH_O, nullptr },
        { "add_media_source_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_add_MediaSourceCreated), METH_O, nullptr },
        { "remove_media_source_created", reinterpret_cast<PyCFunction>(MiracastReceiverSession_remove_MediaSourceCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MiracastReceiverSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MiracastReceiverSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverSession[] = {
        { "max_simultaneous_connections", reinterpret_cast<getter>(MiracastReceiverSession_get_MaxSimultaneousConnections), reinterpret_cast<setter>(MiracastReceiverSession_put_MaxSimultaneousConnections), nullptr, nullptr },
        { "allow_connection_takeover", reinterpret_cast<getter>(MiracastReceiverSession_get_AllowConnectionTakeover), reinterpret_cast<setter>(MiracastReceiverSession_put_AllowConnectionTakeover), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSession) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverSession =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverSession",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSession
    };

    // ----- MiracastReceiverSessionStartResult class --------------------
    static constexpr const char* const type_name_MiracastReceiverSessionStartResult = "MiracastReceiverSessionStartResult";

    static PyObject* _new_MiracastReceiverSessionStartResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverSessionStartResult);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSessionStartResult(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSessionStartResult_get_ExtendedError(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSessionStartResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverSessionStartResult_get_Status(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSessionStartResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSessionStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSessionStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSessionStartResult[] = {
        { "_assign_array_", _assign_array_MiracastReceiverSessionStartResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSessionStartResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverSessionStartResult[] = {
        { "extended_error", reinterpret_cast<getter>(MiracastReceiverSessionStartResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MiracastReceiverSessionStartResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverSessionStartResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSessionStartResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSessionStartResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSessionStartResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSessionStartResult) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverSessionStartResult =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverSessionStartResult",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSessionStartResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSessionStartResult
    };

    // ----- MiracastReceiverSettings class --------------------
    static constexpr const char* const type_name_MiracastReceiverSettings = "MiracastReceiverSettings";

    static PyObject* _new_MiracastReceiverSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverSettings);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverSettings_get_RequireAuthorizationFromKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"RequireAuthorizationFromKnownTransmitters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequireAuthorizationFromKnownTransmitters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_RequireAuthorizationFromKnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"RequireAuthorizationFromKnownTransmitters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireAuthorizationFromKnownTransmitters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_ModelNumber(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_ModelNumber(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ModelNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_ModelName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_ModelName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"ModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ModelName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_FriendlyName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_FriendlyName(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverSettings_get_AuthorizationMethod(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"AuthorizationMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthorizationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverSettings_put_AuthorizationMethod(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverSettings", L"AuthorizationMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverAuthorizationMethod>(arg);

            self->obj.AuthorizationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverSettings[] = {
        { "require_authorization_from_known_transmitters", reinterpret_cast<getter>(MiracastReceiverSettings_get_RequireAuthorizationFromKnownTransmitters), reinterpret_cast<setter>(MiracastReceiverSettings_put_RequireAuthorizationFromKnownTransmitters), nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(MiracastReceiverSettings_get_ModelNumber), reinterpret_cast<setter>(MiracastReceiverSettings_put_ModelNumber), nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(MiracastReceiverSettings_get_ModelName), reinterpret_cast<setter>(MiracastReceiverSettings_put_ModelName), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(MiracastReceiverSettings_get_FriendlyName), reinterpret_cast<setter>(MiracastReceiverSettings_put_FriendlyName), nullptr, nullptr },
        { "authorization_method", reinterpret_cast<getter>(MiracastReceiverSettings_get_AuthorizationMethod), reinterpret_cast<setter>(MiracastReceiverSettings_put_AuthorizationMethod), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverSettings) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverSettings =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverSettings
    };

    // ----- MiracastReceiverStatus class --------------------
    static constexpr const char* const type_name_MiracastReceiverStatus = "MiracastReceiverStatus";

    static PyObject* _new_MiracastReceiverStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverStatus);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverStatus_get_IsConnectionTakeoverSupported(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"IsConnectionTakeoverSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnectionTakeoverSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_KnownTransmitters(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"KnownTransmitters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KnownTransmitters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_ListeningStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"ListeningStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ListeningStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_MaxSimultaneousConnections(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"MaxSimultaneousConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxSimultaneousConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStatus_get_WiFiStatus(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStatus", L"WiFiStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WiFiStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastReceiverStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverStatus[] = {
        { "_assign_array_", _assign_array_MiracastReceiverStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverStatus[] = {
        { "is_connection_takeover_supported", reinterpret_cast<getter>(MiracastReceiverStatus_get_IsConnectionTakeoverSupported), nullptr, nullptr, nullptr },
        { "known_transmitters", reinterpret_cast<getter>(MiracastReceiverStatus_get_KnownTransmitters), nullptr, nullptr, nullptr },
        { "listening_status", reinterpret_cast<getter>(MiracastReceiverStatus_get_ListeningStatus), nullptr, nullptr, nullptr },
        { "max_simultaneous_connections", reinterpret_cast<getter>(MiracastReceiverStatus_get_MaxSimultaneousConnections), nullptr, nullptr, nullptr },
        { "wi_fi_status", reinterpret_cast<getter>(MiracastReceiverStatus_get_WiFiStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverStatus) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverStatus =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverStatus",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverStatus
    };

    // ----- MiracastReceiverStreamControl class --------------------
    static constexpr const char* const type_name_MiracastReceiverStreamControl = "MiracastReceiverStreamControl";

    static PyObject* _new_MiracastReceiverStreamControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverStreamControl);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverStreamControl(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverStreamControl_GetVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"GetVideoStreamSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVideoStreamSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_GetVideoStreamSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"GetVideoStreamSettingsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVideoStreamSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_SuggestVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"SuggestVideoStreamSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>(args, 0);

                self->obj.SuggestVideoStreamSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_SuggestVideoStreamSettingsAsync(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"SuggestVideoStreamSettingsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>(args, 0);

                return py::convert(self->obj.SuggestVideoStreamSettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastReceiverStreamControl_get_MuteAudio(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"MuteAudio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MuteAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverStreamControl_put_MuteAudio(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverStreamControl", L"MuteAudio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MuteAudio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverStreamControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverStreamControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverStreamControl[] = {
        { "get_video_stream_settings", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_GetVideoStreamSettings), METH_VARARGS, nullptr },
        { "get_video_stream_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_GetVideoStreamSettingsAsync), METH_VARARGS, nullptr },
        { "suggest_video_stream_settings", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_SuggestVideoStreamSettings), METH_VARARGS, nullptr },
        { "suggest_video_stream_settings_async", reinterpret_cast<PyCFunction>(MiracastReceiverStreamControl_SuggestVideoStreamSettingsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastReceiverStreamControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverStreamControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverStreamControl[] = {
        { "mute_audio", reinterpret_cast<getter>(MiracastReceiverStreamControl_get_MuteAudio), reinterpret_cast<setter>(MiracastReceiverStreamControl_put_MuteAudio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverStreamControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverStreamControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverStreamControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverStreamControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverStreamControl) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverStreamControl =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverStreamControl",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverStreamControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverStreamControl
    };

    // ----- MiracastReceiverVideoStreamSettings class --------------------
    static constexpr const char* const type_name_MiracastReceiverVideoStreamSettings = "MiracastReceiverVideoStreamSettings";

    static PyObject* _new_MiracastReceiverVideoStreamSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastReceiverVideoStreamSettings);
        return nullptr;
    }

    static void _dealloc_MiracastReceiverVideoStreamSettings(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastReceiverVideoStreamSettings_get_Size(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverVideoStreamSettings_put_Size(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastReceiverVideoStreamSettings_get_Bitrate(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastReceiverVideoStreamSettings_put_Bitrate(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastReceiverVideoStreamSettings", L"Bitrate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MiracastReceiverVideoStreamSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastReceiverVideoStreamSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastReceiverVideoStreamSettings[] = {
        { "_assign_array_", _assign_array_MiracastReceiverVideoStreamSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastReceiverVideoStreamSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastReceiverVideoStreamSettings[] = {
        { "size", reinterpret_cast<getter>(MiracastReceiverVideoStreamSettings_get_Size), reinterpret_cast<setter>(MiracastReceiverVideoStreamSettings_put_Size), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(MiracastReceiverVideoStreamSettings_get_Bitrate), reinterpret_cast<setter>(MiracastReceiverVideoStreamSettings_put_Bitrate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastReceiverVideoStreamSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastReceiverVideoStreamSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastReceiverVideoStreamSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastReceiverVideoStreamSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastReceiverVideoStreamSettings) },
        { },
    };

    static PyType_Spec type_spec_MiracastReceiverVideoStreamSettings =
    {
        "_winsdk_Windows_Media_Miracast.MiracastReceiverVideoStreamSettings",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastReceiverVideoStreamSettings
    };

    // ----- MiracastTransmitter class --------------------
    static constexpr const char* const type_name_MiracastTransmitter = "MiracastTransmitter";

    static PyObject* _new_MiracastTransmitter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MiracastTransmitter);
        return nullptr;
    }

    static void _dealloc_MiracastTransmitter(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MiracastTransmitter_GetConnections(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"GetConnections", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConnections());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MiracastTransmitter_get_Name(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastTransmitter_put_Name(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastTransmitter_get_AuthorizationStatus(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"AuthorizationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthorizationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MiracastTransmitter_put_AuthorizationStatus(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"AuthorizationStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Miracast::MiracastTransmitterAuthorizationStatus>(arg);

            self->obj.AuthorizationStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MiracastTransmitter_get_LastConnectionTime(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"LastConnectionTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LastConnectionTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MiracastTransmitter_get_MacAddress(py::wrapper::Windows::Media::Miracast::MiracastTransmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Miracast.MiracastTransmitter", L"MacAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MacAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MiracastTransmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Miracast::MiracastTransmitter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MiracastTransmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Miracast::MiracastTransmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MiracastTransmitter[] = {
        { "get_connections", reinterpret_cast<PyCFunction>(MiracastTransmitter_GetConnections), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MiracastTransmitter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MiracastTransmitter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MiracastTransmitter[] = {
        { "name", reinterpret_cast<getter>(MiracastTransmitter_get_Name), reinterpret_cast<setter>(MiracastTransmitter_put_Name), nullptr, nullptr },
        { "authorization_status", reinterpret_cast<getter>(MiracastTransmitter_get_AuthorizationStatus), reinterpret_cast<setter>(MiracastTransmitter_put_AuthorizationStatus), nullptr, nullptr },
        { "last_connection_time", reinterpret_cast<getter>(MiracastTransmitter_get_LastConnectionTime), nullptr, nullptr, nullptr },
        { "mac_address", reinterpret_cast<getter>(MiracastTransmitter_get_MacAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MiracastTransmitter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MiracastTransmitter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MiracastTransmitter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MiracastTransmitter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MiracastTransmitter) },
        { },
    };

    static PyType_Spec type_spec_MiracastTransmitter =
    {
        "_winsdk_Windows_Media_Miracast.MiracastTransmitter",
        sizeof(py::wrapper::Windows::Media::Miracast::MiracastTransmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MiracastTransmitter
    };

    // ----- Windows.Media.Miracast Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Miracast");

    static PyMethodDef module_methods[] = {
        {"_register_MiracastReceiverApplySettingsStatus", register_MiracastReceiverApplySettingsStatus, METH_O, "registers type"},
        {"_register_MiracastReceiverAuthorizationMethod", register_MiracastReceiverAuthorizationMethod, METH_O, "registers type"},
        {"_register_MiracastReceiverDisconnectReason", register_MiracastReceiverDisconnectReason, METH_O, "registers type"},
        {"_register_MiracastReceiverGameControllerDeviceUsageMode", register_MiracastReceiverGameControllerDeviceUsageMode, METH_O, "registers type"},
        {"_register_MiracastReceiverListeningStatus", register_MiracastReceiverListeningStatus, METH_O, "registers type"},
        {"_register_MiracastReceiverSessionStartStatus", register_MiracastReceiverSessionStartStatus, METH_O, "registers type"},
        {"_register_MiracastReceiverWiFiStatus", register_MiracastReceiverWiFiStatus, METH_O, "registers type"},
        {"_register_MiracastTransmitterAuthorizationStatus", register_MiracastTransmitterAuthorizationStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_MiracastReceiverApplySettingsStatus);
        Py_VISIT(state->type_MiracastReceiverAuthorizationMethod);
        Py_VISIT(state->type_MiracastReceiverDisconnectReason);
        Py_VISIT(state->type_MiracastReceiverGameControllerDeviceUsageMode);
        Py_VISIT(state->type_MiracastReceiverListeningStatus);
        Py_VISIT(state->type_MiracastReceiverSessionStartStatus);
        Py_VISIT(state->type_MiracastReceiverWiFiStatus);
        Py_VISIT(state->type_MiracastTransmitterAuthorizationStatus);
        Py_VISIT(state->type_MiracastReceiver);
        Py_VISIT(state->type_MiracastReceiverApplySettingsResult);
        Py_VISIT(state->type_MiracastReceiverConnection);
        Py_VISIT(state->type_MiracastReceiverConnectionCreatedEventArgs);
        Py_VISIT(state->type_MiracastReceiverCursorImageChannel);
        Py_VISIT(state->type_MiracastReceiverCursorImageChannelSettings);
        Py_VISIT(state->type_MiracastReceiverDisconnectedEventArgs);
        Py_VISIT(state->type_MiracastReceiverGameControllerDevice);
        Py_VISIT(state->type_MiracastReceiverInputDevices);
        Py_VISIT(state->type_MiracastReceiverKeyboardDevice);
        Py_VISIT(state->type_MiracastReceiverMediaSourceCreatedEventArgs);
        Py_VISIT(state->type_MiracastReceiverSession);
        Py_VISIT(state->type_MiracastReceiverSessionStartResult);
        Py_VISIT(state->type_MiracastReceiverSettings);
        Py_VISIT(state->type_MiracastReceiverStatus);
        Py_VISIT(state->type_MiracastReceiverStreamControl);
        Py_VISIT(state->type_MiracastReceiverVideoStreamSettings);
        Py_VISIT(state->type_MiracastTransmitter);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_MiracastReceiverApplySettingsStatus);
        Py_CLEAR(state->type_MiracastReceiverAuthorizationMethod);
        Py_CLEAR(state->type_MiracastReceiverDisconnectReason);
        Py_CLEAR(state->type_MiracastReceiverGameControllerDeviceUsageMode);
        Py_CLEAR(state->type_MiracastReceiverListeningStatus);
        Py_CLEAR(state->type_MiracastReceiverSessionStartStatus);
        Py_CLEAR(state->type_MiracastReceiverWiFiStatus);
        Py_CLEAR(state->type_MiracastTransmitterAuthorizationStatus);
        Py_CLEAR(state->type_MiracastReceiver);
        Py_CLEAR(state->type_MiracastReceiverApplySettingsResult);
        Py_CLEAR(state->type_MiracastReceiverConnection);
        Py_CLEAR(state->type_MiracastReceiverConnectionCreatedEventArgs);
        Py_CLEAR(state->type_MiracastReceiverCursorImageChannel);
        Py_CLEAR(state->type_MiracastReceiverCursorImageChannelSettings);
        Py_CLEAR(state->type_MiracastReceiverDisconnectedEventArgs);
        Py_CLEAR(state->type_MiracastReceiverGameControllerDevice);
        Py_CLEAR(state->type_MiracastReceiverInputDevices);
        Py_CLEAR(state->type_MiracastReceiverKeyboardDevice);
        Py_CLEAR(state->type_MiracastReceiverMediaSourceCreatedEventArgs);
        Py_CLEAR(state->type_MiracastReceiverSession);
        Py_CLEAR(state->type_MiracastReceiverSessionStartResult);
        Py_CLEAR(state->type_MiracastReceiverSettings);
        Py_CLEAR(state->type_MiracastReceiverStatus);
        Py_CLEAR(state->type_MiracastReceiverStreamControl);
        Py_CLEAR(state->type_MiracastReceiverVideoStreamSettings);
        Py_CLEAR(state->type_MiracastTransmitter);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Miracast",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::Miracast

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_Miracast(void) noexcept
{
    using namespace py::cpp::Windows::Media::Miracast;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_MiracastReceiver = py::register_python_type(module.get(), type_name_MiracastReceiver, &type_spec_MiracastReceiver, bases.get(), nullptr);
    if (!state->type_MiracastReceiver)
    {
        return nullptr;
    }

    state->type_MiracastReceiverApplySettingsResult = py::register_python_type(module.get(), type_name_MiracastReceiverApplySettingsResult, &type_spec_MiracastReceiverApplySettingsResult, bases.get(), nullptr);
    if (!state->type_MiracastReceiverApplySettingsResult)
    {
        return nullptr;
    }

    state->type_MiracastReceiverConnection = py::register_python_type(module.get(), type_name_MiracastReceiverConnection, &type_spec_MiracastReceiverConnection, bases.get(), nullptr);
    if (!state->type_MiracastReceiverConnection)
    {
        return nullptr;
    }

    state->type_MiracastReceiverConnectionCreatedEventArgs = py::register_python_type(module.get(), type_name_MiracastReceiverConnectionCreatedEventArgs, &type_spec_MiracastReceiverConnectionCreatedEventArgs, bases.get(), nullptr);
    if (!state->type_MiracastReceiverConnectionCreatedEventArgs)
    {
        return nullptr;
    }

    state->type_MiracastReceiverCursorImageChannel = py::register_python_type(module.get(), type_name_MiracastReceiverCursorImageChannel, &type_spec_MiracastReceiverCursorImageChannel, bases.get(), nullptr);
    if (!state->type_MiracastReceiverCursorImageChannel)
    {
        return nullptr;
    }

    state->type_MiracastReceiverCursorImageChannelSettings = py::register_python_type(module.get(), type_name_MiracastReceiverCursorImageChannelSettings, &type_spec_MiracastReceiverCursorImageChannelSettings, bases.get(), nullptr);
    if (!state->type_MiracastReceiverCursorImageChannelSettings)
    {
        return nullptr;
    }

    state->type_MiracastReceiverDisconnectedEventArgs = py::register_python_type(module.get(), type_name_MiracastReceiverDisconnectedEventArgs, &type_spec_MiracastReceiverDisconnectedEventArgs, bases.get(), nullptr);
    if (!state->type_MiracastReceiverDisconnectedEventArgs)
    {
        return nullptr;
    }

    state->type_MiracastReceiverGameControllerDevice = py::register_python_type(module.get(), type_name_MiracastReceiverGameControllerDevice, &type_spec_MiracastReceiverGameControllerDevice, bases.get(), nullptr);
    if (!state->type_MiracastReceiverGameControllerDevice)
    {
        return nullptr;
    }

    state->type_MiracastReceiverInputDevices = py::register_python_type(module.get(), type_name_MiracastReceiverInputDevices, &type_spec_MiracastReceiverInputDevices, bases.get(), nullptr);
    if (!state->type_MiracastReceiverInputDevices)
    {
        return nullptr;
    }

    state->type_MiracastReceiverKeyboardDevice = py::register_python_type(module.get(), type_name_MiracastReceiverKeyboardDevice, &type_spec_MiracastReceiverKeyboardDevice, bases.get(), nullptr);
    if (!state->type_MiracastReceiverKeyboardDevice)
    {
        return nullptr;
    }

    state->type_MiracastReceiverMediaSourceCreatedEventArgs = py::register_python_type(module.get(), type_name_MiracastReceiverMediaSourceCreatedEventArgs, &type_spec_MiracastReceiverMediaSourceCreatedEventArgs, bases.get(), nullptr);
    if (!state->type_MiracastReceiverMediaSourceCreatedEventArgs)
    {
        return nullptr;
    }

    state->type_MiracastReceiverSession = py::register_python_type(module.get(), type_name_MiracastReceiverSession, &type_spec_MiracastReceiverSession, bases.get(), nullptr);
    if (!state->type_MiracastReceiverSession)
    {
        return nullptr;
    }

    state->type_MiracastReceiverSessionStartResult = py::register_python_type(module.get(), type_name_MiracastReceiverSessionStartResult, &type_spec_MiracastReceiverSessionStartResult, bases.get(), nullptr);
    if (!state->type_MiracastReceiverSessionStartResult)
    {
        return nullptr;
    }

    state->type_MiracastReceiverSettings = py::register_python_type(module.get(), type_name_MiracastReceiverSettings, &type_spec_MiracastReceiverSettings, bases.get(), nullptr);
    if (!state->type_MiracastReceiverSettings)
    {
        return nullptr;
    }

    state->type_MiracastReceiverStatus = py::register_python_type(module.get(), type_name_MiracastReceiverStatus, &type_spec_MiracastReceiverStatus, bases.get(), nullptr);
    if (!state->type_MiracastReceiverStatus)
    {
        return nullptr;
    }

    state->type_MiracastReceiverStreamControl = py::register_python_type(module.get(), type_name_MiracastReceiverStreamControl, &type_spec_MiracastReceiverStreamControl, bases.get(), nullptr);
    if (!state->type_MiracastReceiverStreamControl)
    {
        return nullptr;
    }

    state->type_MiracastReceiverVideoStreamSettings = py::register_python_type(module.get(), type_name_MiracastReceiverVideoStreamSettings, &type_spec_MiracastReceiverVideoStreamSettings, bases.get(), nullptr);
    if (!state->type_MiracastReceiverVideoStreamSettings)
    {
        return nullptr;
    }

    state->type_MiracastTransmitter = py::register_python_type(module.get(), type_name_MiracastTransmitter, &type_spec_MiracastTransmitter, bases.get(), nullptr);
    if (!state->type_MiracastTransmitter)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverApplySettingsStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverAuthorizationMethod>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverAuthorizationMethod;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverAuthorizationMethod is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverDisconnectReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverDisconnectReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDeviceUsageMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverGameControllerDeviceUsageMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDeviceUsageMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverListeningStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverListeningStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverListeningStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverSessionStartStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverSessionStartStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastReceiverWiFiStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverWiFiStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverWiFiStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Miracast::MiracastTransmitterAuthorizationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastTransmitterAuthorizationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastTransmitterAuthorizationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiver>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiver;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiver is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverApplySettingsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverApplySettingsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverConnectionCreatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverConnectionCreatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverCursorImageChannel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverCursorImageChannelSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverCursorImageChannelSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverDisconnectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverDisconnectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverGameControllerDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverGameControllerDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverInputDevices>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverInputDevices;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverInputDevices is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverKeyboardDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverKeyboardDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverMediaSourceCreatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverMediaSourceCreatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverSessionStartResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverSessionStartResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverStreamControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverStreamControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverStreamControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastReceiverVideoStreamSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastReceiverVideoStreamSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Miracast::MiracastTransmitter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Miracast;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Miracast");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MiracastTransmitter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Miracast::MiracastTransmitter is not registered");
        return nullptr;
    }

    return python_type;
}
