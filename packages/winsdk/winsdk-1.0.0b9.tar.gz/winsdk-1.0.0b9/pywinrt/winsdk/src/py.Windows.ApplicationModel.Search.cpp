// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.ApplicationModel.Search.h"


namespace py::cpp::Windows::ApplicationModel::Search
{
    struct module_state
    {
        PyTypeObject* type_LocalContentSuggestionSettings;
        PyTypeObject* type_SearchPane;
        PyTypeObject* type_SearchPaneQueryChangedEventArgs;
        PyTypeObject* type_SearchPaneQueryLinguisticDetails;
        PyTypeObject* type_SearchPaneQuerySubmittedEventArgs;
        PyTypeObject* type_SearchPaneResultSuggestionChosenEventArgs;
        PyTypeObject* type_SearchPaneSuggestionsRequest;
        PyTypeObject* type_SearchPaneSuggestionsRequestDeferral;
        PyTypeObject* type_SearchPaneSuggestionsRequestedEventArgs;
        PyTypeObject* type_SearchPaneVisibilityChangedEventArgs;
        PyTypeObject* type_SearchQueryLinguisticDetails;
        PyTypeObject* type_SearchSuggestionCollection;
        PyTypeObject* type_SearchSuggestionsRequest;
        PyTypeObject* type_SearchSuggestionsRequestDeferral;
        PyTypeObject* type_ISearchPaneQueryChangedEventArgs;
    };

    // ----- LocalContentSuggestionSettings class --------------------
    static constexpr const char* const type_name_LocalContentSuggestionSettings = "LocalContentSuggestionSettings";

    static PyObject* _new_LocalContentSuggestionSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocalContentSuggestionSettings(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocalContentSuggestionSettings_get_Enabled(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalContentSuggestionSettings_put_Enabled(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Enabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_AqsFilter(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"AqsFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AqsFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalContentSuggestionSettings_put_AqsFilter(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"AqsFilter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AqsFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_Locations(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"Locations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Locations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LocalContentSuggestionSettings_get_PropertiesToMatch(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.LocalContentSuggestionSettings", L"PropertiesToMatch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PropertiesToMatch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocalContentSuggestionSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocalContentSuggestionSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocalContentSuggestionSettings[] = {
        { "_assign_array_", _assign_array_LocalContentSuggestionSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocalContentSuggestionSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LocalContentSuggestionSettings[] = {
        { "enabled", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_Enabled), reinterpret_cast<setter>(LocalContentSuggestionSettings_put_Enabled), nullptr, nullptr },
        { "aqs_filter", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_AqsFilter), reinterpret_cast<setter>(LocalContentSuggestionSettings_put_AqsFilter), nullptr, nullptr },
        { "locations", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_Locations), nullptr, nullptr, nullptr },
        { "properties_to_match", reinterpret_cast<getter>(LocalContentSuggestionSettings_get_PropertiesToMatch), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LocalContentSuggestionSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocalContentSuggestionSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocalContentSuggestionSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocalContentSuggestionSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocalContentSuggestionSettings) },
        { },
    };

    static PyType_Spec type_spec_LocalContentSuggestionSettings =
    {
        "_winsdk_Windows_ApplicationModel_Search.LocalContentSuggestionSettings",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::LocalContentSuggestionSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocalContentSuggestionSettings
    };

    // ----- SearchPane class --------------------
    static constexpr const char* const type_name_SearchPane = "SearchPane";

    static PyObject* _new_SearchPane(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPane);
        return nullptr;
    }

    static void _dealloc_SearchPane(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPane_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Search::SearchPane::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_HideThisApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"HideThisApplication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Search::SearchPane::HideThisApplication();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_SetLocalContentSuggestionSettings(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SetLocalContentSuggestionSettings", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>(args, 0);

                self->obj.SetLocalContentSuggestionSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_Show(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Show", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Show();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_TrySetQueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPane", L"TrySetQueryText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TrySetQueryText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_ShowOnKeyboardInput(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ShowOnKeyboardInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShowOnKeyboardInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_ShowOnKeyboardInput(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ShowOnKeyboardInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowOnKeyboardInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_SearchHistoryEnabled(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchHistoryEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_SearchHistoryEnabled(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SearchHistoryEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_SearchHistoryContext(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchHistoryContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_SearchHistoryContext(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SearchHistoryContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SearchHistoryContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_PlaceholderText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"PlaceholderText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SearchPane_put_PlaceholderText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"PlaceholderText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SearchPane_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_get_Visible(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPane", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_QueryChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>>(arg);

            return py::convert(self->obj.QueryChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_QueryChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QueryChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QueryChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_QuerySubmitted(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QuerySubmitted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>>(arg);

            return py::convert(self->obj.QuerySubmitted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_QuerySubmitted(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"QuerySubmitted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuerySubmitted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_ResultSuggestionChosen(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ResultSuggestionChosen"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>>(arg);

            return py::convert(self->obj.ResultSuggestionChosen(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_ResultSuggestionChosen(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"ResultSuggestionChosen"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResultSuggestionChosen(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_SuggestionsRequested(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SuggestionsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SuggestionsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_SuggestionsRequested(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"SuggestionsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SuggestionsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_add_VisibilityChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Search::SearchPane, winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>>(arg);

            return py::convert(self->obj.VisibilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPane_remove_VisibilityChanged(py::wrapper::Windows::ApplicationModel::Search::SearchPane* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Search.SearchPane", L"VisibilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPane>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPane>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPane[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(SearchPane_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "hide_this_application", reinterpret_cast<PyCFunction>(SearchPane_HideThisApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "set_local_content_suggestion_settings", reinterpret_cast<PyCFunction>(SearchPane_SetLocalContentSuggestionSettings), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(SearchPane_Show), METH_VARARGS, nullptr },
        { "try_set_query_text", reinterpret_cast<PyCFunction>(SearchPane_TrySetQueryText), METH_VARARGS, nullptr },
        { "add_query_changed", reinterpret_cast<PyCFunction>(SearchPane_add_QueryChanged), METH_O, nullptr },
        { "remove_query_changed", reinterpret_cast<PyCFunction>(SearchPane_remove_QueryChanged), METH_O, nullptr },
        { "add_query_submitted", reinterpret_cast<PyCFunction>(SearchPane_add_QuerySubmitted), METH_O, nullptr },
        { "remove_query_submitted", reinterpret_cast<PyCFunction>(SearchPane_remove_QuerySubmitted), METH_O, nullptr },
        { "add_result_suggestion_chosen", reinterpret_cast<PyCFunction>(SearchPane_add_ResultSuggestionChosen), METH_O, nullptr },
        { "remove_result_suggestion_chosen", reinterpret_cast<PyCFunction>(SearchPane_remove_ResultSuggestionChosen), METH_O, nullptr },
        { "add_suggestions_requested", reinterpret_cast<PyCFunction>(SearchPane_add_SuggestionsRequested), METH_O, nullptr },
        { "remove_suggestions_requested", reinterpret_cast<PyCFunction>(SearchPane_remove_SuggestionsRequested), METH_O, nullptr },
        { "add_visibility_changed", reinterpret_cast<PyCFunction>(SearchPane_add_VisibilityChanged), METH_O, nullptr },
        { "remove_visibility_changed", reinterpret_cast<PyCFunction>(SearchPane_remove_VisibilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SearchPane, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPane), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPane[] = {
        { "show_on_keyboard_input", reinterpret_cast<getter>(SearchPane_get_ShowOnKeyboardInput), reinterpret_cast<setter>(SearchPane_put_ShowOnKeyboardInput), nullptr, nullptr },
        { "search_history_enabled", reinterpret_cast<getter>(SearchPane_get_SearchHistoryEnabled), reinterpret_cast<setter>(SearchPane_put_SearchHistoryEnabled), nullptr, nullptr },
        { "search_history_context", reinterpret_cast<getter>(SearchPane_get_SearchHistoryContext), reinterpret_cast<setter>(SearchPane_put_SearchHistoryContext), nullptr, nullptr },
        { "placeholder_text", reinterpret_cast<getter>(SearchPane_get_PlaceholderText), reinterpret_cast<setter>(SearchPane_put_PlaceholderText), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(SearchPane_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPane_get_QueryText), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(SearchPane_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPane[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPane) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPane) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPane) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPane) },
        { },
    };

    static PyType_Spec type_spec_SearchPane =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPane",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPane
    };

    // ----- SearchPaneQueryChangedEventArgs class --------------------
    static constexpr const char* const type_name_SearchPaneQueryChangedEventArgs = "SearchPaneQueryChangedEventArgs";

    static PyObject* _new_SearchPaneQueryChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneQueryChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SearchPaneQueryChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryChangedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQueryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneQueryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQueryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneQueryChangedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneQueryChangedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneQueryChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQueryChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQueryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQueryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQueryChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneQueryChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneQueryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQueryChangedEventArgs
    };

    // ----- SearchPaneQueryLinguisticDetails class --------------------
    static constexpr const char* const type_name_SearchPaneQueryLinguisticDetails = "SearchPaneQueryLinguisticDetails";

    static PyObject* _new_SearchPaneQueryLinguisticDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneQueryLinguisticDetails);
        return nullptr;
    }

    static void _dealloc_SearchPaneQueryLinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextAlternatives(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextAlternatives"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextAlternatives());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextCompositionLength(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextCompositionLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQueryLinguisticDetails_get_QueryTextCompositionStart(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails", L"QueryTextCompositionStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQueryLinguisticDetails[] = {
        { "_assign_array_", _assign_array_SearchPaneQueryLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQueryLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneQueryLinguisticDetails[] = {
        { "query_text_alternatives", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextAlternatives), nullptr, nullptr, nullptr },
        { "query_text_composition_length", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextCompositionLength), nullptr, nullptr, nullptr },
        { "query_text_composition_start", reinterpret_cast<getter>(SearchPaneQueryLinguisticDetails_get_QueryTextCompositionStart), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneQueryLinguisticDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQueryLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQueryLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQueryLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQueryLinguisticDetails) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneQueryLinguisticDetails =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneQueryLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQueryLinguisticDetails
    };

    // ----- SearchPaneQuerySubmittedEventArgs class --------------------
    static constexpr const char* const type_name_SearchPaneQuerySubmittedEventArgs = "SearchPaneQuerySubmittedEventArgs";

    static PyObject* _new_SearchPaneQuerySubmittedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneQuerySubmittedEventArgs);
        return nullptr;
    }

    static void _dealloc_SearchPaneQuerySubmittedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneQuerySubmittedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneQuerySubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneQuerySubmittedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneQuerySubmittedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneQuerySubmittedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneQuerySubmittedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneQuerySubmittedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneQuerySubmittedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneQuerySubmittedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneQuerySubmittedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneQuerySubmittedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneQuerySubmittedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneQuerySubmittedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneQuerySubmittedEventArgs
    };

    // ----- SearchPaneResultSuggestionChosenEventArgs class --------------------
    static constexpr const char* const type_name_SearchPaneResultSuggestionChosenEventArgs = "SearchPaneResultSuggestionChosenEventArgs";

    static PyObject* _new_SearchPaneResultSuggestionChosenEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneResultSuggestionChosenEventArgs);
        return nullptr;
    }

    static void _dealloc_SearchPaneResultSuggestionChosenEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneResultSuggestionChosenEventArgs_get_Tag(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneResultSuggestionChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneResultSuggestionChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneResultSuggestionChosenEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneResultSuggestionChosenEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneResultSuggestionChosenEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneResultSuggestionChosenEventArgs[] = {
        { "tag", reinterpret_cast<getter>(SearchPaneResultSuggestionChosenEventArgs_get_Tag), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneResultSuggestionChosenEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneResultSuggestionChosenEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneResultSuggestionChosenEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneResultSuggestionChosenEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneResultSuggestionChosenEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneResultSuggestionChosenEventArgs
    };

    // ----- SearchPaneSuggestionsRequest class --------------------
    static constexpr const char* const type_name_SearchPaneSuggestionsRequest = "SearchPaneSuggestionsRequest";

    static PyObject* _new_SearchPaneSuggestionsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneSuggestionsRequest);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequest(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequest_get_IsCanceled(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequest_get_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest", L"SearchSuggestionCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchSuggestionCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SearchPaneSuggestionsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneSuggestionsRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(SearchPaneSuggestionsRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "search_suggestion_collection", reinterpret_cast<getter>(SearchPaneSuggestionsRequest_get_SearchSuggestionCollection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequest) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneSuggestionsRequest =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneSuggestionsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequest
    };

    // ----- SearchPaneSuggestionsRequestDeferral class --------------------
    static constexpr const char* const type_name_SearchPaneSuggestionsRequestDeferral = "SearchPaneSuggestionsRequestDeferral";

    static PyObject* _new_SearchPaneSuggestionsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneSuggestionsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequestDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SearchPaneSuggestionsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneSuggestionsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneSuggestionsRequestDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneSuggestionsRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequestDeferral
    };

    // ----- SearchPaneSuggestionsRequestedEventArgs class --------------------
    static constexpr const char* const type_name_SearchPaneSuggestionsRequestedEventArgs = "SearchPaneSuggestionsRequestedEventArgs";

    static PyObject* _new_SearchPaneSuggestionsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneSuggestionsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_SearchPaneSuggestionsRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchPaneSuggestionsRequestedEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneSuggestionsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneSuggestionsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneSuggestionsRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneSuggestionsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneSuggestionsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneSuggestionsRequestedEventArgs[] = {
        { "language", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "request", reinterpret_cast<getter>(SearchPaneSuggestionsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneSuggestionsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneSuggestionsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneSuggestionsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneSuggestionsRequestedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneSuggestionsRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneSuggestionsRequestedEventArgs
    };

    // ----- SearchPaneVisibilityChangedEventArgs class --------------------
    static constexpr const char* const type_name_SearchPaneVisibilityChangedEventArgs = "SearchPaneVisibilityChangedEventArgs";

    static PyObject* _new_SearchPaneVisibilityChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchPaneVisibilityChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SearchPaneVisibilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchPaneVisibilityChangedEventArgs_get_Visible(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchPaneVisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchPaneVisibilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchPaneVisibilityChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SearchPaneVisibilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchPaneVisibilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchPaneVisibilityChangedEventArgs[] = {
        { "visible", reinterpret_cast<getter>(SearchPaneVisibilityChangedEventArgs_get_Visible), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchPaneVisibilityChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchPaneVisibilityChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchPaneVisibilityChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_SearchPaneVisibilityChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchPaneVisibilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchPaneVisibilityChangedEventArgs
    };

    // ----- SearchQueryLinguisticDetails class --------------------
    static constexpr const char* const type_name_SearchQueryLinguisticDetails = "SearchQueryLinguisticDetails";

    static PyObject* _new_SearchQueryLinguisticDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SearchQueryLinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextAlternatives(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextAlternatives"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextAlternatives());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextCompositionLength(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextCompositionLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchQueryLinguisticDetails_get_QueryTextCompositionStart(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchQueryLinguisticDetails", L"QueryTextCompositionStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryTextCompositionStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchQueryLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchQueryLinguisticDetails[] = {
        { "_assign_array_", _assign_array_SearchQueryLinguisticDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchQueryLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchQueryLinguisticDetails[] = {
        { "query_text_alternatives", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextAlternatives), nullptr, nullptr, nullptr },
        { "query_text_composition_length", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextCompositionLength), nullptr, nullptr, nullptr },
        { "query_text_composition_start", reinterpret_cast<getter>(SearchQueryLinguisticDetails_get_QueryTextCompositionStart), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchQueryLinguisticDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchQueryLinguisticDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchQueryLinguisticDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchQueryLinguisticDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchQueryLinguisticDetails) },
        { },
    };

    static PyType_Spec type_spec_SearchQueryLinguisticDetails =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchQueryLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchQueryLinguisticDetails
    };

    // ----- SearchSuggestionCollection class --------------------
    static constexpr const char* const type_name_SearchSuggestionCollection = "SearchSuggestionCollection";

    static PyObject* _new_SearchSuggestionCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchSuggestionCollection);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionCollection_AppendQuerySuggestion(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendQuerySuggestion", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AppendQuerySuggestion(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendQuerySuggestions(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendQuerySuggestions", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                self->obj.AppendQuerySuggestions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendResultSuggestion(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendResultSuggestion", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                self->obj.AppendResultSuggestion(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_AppendSearchSeparator(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"AppendSearchSeparator", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AppendSearchSeparator(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionCollection_get_Size(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionCollection[] = {
        { "append_query_suggestion", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendQuerySuggestion), METH_VARARGS, nullptr },
        { "append_query_suggestions", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendQuerySuggestions), METH_VARARGS, nullptr },
        { "append_result_suggestion", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendResultSuggestion), METH_VARARGS, nullptr },
        { "append_search_separator", reinterpret_cast<PyCFunction>(SearchSuggestionCollection_AppendSearchSeparator), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchSuggestionCollection[] = {
        { "size", reinterpret_cast<getter>(SearchSuggestionCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchSuggestionCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionCollection) },
        { },
    };

    static PyType_Spec type_spec_SearchSuggestionCollection =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchSuggestionCollection",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionCollection
    };

    // ----- SearchSuggestionsRequest class --------------------
    static constexpr const char* const type_name_SearchSuggestionsRequest = "SearchSuggestionsRequest";

    static PyObject* _new_SearchSuggestionsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchSuggestionsRequest);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionsRequest(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionsRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionsRequest_get_IsCanceled(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"IsCanceled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchSuggestionsRequest_get_SearchSuggestionCollection(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequest", L"SearchSuggestionCollection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchSuggestionCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SearchSuggestionsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionsRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchSuggestionsRequest[] = {
        { "is_canceled", reinterpret_cast<getter>(SearchSuggestionsRequest_get_IsCanceled), nullptr, nullptr, nullptr },
        { "search_suggestion_collection", reinterpret_cast<getter>(SearchSuggestionsRequest_get_SearchSuggestionCollection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchSuggestionsRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionsRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionsRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionsRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionsRequest) },
        { },
    };

    static PyType_Spec type_spec_SearchSuggestionsRequest =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchSuggestionsRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionsRequest
    };

    // ----- SearchSuggestionsRequestDeferral class --------------------
    static constexpr const char* const type_name_SearchSuggestionsRequestDeferral = "SearchSuggestionsRequestDeferral";

    static PyObject* _new_SearchSuggestionsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchSuggestionsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_SearchSuggestionsRequestDeferral(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchSuggestionsRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SearchSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchSuggestionsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchSuggestionsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SearchSuggestionsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SearchSuggestionsRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchSuggestionsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchSuggestionsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchSuggestionsRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchSuggestionsRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchSuggestionsRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchSuggestionsRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchSuggestionsRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_SearchSuggestionsRequestDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Search.SearchSuggestionsRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchSuggestionsRequestDeferral
    };

    // ----- ISearchPaneQueryChangedEventArgs interface --------------------
    static constexpr const char* const type_name_ISearchPaneQueryChangedEventArgs = "ISearchPaneQueryChangedEventArgs";

    static PyObject* _new_ISearchPaneQueryChangedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ISearchPaneQueryChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ISearchPaneQueryChangedEventArgs(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"LinguisticDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchPaneQueryChangedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs", L"QueryText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISearchPaneQueryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchPaneQueryChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ISearchPaneQueryChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchPaneQueryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISearchPaneQueryChangedEventArgs[] = {
        { "language", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(ISearchPaneQueryChangedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISearchPaneQueryChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISearchPaneQueryChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISearchPaneQueryChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ISearchPaneQueryChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Search.ISearchPaneQueryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISearchPaneQueryChangedEventArgs
    };

    // ----- Windows.ApplicationModel.Search Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Search");

    static PyMethodDef module_methods[] = {
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_LocalContentSuggestionSettings);
        Py_VISIT(state->type_SearchPane);
        Py_VISIT(state->type_SearchPaneQueryChangedEventArgs);
        Py_VISIT(state->type_SearchPaneQueryLinguisticDetails);
        Py_VISIT(state->type_SearchPaneQuerySubmittedEventArgs);
        Py_VISIT(state->type_SearchPaneResultSuggestionChosenEventArgs);
        Py_VISIT(state->type_SearchPaneSuggestionsRequest);
        Py_VISIT(state->type_SearchPaneSuggestionsRequestDeferral);
        Py_VISIT(state->type_SearchPaneSuggestionsRequestedEventArgs);
        Py_VISIT(state->type_SearchPaneVisibilityChangedEventArgs);
        Py_VISIT(state->type_SearchQueryLinguisticDetails);
        Py_VISIT(state->type_SearchSuggestionCollection);
        Py_VISIT(state->type_SearchSuggestionsRequest);
        Py_VISIT(state->type_SearchSuggestionsRequestDeferral);
        Py_VISIT(state->type_ISearchPaneQueryChangedEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_LocalContentSuggestionSettings);
        Py_CLEAR(state->type_SearchPane);
        Py_CLEAR(state->type_SearchPaneQueryChangedEventArgs);
        Py_CLEAR(state->type_SearchPaneQueryLinguisticDetails);
        Py_CLEAR(state->type_SearchPaneQuerySubmittedEventArgs);
        Py_CLEAR(state->type_SearchPaneResultSuggestionChosenEventArgs);
        Py_CLEAR(state->type_SearchPaneSuggestionsRequest);
        Py_CLEAR(state->type_SearchPaneSuggestionsRequestDeferral);
        Py_CLEAR(state->type_SearchPaneSuggestionsRequestedEventArgs);
        Py_CLEAR(state->type_SearchPaneVisibilityChangedEventArgs);
        Py_CLEAR(state->type_SearchQueryLinguisticDetails);
        Py_CLEAR(state->type_SearchSuggestionCollection);
        Py_CLEAR(state->type_SearchSuggestionsRequest);
        Py_CLEAR(state->type_SearchSuggestionsRequestDeferral);
        Py_CLEAR(state->type_ISearchPaneQueryChangedEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Search",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Search

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Search(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Search;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_LocalContentSuggestionSettings = py::register_python_type(module.get(), type_name_LocalContentSuggestionSettings, &type_spec_LocalContentSuggestionSettings, bases.get(), nullptr);
    if (!state->type_LocalContentSuggestionSettings)
    {
        return nullptr;
    }

    state->type_SearchPane = py::register_python_type(module.get(), type_name_SearchPane, &type_spec_SearchPane, bases.get(), nullptr);
    if (!state->type_SearchPane)
    {
        return nullptr;
    }

    state->type_SearchPaneQueryChangedEventArgs = py::register_python_type(module.get(), type_name_SearchPaneQueryChangedEventArgs, &type_spec_SearchPaneQueryChangedEventArgs, bases.get(), nullptr);
    if (!state->type_SearchPaneQueryChangedEventArgs)
    {
        return nullptr;
    }

    state->type_SearchPaneQueryLinguisticDetails = py::register_python_type(module.get(), type_name_SearchPaneQueryLinguisticDetails, &type_spec_SearchPaneQueryLinguisticDetails, bases.get(), nullptr);
    if (!state->type_SearchPaneQueryLinguisticDetails)
    {
        return nullptr;
    }

    state->type_SearchPaneQuerySubmittedEventArgs = py::register_python_type(module.get(), type_name_SearchPaneQuerySubmittedEventArgs, &type_spec_SearchPaneQuerySubmittedEventArgs, bases.get(), nullptr);
    if (!state->type_SearchPaneQuerySubmittedEventArgs)
    {
        return nullptr;
    }

    state->type_SearchPaneResultSuggestionChosenEventArgs = py::register_python_type(module.get(), type_name_SearchPaneResultSuggestionChosenEventArgs, &type_spec_SearchPaneResultSuggestionChosenEventArgs, bases.get(), nullptr);
    if (!state->type_SearchPaneResultSuggestionChosenEventArgs)
    {
        return nullptr;
    }

    state->type_SearchPaneSuggestionsRequest = py::register_python_type(module.get(), type_name_SearchPaneSuggestionsRequest, &type_spec_SearchPaneSuggestionsRequest, bases.get(), nullptr);
    if (!state->type_SearchPaneSuggestionsRequest)
    {
        return nullptr;
    }

    state->type_SearchPaneSuggestionsRequestDeferral = py::register_python_type(module.get(), type_name_SearchPaneSuggestionsRequestDeferral, &type_spec_SearchPaneSuggestionsRequestDeferral, bases.get(), nullptr);
    if (!state->type_SearchPaneSuggestionsRequestDeferral)
    {
        return nullptr;
    }

    state->type_SearchPaneSuggestionsRequestedEventArgs = py::register_python_type(module.get(), type_name_SearchPaneSuggestionsRequestedEventArgs, &type_spec_SearchPaneSuggestionsRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_SearchPaneSuggestionsRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_SearchPaneVisibilityChangedEventArgs = py::register_python_type(module.get(), type_name_SearchPaneVisibilityChangedEventArgs, &type_spec_SearchPaneVisibilityChangedEventArgs, bases.get(), nullptr);
    if (!state->type_SearchPaneVisibilityChangedEventArgs)
    {
        return nullptr;
    }

    state->type_SearchQueryLinguisticDetails = py::register_python_type(module.get(), type_name_SearchQueryLinguisticDetails, &type_spec_SearchQueryLinguisticDetails, bases.get(), nullptr);
    if (!state->type_SearchQueryLinguisticDetails)
    {
        return nullptr;
    }

    state->type_SearchSuggestionCollection = py::register_python_type(module.get(), type_name_SearchSuggestionCollection, &type_spec_SearchSuggestionCollection, bases.get(), nullptr);
    if (!state->type_SearchSuggestionCollection)
    {
        return nullptr;
    }

    state->type_SearchSuggestionsRequest = py::register_python_type(module.get(), type_name_SearchSuggestionsRequest, &type_spec_SearchSuggestionsRequest, bases.get(), nullptr);
    if (!state->type_SearchSuggestionsRequest)
    {
        return nullptr;
    }

    state->type_SearchSuggestionsRequestDeferral = py::register_python_type(module.get(), type_name_SearchSuggestionsRequestDeferral, &type_spec_SearchSuggestionsRequestDeferral, bases.get(), nullptr);
    if (!state->type_SearchSuggestionsRequestDeferral)
    {
        return nullptr;
    }

    state->type_ISearchPaneQueryChangedEventArgs = py::register_python_type(module.get(), type_name_ISearchPaneQueryChangedEventArgs, &type_spec_ISearchPaneQueryChangedEventArgs, bases.get(), nullptr);
    if (!state->type_ISearchPaneQueryChangedEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LocalContentSuggestionSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::LocalContentSuggestionSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPane>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPane;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPane is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneQueryChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneQueryChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneQueryLinguisticDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneQueryLinguisticDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneQuerySubmittedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneQuerySubmittedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneResultSuggestionChosenEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneResultSuggestionChosenEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneSuggestionsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneSuggestionsRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneSuggestionsRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneSuggestionsRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchPaneVisibilityChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchPaneVisibilityChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchQueryLinguisticDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchQueryLinguisticDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchSuggestionCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchSuggestionCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchSuggestionsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchSuggestionsRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::SearchSuggestionsRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Search;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Search");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISearchPaneQueryChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Search::ISearchPaneQueryChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
