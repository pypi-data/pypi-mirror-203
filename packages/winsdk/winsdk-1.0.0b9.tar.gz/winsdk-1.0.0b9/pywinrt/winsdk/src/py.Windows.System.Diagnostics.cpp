// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.System.Diagnostics.h"


namespace py::cpp::Windows::System::Diagnostics
{
    struct module_state
    {
        PyObject* type_DiagnosticActionState;
        PyTypeObject* type_DiagnosticActionResult;
        PyTypeObject* type_DiagnosticInvoker;
        PyTypeObject* type_ProcessCpuUsage;
        PyTypeObject* type_ProcessCpuUsageReport;
        PyTypeObject* type_ProcessDiagnosticInfo;
        PyTypeObject* type_ProcessDiskUsage;
        PyTypeObject* type_ProcessDiskUsageReport;
        PyTypeObject* type_ProcessMemoryUsage;
        PyTypeObject* type_ProcessMemoryUsageReport;
        PyTypeObject* type_SystemCpuUsage;
        PyTypeObject* type_SystemCpuUsageReport;
        PyTypeObject* type_SystemDiagnosticInfo;
        PyTypeObject* type_SystemMemoryUsage;
        PyTypeObject* type_SystemMemoryUsageReport;
    };

    static PyObject* register_DiagnosticActionState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DiagnosticActionState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DiagnosticActionState = type;
        Py_INCREF(state->type_DiagnosticActionState);


        Py_RETURN_NONE;
    }

    // ----- DiagnosticActionResult class --------------------
    static constexpr const char* const type_name_DiagnosticActionResult = "DiagnosticActionResult";

    static PyObject* _new_DiagnosticActionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DiagnosticActionResult);
        return nullptr;
    }

    static void _dealloc_DiagnosticActionResult(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DiagnosticActionResult_get_ExtendedError(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticActionResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DiagnosticActionResult_get_Results(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticActionResult", L"Results"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Results());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::DiagnosticActionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticActionResult[] = {
        { "_assign_array_", _assign_array_DiagnosticActionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticActionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiagnosticActionResult[] = {
        { "extended_error", reinterpret_cast<getter>(DiagnosticActionResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "results", reinterpret_cast<getter>(DiagnosticActionResult_get_Results), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DiagnosticActionResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiagnosticActionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiagnosticActionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiagnosticActionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiagnosticActionResult) },
        { },
    };

    static PyType_Spec type_spec_DiagnosticActionResult =
    {
        "_winsdk_Windows_System_Diagnostics.DiagnosticActionResult",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticActionResult
    };

    // ----- DiagnosticInvoker class --------------------
    static constexpr const char* const type_name_DiagnosticInvoker = "DiagnosticInvoker";

    static PyObject* _new_DiagnosticInvoker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DiagnosticInvoker);
        return nullptr;
    }

    static void _dealloc_DiagnosticInvoker(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DiagnosticInvoker_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"RunDiagnosticActionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Json::JsonObject>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionFromStringAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"RunDiagnosticActionFromStringAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionFromStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.DiagnosticInvoker", L"IsSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::DiagnosticInvoker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticInvoker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticInvoker[] = {
        { "get_default", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "run_diagnostic_action_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionAsync), METH_VARARGS, nullptr },
        { "run_diagnostic_action_from_string_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionFromStringAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DiagnosticInvoker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticInvoker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiagnosticInvoker[] = {
        { }
    };

    static PyType_Slot _type_slots_DiagnosticInvoker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DiagnosticInvoker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DiagnosticInvoker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DiagnosticInvoker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DiagnosticInvoker) },
        { },
    };

    static PyType_Spec type_spec_DiagnosticInvoker =
    {
        "_winsdk_Windows_System_Diagnostics.DiagnosticInvoker",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticInvoker
    };

    static PyGetSetDef getset_DiagnosticInvoker_Meta[] = {
        { "is_supported", reinterpret_cast<getter>(DiagnosticInvoker_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_DiagnosticInvoker_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DiagnosticInvoker_Meta) },
        { }
    };

    static PyType_Spec type_spec_DiagnosticInvoker_Meta =
    {
        "_winsdk_Windows_System_Diagnostics.DiagnosticInvoker_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DiagnosticInvoker_Meta
    };

    // ----- ProcessCpuUsage class --------------------
    static constexpr const char* const type_name_ProcessCpuUsage = "ProcessCpuUsage";

    static PyObject* _new_ProcessCpuUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessCpuUsage);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessCpuUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessCpuUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessCpuUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessCpuUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessCpuUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessCpuUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessCpuUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessCpuUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessCpuUsage) },
        { },
    };

    static PyType_Spec type_spec_ProcessCpuUsage =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsage
    };

    // ----- ProcessCpuUsageReport class --------------------
    static constexpr const char* const type_name_ProcessCpuUsageReport = "ProcessCpuUsageReport";

    static PyObject* _new_ProcessCpuUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessCpuUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessCpuUsageReport", L"KernelTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessCpuUsageReport", L"UserTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessCpuUsageReport[] = {
        { "kernel_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessCpuUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessCpuUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessCpuUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessCpuUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessCpuUsageReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessCpuUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsageReport
    };

    // ----- ProcessDiagnosticInfo class --------------------
    static constexpr const char* const type_name_ProcessDiagnosticInfo = "ProcessDiagnosticInfo";

    static PyObject* _new_ProcessDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_ProcessDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiagnosticInfo_GetAppDiagnosticInfos(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetAppDiagnosticInfos", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAppDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForCurrentProcess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetForCurrentProcess", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForCurrentProcess());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForProcesses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"GetForProcesses", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForProcesses());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_TryGetForProcessId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"TryGetForProcessId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::TryGetForProcessId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"CpuUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_DiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"DiskUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DiskUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ExecutableFileName(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ExecutableFileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExecutableFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"MemoryUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_Parent(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessId(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessStartTime(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"ProcessStartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_IsPackaged(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiagnosticInfo", L"IsPackaged"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPackaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiagnosticInfo[] = {
        { "get_app_diagnostic_infos", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetAppDiagnosticInfos), METH_VARARGS, nullptr },
        { "get_for_current_process", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForCurrentProcess), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_processes", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForProcesses), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_for_process_id", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_TryGetForProcessId), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_ProcessDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "disk_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_DiskUsage), nullptr, nullptr, nullptr },
        { "executable_file_name", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ExecutableFileName), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_Parent), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessId), nullptr, nullptr, nullptr },
        { "process_start_time", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessStartTime), nullptr, nullptr, nullptr },
        { "is_packaged", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_IsPackaged), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessDiagnosticInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiagnosticInfo) },
        { },
    };

    static PyType_Spec type_spec_ProcessDiagnosticInfo =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiagnosticInfo
    };

    // ----- ProcessDiskUsage class --------------------
    static constexpr const char* const type_name_ProcessDiskUsage = "ProcessDiskUsage";

    static PyObject* _new_ProcessDiskUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessDiskUsage);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiskUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessDiskUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiskUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessDiskUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessDiskUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiskUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessDiskUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiskUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiskUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiskUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiskUsage) },
        { },
    };

    static PyType_Spec type_spec_ProcessDiskUsage =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessDiskUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsage
    };

    // ----- ProcessDiskUsageReport class --------------------
    static constexpr const char* const type_name_ProcessDiskUsageReport = "ProcessDiskUsageReport";

    static PyObject* _new_ProcessDiskUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessDiskUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessDiskUsageReport_get_BytesReadCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"BytesReadCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReadCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_BytesWrittenCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"BytesWrittenCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesWrittenCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherBytesCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"OtherBytesCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherBytesCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"OtherOperationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OtherOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_ReadOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"ReadOperationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_WriteOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessDiskUsageReport", L"WriteOperationCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WriteOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessDiskUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiskUsageReport[] = {
        { "bytes_read_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesReadCount), nullptr, nullptr, nullptr },
        { "bytes_written_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesWrittenCount), nullptr, nullptr, nullptr },
        { "other_bytes_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherBytesCount), nullptr, nullptr, nullptr },
        { "other_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherOperationCount), nullptr, nullptr, nullptr },
        { "read_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_ReadOperationCount), nullptr, nullptr, nullptr },
        { "write_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_WriteOperationCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessDiskUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessDiskUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessDiskUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessDiskUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessDiskUsageReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessDiskUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessDiskUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsageReport
    };

    // ----- ProcessMemoryUsage class --------------------
    static constexpr const char* const type_name_ProcessMemoryUsage = "ProcessMemoryUsage";

    static PyObject* _new_ProcessMemoryUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessMemoryUsage);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.ProcessMemoryUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProcessMemoryUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryUsage) },
        { },
    };

    static PyType_Spec type_spec_ProcessMemoryUsage =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsage
    };

    // ----- ProcessMemoryUsageReport class --------------------
    static constexpr const char* const type_name_ProcessMemoryUsageReport = "ProcessMemoryUsageReport";

    static PyObject* _new_ProcessMemoryUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessMemoryUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"NonPagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFaultCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PageFaultCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageFaultCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PageFileSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakNonPagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakNonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakPageFileSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakPageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakPagedPoolSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakVirtualMemorySizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakVirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PeakWorkingSetSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeakWorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PrivatePageCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"PrivatePageCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrivatePageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"VirtualMemorySizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_WorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.ProcessMemoryUsageReport", L"WorkingSetSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsageReport[] = {
        { "_assign_array_", _assign_array_ProcessMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryUsageReport[] = {
        { "non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "page_fault_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFaultCount), nullptr, nullptr, nullptr },
        { "page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "peak_working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { "private_page_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PrivatePageCount), nullptr, nullptr, nullptr },
        { "virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_WorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessMemoryUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessMemoryUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessMemoryUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessMemoryUsageReport) },
        { },
    };

    static PyType_Spec type_spec_ProcessMemoryUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsageReport
    };

    // ----- SystemCpuUsage class --------------------
    static constexpr const char* const type_name_SystemCpuUsage = "SystemCpuUsage";

    static PyObject* _new_SystemCpuUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemCpuUsage);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsage(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemCpuUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemCpuUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemCpuUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCpuUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemCpuUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCpuUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCpuUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCpuUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCpuUsage) },
        { },
    };

    static PyType_Spec type_spec_SystemCpuUsage =
    {
        "_winsdk_Windows_System_Diagnostics.SystemCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsage
    };

    // ----- SystemCpuUsageReport class --------------------
    static constexpr const char* const type_name_SystemCpuUsageReport = "SystemCpuUsageReport";

    static PyObject* _new_SystemCpuUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemCpuUsageReport);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsageReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemCpuUsageReport_get_IdleTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"IdleTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IdleTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"KernelTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemCpuUsageReport", L"UserTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsageReport[] = {
        { "_assign_array_", _assign_array_SystemCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCpuUsageReport[] = {
        { "idle_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_IdleTime), nullptr, nullptr, nullptr },
        { "kernel_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemCpuUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemCpuUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemCpuUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemCpuUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemCpuUsageReport) },
        { },
    };

    static PyType_Spec type_spec_SystemCpuUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.SystemCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsageReport
    };

    // ----- SystemDiagnosticInfo class --------------------
    static constexpr const char* const type_name_SystemDiagnosticInfo = "SystemDiagnosticInfo";

    static PyObject* _new_SystemDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_SystemDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemDiagnosticInfo_GetForCurrentSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"GetForCurrentSystem", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::GetForCurrentSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_IsArchitectureSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"IsArchitectureSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::ProcessorArchitecture>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::IsArchitectureSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"CpuUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"MemoryUsage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_PreferredArchitecture(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemDiagnosticInfo", L"PreferredArchitecture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::PreferredArchitecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDiagnosticInfo[] = {
        { "get_for_current_system", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_GetForCurrentSystem), METH_VARARGS | METH_STATIC, nullptr },
        { "is_architecture_supported", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_IsArchitectureSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_SystemDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemDiagnosticInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemDiagnosticInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemDiagnosticInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemDiagnosticInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemDiagnosticInfo) },
        { },
    };

    static PyType_Spec type_spec_SystemDiagnosticInfo =
    {
        "_winsdk_Windows_System_Diagnostics.SystemDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDiagnosticInfo
    };

    static PyGetSetDef getset_SystemDiagnosticInfo_Meta[] = {
        { "preferred_architecture", reinterpret_cast<getter>(SystemDiagnosticInfo_get_PreferredArchitecture), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_SystemDiagnosticInfo_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemDiagnosticInfo_Meta) },
        { }
    };

    static PyType_Spec type_spec_SystemDiagnosticInfo_Meta =
    {
        "_winsdk_Windows_System_Diagnostics.SystemDiagnosticInfo_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemDiagnosticInfo_Meta
    };

    // ----- SystemMemoryUsage class --------------------
    static constexpr const char* const type_name_SystemMemoryUsage = "SystemMemoryUsage";

    static PyObject* _new_SystemMemoryUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemMemoryUsage);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Diagnostics.SystemMemoryUsage", L"GetReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemMemoryUsage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemMemoryUsage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMemoryUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemMemoryUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMemoryUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMemoryUsage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMemoryUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMemoryUsage) },
        { },
    };

    static PyType_Spec type_spec_SystemMemoryUsage =
    {
        "_winsdk_Windows_System_Diagnostics.SystemMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsage
    };

    // ----- SystemMemoryUsageReport class --------------------
    static constexpr const char* const type_name_SystemMemoryUsageReport = "SystemMemoryUsageReport";

    static PyObject* _new_SystemMemoryUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SystemMemoryUsageReport);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemMemoryUsageReport_get_AvailableSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"AvailableSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailableSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_CommittedSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"CommittedSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommittedSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Diagnostics.SystemMemoryUsageReport", L"TotalPhysicalSizeInBytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalPhysicalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsageReport[] = {
        { "_assign_array_", _assign_array_SystemMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMemoryUsageReport[] = {
        { "available_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_AvailableSizeInBytes), nullptr, nullptr, nullptr },
        { "committed_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_CommittedSizeInBytes), nullptr, nullptr, nullptr },
        { "total_physical_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMemoryUsageReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemMemoryUsageReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemMemoryUsageReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemMemoryUsageReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemMemoryUsageReport) },
        { },
    };

    static PyType_Spec type_spec_SystemMemoryUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.SystemMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsageReport
    };

    // ----- Windows.System.Diagnostics Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System::Diagnostics");

    static PyMethodDef module_methods[] = {
        {"_register_DiagnosticActionState", register_DiagnosticActionState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_DiagnosticActionState);
        Py_VISIT(state->type_DiagnosticActionResult);
        Py_VISIT(state->type_DiagnosticInvoker);
        Py_VISIT(state->type_ProcessCpuUsage);
        Py_VISIT(state->type_ProcessCpuUsageReport);
        Py_VISIT(state->type_ProcessDiagnosticInfo);
        Py_VISIT(state->type_ProcessDiskUsage);
        Py_VISIT(state->type_ProcessDiskUsageReport);
        Py_VISIT(state->type_ProcessMemoryUsage);
        Py_VISIT(state->type_ProcessMemoryUsageReport);
        Py_VISIT(state->type_SystemCpuUsage);
        Py_VISIT(state->type_SystemCpuUsageReport);
        Py_VISIT(state->type_SystemDiagnosticInfo);
        Py_VISIT(state->type_SystemMemoryUsage);
        Py_VISIT(state->type_SystemMemoryUsageReport);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_DiagnosticActionState);
        Py_CLEAR(state->type_DiagnosticActionResult);
        Py_CLEAR(state->type_DiagnosticInvoker);
        Py_CLEAR(state->type_ProcessCpuUsage);
        Py_CLEAR(state->type_ProcessCpuUsageReport);
        Py_CLEAR(state->type_ProcessDiagnosticInfo);
        Py_CLEAR(state->type_ProcessDiskUsage);
        Py_CLEAR(state->type_ProcessDiskUsageReport);
        Py_CLEAR(state->type_ProcessMemoryUsage);
        Py_CLEAR(state->type_ProcessMemoryUsageReport);
        Py_CLEAR(state->type_SystemCpuUsage);
        Py_CLEAR(state->type_SystemCpuUsageReport);
        Py_CLEAR(state->type_SystemDiagnosticInfo);
        Py_CLEAR(state->type_SystemMemoryUsage);
        Py_CLEAR(state->type_SystemMemoryUsageReport);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_System_Diagnostics",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::System::Diagnostics

PyMODINIT_FUNC PyInit__winsdk_Windows_System_Diagnostics(void) noexcept
{
    using namespace py::cpp::Windows::System::Diagnostics;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_DiagnosticActionResult = py::register_python_type(module.get(), type_name_DiagnosticActionResult, &type_spec_DiagnosticActionResult, bases.get(), nullptr);
    if (!state->type_DiagnosticActionResult)
    {
        return nullptr;
    }

    py::pyobj_handle type_DiagnosticInvoker_Meta{PyType_FromSpec(&type_spec_DiagnosticInvoker_Meta)};
    if (!type_DiagnosticInvoker_Meta)
    {
        return nullptr;
    }

    state->type_DiagnosticInvoker = py::register_python_type(module.get(), type_name_DiagnosticInvoker, &type_spec_DiagnosticInvoker, bases.get(), reinterpret_cast<PyTypeObject*>(type_DiagnosticInvoker_Meta.get()));
    if (!state->type_DiagnosticInvoker)
    {
        return nullptr;
    }

    state->type_ProcessCpuUsage = py::register_python_type(module.get(), type_name_ProcessCpuUsage, &type_spec_ProcessCpuUsage, bases.get(), nullptr);
    if (!state->type_ProcessCpuUsage)
    {
        return nullptr;
    }

    state->type_ProcessCpuUsageReport = py::register_python_type(module.get(), type_name_ProcessCpuUsageReport, &type_spec_ProcessCpuUsageReport, bases.get(), nullptr);
    if (!state->type_ProcessCpuUsageReport)
    {
        return nullptr;
    }

    state->type_ProcessDiagnosticInfo = py::register_python_type(module.get(), type_name_ProcessDiagnosticInfo, &type_spec_ProcessDiagnosticInfo, bases.get(), nullptr);
    if (!state->type_ProcessDiagnosticInfo)
    {
        return nullptr;
    }

    state->type_ProcessDiskUsage = py::register_python_type(module.get(), type_name_ProcessDiskUsage, &type_spec_ProcessDiskUsage, bases.get(), nullptr);
    if (!state->type_ProcessDiskUsage)
    {
        return nullptr;
    }

    state->type_ProcessDiskUsageReport = py::register_python_type(module.get(), type_name_ProcessDiskUsageReport, &type_spec_ProcessDiskUsageReport, bases.get(), nullptr);
    if (!state->type_ProcessDiskUsageReport)
    {
        return nullptr;
    }

    state->type_ProcessMemoryUsage = py::register_python_type(module.get(), type_name_ProcessMemoryUsage, &type_spec_ProcessMemoryUsage, bases.get(), nullptr);
    if (!state->type_ProcessMemoryUsage)
    {
        return nullptr;
    }

    state->type_ProcessMemoryUsageReport = py::register_python_type(module.get(), type_name_ProcessMemoryUsageReport, &type_spec_ProcessMemoryUsageReport, bases.get(), nullptr);
    if (!state->type_ProcessMemoryUsageReport)
    {
        return nullptr;
    }

    state->type_SystemCpuUsage = py::register_python_type(module.get(), type_name_SystemCpuUsage, &type_spec_SystemCpuUsage, bases.get(), nullptr);
    if (!state->type_SystemCpuUsage)
    {
        return nullptr;
    }

    state->type_SystemCpuUsageReport = py::register_python_type(module.get(), type_name_SystemCpuUsageReport, &type_spec_SystemCpuUsageReport, bases.get(), nullptr);
    if (!state->type_SystemCpuUsageReport)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemDiagnosticInfo_Meta{PyType_FromSpec(&type_spec_SystemDiagnosticInfo_Meta)};
    if (!type_SystemDiagnosticInfo_Meta)
    {
        return nullptr;
    }

    state->type_SystemDiagnosticInfo = py::register_python_type(module.get(), type_name_SystemDiagnosticInfo, &type_spec_SystemDiagnosticInfo, bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemDiagnosticInfo_Meta.get()));
    if (!state->type_SystemDiagnosticInfo)
    {
        return nullptr;
    }

    state->type_SystemMemoryUsage = py::register_python_type(module.get(), type_name_SystemMemoryUsage, &type_spec_SystemMemoryUsage, bases.get(), nullptr);
    if (!state->type_SystemMemoryUsage)
    {
        return nullptr;
    }

    state->type_SystemMemoryUsageReport = py::register_python_type(module.get(), type_name_SystemMemoryUsageReport, &type_spec_SystemMemoryUsageReport, bases.get(), nullptr);
    if (!state->type_SystemMemoryUsageReport)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::System::Diagnostics::DiagnosticActionState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DiagnosticActionState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::DiagnosticActionState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DiagnosticActionResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::DiagnosticActionResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DiagnosticInvoker;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::DiagnosticInvoker is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessCpuUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessCpuUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessCpuUsageReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessCpuUsageReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessDiagnosticInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessDiskUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessDiskUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessDiskUsageReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessDiskUsageReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessMemoryUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessMemoryUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessMemoryUsageReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemCpuUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::SystemCpuUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemCpuUsageReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::SystemCpuUsageReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemDiagnosticInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::SystemDiagnosticInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMemoryUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::SystemMemoryUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::System::Diagnostics;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::System::Diagnostics");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SystemMemoryUsageReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::System::Diagnostics::SystemMemoryUsageReport is not registered");
        return nullptr;
    }

    return python_type;
}
