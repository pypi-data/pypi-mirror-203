// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Devices.Input.h"


PyObject* py::converter<winrt::Windows::Devices::Input::MouseDelta>::convert(winrt::Windows::Devices::Input::MouseDelta instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Devices::Input::MouseDelta>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Devices::Input::MouseDelta py::converter<winrt::Windows::Devices::Input::MouseDelta>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Devices::Input::MouseDelta>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Input::MouseDelta>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Devices::Input::MouseDelta");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Devices::Input::PointerDeviceUsage>::convert(winrt::Windows::Devices::Input::PointerDeviceUsage instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Devices::Input::PointerDeviceUsage>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Devices::Input::PointerDeviceUsage py::converter<winrt::Windows::Devices::Input::PointerDeviceUsage>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Devices::Input::PointerDeviceUsage>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Input::PointerDeviceUsage>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Devices::Input::PointerDeviceUsage");
    throw python_exception();
}

namespace py::cpp::Windows::Devices::Input
{
    struct module_state
    {
        PyObject* type_PointerDeviceType;
        PyTypeObject* type_KeyboardCapabilities;
        PyTypeObject* type_MouseCapabilities;
        PyTypeObject* type_MouseDevice;
        PyTypeObject* type_MouseEventArgs;
        PyTypeObject* type_PenButtonListener;
        PyTypeObject* type_PenDevice;
        PyTypeObject* type_PenDockListener;
        PyTypeObject* type_PenDockedEventArgs;
        PyTypeObject* type_PenTailButtonClickedEventArgs;
        PyTypeObject* type_PenTailButtonDoubleClickedEventArgs;
        PyTypeObject* type_PenTailButtonLongPressedEventArgs;
        PyTypeObject* type_PenUndockedEventArgs;
        PyTypeObject* type_PointerDevice;
        PyTypeObject* type_TouchCapabilities;
        PyTypeObject* type_MouseDelta;
        PyTypeObject* type_PointerDeviceUsage;
    };

    static PyObject* register_PointerDeviceType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PointerDeviceType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PointerDeviceType = type;
        Py_INCREF(state->type_PointerDeviceType);


        Py_RETURN_NONE;
    }

    // ----- KeyboardCapabilities class --------------------
    static constexpr const char* const type_name_KeyboardCapabilities = "KeyboardCapabilities";

    static PyObject* _new_KeyboardCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::KeyboardCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeyboardCapabilities(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardCapabilities_get_KeyboardPresent(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.KeyboardCapabilities", L"KeyboardPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyboardPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::KeyboardCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::KeyboardCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardCapabilities[] = {
        { "_assign_array_", _assign_array_KeyboardCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyboardCapabilities[] = {
        { "keyboard_present", reinterpret_cast<getter>(KeyboardCapabilities_get_KeyboardPresent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyboardCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardCapabilities) },
        { },
    };

    static PyType_Spec type_spec_KeyboardCapabilities =
    {
        "_winsdk_Windows_Devices_Input.KeyboardCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::KeyboardCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardCapabilities
    };

    // ----- MouseCapabilities class --------------------
    static constexpr const char* const type_name_MouseCapabilities = "MouseCapabilities";

    static PyObject* _new_MouseCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::MouseCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MouseCapabilities(py::wrapper::Windows::Devices::Input::MouseCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseCapabilities_get_HorizontalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"HorizontalWheelPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalWheelPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_MousePresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"MousePresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MousePresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_NumberOfButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"NumberOfButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberOfButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_SwapButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"SwapButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SwapButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_VerticalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseCapabilities", L"VerticalWheelPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalWheelPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseCapabilities[] = {
        { "_assign_array_", _assign_array_MouseCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MouseCapabilities[] = {
        { "horizontal_wheel_present", reinterpret_cast<getter>(MouseCapabilities_get_HorizontalWheelPresent), nullptr, nullptr, nullptr },
        { "mouse_present", reinterpret_cast<getter>(MouseCapabilities_get_MousePresent), nullptr, nullptr, nullptr },
        { "number_of_buttons", reinterpret_cast<getter>(MouseCapabilities_get_NumberOfButtons), nullptr, nullptr, nullptr },
        { "swap_buttons", reinterpret_cast<getter>(MouseCapabilities_get_SwapButtons), nullptr, nullptr, nullptr },
        { "vertical_wheel_present", reinterpret_cast<getter>(MouseCapabilities_get_VerticalWheelPresent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MouseCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseCapabilities) },
        { },
    };

    static PyType_Spec type_spec_MouseCapabilities =
    {
        "_winsdk_Windows_Devices_Input.MouseCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::MouseCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseCapabilities
    };

    // ----- MouseDevice class --------------------
    static constexpr const char* const type_name_MouseDevice = "MouseDevice";

    static PyObject* _new_MouseDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MouseDevice);
        return nullptr;
    }

    static void _dealloc_MouseDevice(py::wrapper::Windows::Devices::Input::MouseDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseDevice_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.MouseDevice", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::MouseDevice::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MouseDevice_add_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.MouseDevice", L"MouseMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::MouseDevice, winrt::Windows::Devices::Input::MouseEventArgs>>(arg);

            return py::convert(self->obj.MouseMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseDevice_remove_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.MouseDevice", L"MouseMoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MouseMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseDevice[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(MouseDevice_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "add_mouse_moved", reinterpret_cast<PyCFunction>(MouseDevice_add_MouseMoved), METH_O, nullptr },
        { "remove_mouse_moved", reinterpret_cast<PyCFunction>(MouseDevice_remove_MouseMoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_MouseDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MouseDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_MouseDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseDevice) },
        { },
    };

    static PyType_Spec type_spec_MouseDevice =
    {
        "_winsdk_Windows_Devices_Input.MouseDevice",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDevice
    };

    // ----- MouseEventArgs class --------------------
    static constexpr const char* const type_name_MouseEventArgs = "MouseEventArgs";

    static PyObject* _new_MouseEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MouseEventArgs);
        return nullptr;
    }

    static void _dealloc_MouseEventArgs(py::wrapper::Windows::Devices::Input::MouseEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseEventArgs_get_MouseDelta(py::wrapper::Windows::Devices::Input::MouseEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.MouseEventArgs", L"MouseDelta"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MouseDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::MouseEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseEventArgs[] = {
        { "_assign_array_", _assign_array_MouseEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MouseEventArgs[] = {
        { "mouse_delta", reinterpret_cast<getter>(MouseEventArgs_get_MouseDelta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MouseEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MouseEventArgs =
    {
        "_winsdk_Windows_Devices_Input.MouseEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::MouseEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseEventArgs
    };

    // ----- PenButtonListener class --------------------
    static constexpr const char* const type_name_PenButtonListener = "PenButtonListener";

    static PyObject* _new_PenButtonListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenButtonListener);
        return nullptr;
    }

    static void _dealloc_PenButtonListener(py::wrapper::Windows::Devices::Input::PenButtonListener* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenButtonListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenButtonListener", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::PenButtonListener::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_IsSupported(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonDoubleClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonDoubleClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonDoubleClicked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonDoubleClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonLongPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonLongPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenButtonListener", L"TailButtonLongPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonLongPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenButtonListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenButtonListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenButtonListener[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenButtonListener_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(PenButtonListener_IsSupported), METH_VARARGS, nullptr },
        { "add_is_supported_changed", reinterpret_cast<PyCFunction>(PenButtonListener_add_IsSupportedChanged), METH_O, nullptr },
        { "remove_is_supported_changed", reinterpret_cast<PyCFunction>(PenButtonListener_remove_IsSupportedChanged), METH_O, nullptr },
        { "add_tail_button_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonClicked), METH_O, nullptr },
        { "remove_tail_button_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonClicked), METH_O, nullptr },
        { "add_tail_button_double_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonDoubleClicked), METH_O, nullptr },
        { "remove_tail_button_double_clicked", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonDoubleClicked), METH_O, nullptr },
        { "add_tail_button_long_pressed", reinterpret_cast<PyCFunction>(PenButtonListener_add_TailButtonLongPressed), METH_O, nullptr },
        { "remove_tail_button_long_pressed", reinterpret_cast<PyCFunction>(PenButtonListener_remove_TailButtonLongPressed), METH_O, nullptr },
        { "_assign_array_", _assign_array_PenButtonListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenButtonListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenButtonListener[] = {
        { }
    };

    static PyType_Slot _type_slots_PenButtonListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenButtonListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenButtonListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenButtonListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenButtonListener) },
        { },
    };

    static PyType_Spec type_spec_PenButtonListener =
    {
        "_winsdk_Windows_Devices_Input.PenButtonListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenButtonListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenButtonListener
    };

    // ----- PenDevice class --------------------
    static constexpr const char* const type_name_PenDevice = "PenDevice";

    static PyObject* _new_PenDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenDevice);
        return nullptr;
    }

    static void _dealloc_PenDevice(py::wrapper::Windows::Devices::Input::PenDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenDevice_GetFromPointerId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDevice", L"GetFromPointerId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Input::PenDevice::GetFromPointerId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_PenId(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PenDevice", L"PenId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_SimpleHapticsController(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PenDevice", L"SimpleHapticsController"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDevice[] = {
        { "get_from_pointer_id", reinterpret_cast<PyCFunction>(PenDevice_GetFromPointerId), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_PenDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenDevice[] = {
        { "pen_id", reinterpret_cast<getter>(PenDevice_get_PenId), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(PenDevice_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PenDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDevice) },
        { },
    };

    static PyType_Spec type_spec_PenDevice =
    {
        "_winsdk_Windows_Devices_Input.PenDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PenDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDevice
    };

    // ----- PenDockListener class --------------------
    static constexpr const char* const type_name_PenDockListener = "PenDockListener";

    static PyObject* _new_PenDockListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenDockListener);
        return nullptr;
    }

    static void _dealloc_PenDockListener(py::wrapper::Windows::Devices::Input::PenDockListener* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PenDockListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDockListener", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::PenDockListener::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_IsSupported(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Docked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenDockedEventArgs>>(arg);

            return py::convert(self->obj.Docked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Docked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Docked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"IsSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Undocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenUndockedEventArgs>>(arg);

            return py::convert(self->obj.Undocked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Input.PenDockListener", L"Undocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Undocked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDockListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockListener[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenDockListener_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(PenDockListener_IsSupported), METH_VARARGS, nullptr },
        { "add_docked", reinterpret_cast<PyCFunction>(PenDockListener_add_Docked), METH_O, nullptr },
        { "remove_docked", reinterpret_cast<PyCFunction>(PenDockListener_remove_Docked), METH_O, nullptr },
        { "add_is_supported_changed", reinterpret_cast<PyCFunction>(PenDockListener_add_IsSupportedChanged), METH_O, nullptr },
        { "remove_is_supported_changed", reinterpret_cast<PyCFunction>(PenDockListener_remove_IsSupportedChanged), METH_O, nullptr },
        { "add_undocked", reinterpret_cast<PyCFunction>(PenDockListener_add_Undocked), METH_O, nullptr },
        { "remove_undocked", reinterpret_cast<PyCFunction>(PenDockListener_remove_Undocked), METH_O, nullptr },
        { "_assign_array_", _assign_array_PenDockListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDockListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenDockListener[] = {
        { }
    };

    static PyType_Slot _type_slots_PenDockListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDockListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDockListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDockListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDockListener) },
        { },
    };

    static PyType_Spec type_spec_PenDockListener =
    {
        "_winsdk_Windows_Devices_Input.PenDockListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockListener
    };

    // ----- PenDockedEventArgs class --------------------
    static constexpr const char* const type_name_PenDockedEventArgs = "PenDockedEventArgs";

    static PyObject* _new_PenDockedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenDockedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenDockedEventArgs(py::wrapper::Windows::Devices::Input::PenDockedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenDockedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockedEventArgs[] = {
        { "_assign_array_", _assign_array_PenDockedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenDockedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenDockedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenDockedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenDockedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenDockedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenDockedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenDockedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenDockedEventArgs =
    {
        "_winsdk_Windows_Devices_Input.PenDockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockedEventArgs
    };

    // ----- PenTailButtonClickedEventArgs class --------------------
    static constexpr const char* const type_name_PenTailButtonClickedEventArgs = "PenTailButtonClickedEventArgs";

    static PyObject* _new_PenTailButtonClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenTailButtonClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenTailButtonClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonClickedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenTailButtonClickedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenTailButtonClickedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonClickedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenTailButtonClickedEventArgs =
    {
        "_winsdk_Windows_Devices_Input.PenTailButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonClickedEventArgs
    };

    // ----- PenTailButtonDoubleClickedEventArgs class --------------------
    static constexpr const char* const type_name_PenTailButtonDoubleClickedEventArgs = "PenTailButtonDoubleClickedEventArgs";

    static PyObject* _new_PenTailButtonDoubleClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenTailButtonDoubleClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenTailButtonDoubleClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonDoubleClickedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonDoubleClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonDoubleClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenTailButtonDoubleClickedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenTailButtonDoubleClickedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonDoubleClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonDoubleClickedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenTailButtonDoubleClickedEventArgs =
    {
        "_winsdk_Windows_Devices_Input.PenTailButtonDoubleClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonDoubleClickedEventArgs
    };

    // ----- PenTailButtonLongPressedEventArgs class --------------------
    static constexpr const char* const type_name_PenTailButtonLongPressedEventArgs = "PenTailButtonLongPressedEventArgs";

    static PyObject* _new_PenTailButtonLongPressedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenTailButtonLongPressedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenTailButtonLongPressedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonLongPressedEventArgs[] = {
        { "_assign_array_", _assign_array_PenTailButtonLongPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenTailButtonLongPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenTailButtonLongPressedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenTailButtonLongPressedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenTailButtonLongPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenTailButtonLongPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenTailButtonLongPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenTailButtonLongPressedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenTailButtonLongPressedEventArgs =
    {
        "_winsdk_Windows_Devices_Input.PenTailButtonLongPressedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonLongPressedEventArgs
    };

    // ----- PenUndockedEventArgs class --------------------
    static constexpr const char* const type_name_PenUndockedEventArgs = "PenUndockedEventArgs";

    static PyObject* _new_PenUndockedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PenUndockedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenUndockedEventArgs(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PenUndockedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenUndockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenUndockedEventArgs[] = {
        { "_assign_array_", _assign_array_PenUndockedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenUndockedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenUndockedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PenUndockedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PenUndockedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PenUndockedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PenUndockedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PenUndockedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PenUndockedEventArgs =
    {
        "_winsdk_Windows_Devices_Input.PenUndockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenUndockedEventArgs
    };

    // ----- PointerDevice class --------------------
    static constexpr const char* const type_name_PointerDevice = "PointerDevice";

    static PyObject* _new_PointerDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PointerDevice);
        return nullptr;
    }

    static void _dealloc_PointerDevice(py::wrapper::Windows::Devices::Input::PointerDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerDevice_GetPointerDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PointerDevice", L"GetPointerDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Input::PointerDevice::GetPointerDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_GetPointerDevices(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Input.PointerDevice", L"GetPointerDevices", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Input::PointerDevice::GetPointerDevices());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_IsIntegrated(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"IsIntegrated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIntegrated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxContacts(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"MaxContacts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PhysicalDeviceRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"PhysicalDeviceRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalDeviceRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PointerDeviceType(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"PointerDeviceType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_ScreenRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"ScreenRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScreenRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_SupportedUsages(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"SupportedUsages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxPointersWithZDistance(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.PointerDevice", L"MaxPointersWithZDistance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPointersWithZDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::PointerDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PointerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerDevice[] = {
        { "get_pointer_device", reinterpret_cast<PyCFunction>(PointerDevice_GetPointerDevice), METH_VARARGS | METH_STATIC, nullptr },
        { "get_pointer_devices", reinterpret_cast<PyCFunction>(PointerDevice_GetPointerDevices), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_PointerDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointerDevice[] = {
        { "is_integrated", reinterpret_cast<getter>(PointerDevice_get_IsIntegrated), nullptr, nullptr, nullptr },
        { "max_contacts", reinterpret_cast<getter>(PointerDevice_get_MaxContacts), nullptr, nullptr, nullptr },
        { "physical_device_rect", reinterpret_cast<getter>(PointerDevice_get_PhysicalDeviceRect), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(PointerDevice_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "screen_rect", reinterpret_cast<getter>(PointerDevice_get_ScreenRect), nullptr, nullptr, nullptr },
        { "supported_usages", reinterpret_cast<getter>(PointerDevice_get_SupportedUsages), nullptr, nullptr, nullptr },
        { "max_pointers_with_z_distance", reinterpret_cast<getter>(PointerDevice_get_MaxPointersWithZDistance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDevice) },
        { },
    };

    static PyType_Spec type_spec_PointerDevice =
    {
        "_winsdk_Windows_Devices_Input.PointerDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDevice
    };

    // ----- TouchCapabilities class --------------------
    static constexpr const char* const type_name_TouchCapabilities = "TouchCapabilities";

    static PyObject* _new_TouchCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::TouchCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TouchCapabilities(py::wrapper::Windows::Devices::Input::TouchCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchCapabilities_get_Contacts(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.TouchCapabilities", L"Contacts"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchCapabilities_get_TouchPresent(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Input.TouchCapabilities", L"TouchPresent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Input::TouchCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::TouchCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchCapabilities[] = {
        { "_assign_array_", _assign_array_TouchCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TouchCapabilities[] = {
        { "contacts", reinterpret_cast<getter>(TouchCapabilities_get_Contacts), nullptr, nullptr, nullptr },
        { "touch_present", reinterpret_cast<getter>(TouchCapabilities_get_TouchPresent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TouchCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchCapabilities) },
        { },
    };

    static PyType_Spec type_spec_TouchCapabilities =
    {
        "_winsdk_Windows_Devices_Input.TouchCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::TouchCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchCapabilities
    };

    // ----- MouseDelta struct --------------------
    static constexpr const char* const type_name_MouseDelta = "MouseDelta";

    PyObject* _new_MouseDelta(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Input::MouseDelta return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _X{};
        int32_t _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Input::MouseDelta return_value{ _X, _Y };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self) noexcept
    {
    }

    static PyObject* MouseDelta_get_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseDelta_set_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseDelta_get_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseDelta_set_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MouseDelta[] = {
        { "x", reinterpret_cast<getter>(MouseDelta_get_X), reinterpret_cast<setter>(MouseDelta_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MouseDelta_get_Y), reinterpret_cast<setter>(MouseDelta_set_Y), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MouseDelta[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseDelta) },
        { },
    };

    static PyType_Spec type_spec_MouseDelta =
    {
        "_winsdk_Windows_Devices_Input.MouseDelta",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDelta
    };

    // ----- PointerDeviceUsage struct --------------------
    static constexpr const char* const type_name_PointerDeviceUsage = "PointerDeviceUsage";

    PyObject* _new_PointerDeviceUsage(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Input::PointerDeviceUsage return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _UsagePage{};
        uint32_t _Usage{};
        int32_t _MinLogical{};
        int32_t _MaxLogical{};
        int32_t _MinPhysical{};
        int32_t _MaxPhysical{};
        uint32_t _Unit{};
        float _PhysicalMultiplier{};

        static const char* kwlist[] = {"usage_page", "usage", "min_logical", "max_logical", "min_physical", "max_physical", "unit", "physical_multiplier", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIiiiiIf", const_cast<char**>(kwlist), &_UsagePage, &_Usage, &_MinLogical, &_MaxLogical, &_MinPhysical, &_MaxPhysical, &_Unit, &_PhysicalMultiplier))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Input::PointerDeviceUsage return_value{ _UsagePage, _Usage, _MinLogical, _MaxLogical, _MinPhysical, _MaxPhysical, _Unit, _PhysicalMultiplier };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self) noexcept
    {
    }

    static PyObject* PointerDeviceUsage_get_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsagePage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.UsagePage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Usage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Usage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MinLogical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MaxLogical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MinPhysical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.MaxPhysical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalMultiplier);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PhysicalMultiplier = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PointerDeviceUsage[] = {
        { "usage_page", reinterpret_cast<getter>(PointerDeviceUsage_get_UsagePage), reinterpret_cast<setter>(PointerDeviceUsage_set_UsagePage), nullptr, nullptr },
        { "usage", reinterpret_cast<getter>(PointerDeviceUsage_get_Usage), reinterpret_cast<setter>(PointerDeviceUsage_set_Usage), nullptr, nullptr },
        { "min_logical", reinterpret_cast<getter>(PointerDeviceUsage_get_MinLogical), reinterpret_cast<setter>(PointerDeviceUsage_set_MinLogical), nullptr, nullptr },
        { "max_logical", reinterpret_cast<getter>(PointerDeviceUsage_get_MaxLogical), reinterpret_cast<setter>(PointerDeviceUsage_set_MaxLogical), nullptr, nullptr },
        { "min_physical", reinterpret_cast<getter>(PointerDeviceUsage_get_MinPhysical), reinterpret_cast<setter>(PointerDeviceUsage_set_MinPhysical), nullptr, nullptr },
        { "max_physical", reinterpret_cast<getter>(PointerDeviceUsage_get_MaxPhysical), reinterpret_cast<setter>(PointerDeviceUsage_set_MaxPhysical), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(PointerDeviceUsage_get_Unit), reinterpret_cast<setter>(PointerDeviceUsage_set_Unit), nullptr, nullptr },
        { "physical_multiplier", reinterpret_cast<getter>(PointerDeviceUsage_get_PhysicalMultiplier), reinterpret_cast<setter>(PointerDeviceUsage_set_PhysicalMultiplier), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointerDeviceUsage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerDeviceUsage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerDeviceUsage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerDeviceUsage) },
        { },
    };

    static PyType_Spec type_spec_PointerDeviceUsage =
    {
        "_winsdk_Windows_Devices_Input.PointerDeviceUsage",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDeviceUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDeviceUsage
    };

    // ----- Windows.Devices.Input Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Input");

    static PyMethodDef module_methods[] = {
        {"_register_PointerDeviceType", register_PointerDeviceType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PointerDeviceType);
        Py_VISIT(state->type_KeyboardCapabilities);
        Py_VISIT(state->type_MouseCapabilities);
        Py_VISIT(state->type_MouseDevice);
        Py_VISIT(state->type_MouseEventArgs);
        Py_VISIT(state->type_PenButtonListener);
        Py_VISIT(state->type_PenDevice);
        Py_VISIT(state->type_PenDockListener);
        Py_VISIT(state->type_PenDockedEventArgs);
        Py_VISIT(state->type_PenTailButtonClickedEventArgs);
        Py_VISIT(state->type_PenTailButtonDoubleClickedEventArgs);
        Py_VISIT(state->type_PenTailButtonLongPressedEventArgs);
        Py_VISIT(state->type_PenUndockedEventArgs);
        Py_VISIT(state->type_PointerDevice);
        Py_VISIT(state->type_TouchCapabilities);
        Py_VISIT(state->type_MouseDelta);
        Py_VISIT(state->type_PointerDeviceUsage);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PointerDeviceType);
        Py_CLEAR(state->type_KeyboardCapabilities);
        Py_CLEAR(state->type_MouseCapabilities);
        Py_CLEAR(state->type_MouseDevice);
        Py_CLEAR(state->type_MouseEventArgs);
        Py_CLEAR(state->type_PenButtonListener);
        Py_CLEAR(state->type_PenDevice);
        Py_CLEAR(state->type_PenDockListener);
        Py_CLEAR(state->type_PenDockedEventArgs);
        Py_CLEAR(state->type_PenTailButtonClickedEventArgs);
        Py_CLEAR(state->type_PenTailButtonDoubleClickedEventArgs);
        Py_CLEAR(state->type_PenTailButtonLongPressedEventArgs);
        Py_CLEAR(state->type_PenUndockedEventArgs);
        Py_CLEAR(state->type_PointerDevice);
        Py_CLEAR(state->type_TouchCapabilities);
        Py_CLEAR(state->type_MouseDelta);
        Py_CLEAR(state->type_PointerDeviceUsage);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Input",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Input

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Input(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Input;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_KeyboardCapabilities = py::register_python_type(module.get(), type_name_KeyboardCapabilities, &type_spec_KeyboardCapabilities, bases.get(), nullptr);
    if (!state->type_KeyboardCapabilities)
    {
        return nullptr;
    }

    state->type_MouseCapabilities = py::register_python_type(module.get(), type_name_MouseCapabilities, &type_spec_MouseCapabilities, bases.get(), nullptr);
    if (!state->type_MouseCapabilities)
    {
        return nullptr;
    }

    state->type_MouseDevice = py::register_python_type(module.get(), type_name_MouseDevice, &type_spec_MouseDevice, bases.get(), nullptr);
    if (!state->type_MouseDevice)
    {
        return nullptr;
    }

    state->type_MouseEventArgs = py::register_python_type(module.get(), type_name_MouseEventArgs, &type_spec_MouseEventArgs, bases.get(), nullptr);
    if (!state->type_MouseEventArgs)
    {
        return nullptr;
    }

    state->type_PenButtonListener = py::register_python_type(module.get(), type_name_PenButtonListener, &type_spec_PenButtonListener, bases.get(), nullptr);
    if (!state->type_PenButtonListener)
    {
        return nullptr;
    }

    state->type_PenDevice = py::register_python_type(module.get(), type_name_PenDevice, &type_spec_PenDevice, bases.get(), nullptr);
    if (!state->type_PenDevice)
    {
        return nullptr;
    }

    state->type_PenDockListener = py::register_python_type(module.get(), type_name_PenDockListener, &type_spec_PenDockListener, bases.get(), nullptr);
    if (!state->type_PenDockListener)
    {
        return nullptr;
    }

    state->type_PenDockedEventArgs = py::register_python_type(module.get(), type_name_PenDockedEventArgs, &type_spec_PenDockedEventArgs, bases.get(), nullptr);
    if (!state->type_PenDockedEventArgs)
    {
        return nullptr;
    }

    state->type_PenTailButtonClickedEventArgs = py::register_python_type(module.get(), type_name_PenTailButtonClickedEventArgs, &type_spec_PenTailButtonClickedEventArgs, bases.get(), nullptr);
    if (!state->type_PenTailButtonClickedEventArgs)
    {
        return nullptr;
    }

    state->type_PenTailButtonDoubleClickedEventArgs = py::register_python_type(module.get(), type_name_PenTailButtonDoubleClickedEventArgs, &type_spec_PenTailButtonDoubleClickedEventArgs, bases.get(), nullptr);
    if (!state->type_PenTailButtonDoubleClickedEventArgs)
    {
        return nullptr;
    }

    state->type_PenTailButtonLongPressedEventArgs = py::register_python_type(module.get(), type_name_PenTailButtonLongPressedEventArgs, &type_spec_PenTailButtonLongPressedEventArgs, bases.get(), nullptr);
    if (!state->type_PenTailButtonLongPressedEventArgs)
    {
        return nullptr;
    }

    state->type_PenUndockedEventArgs = py::register_python_type(module.get(), type_name_PenUndockedEventArgs, &type_spec_PenUndockedEventArgs, bases.get(), nullptr);
    if (!state->type_PenUndockedEventArgs)
    {
        return nullptr;
    }

    state->type_PointerDevice = py::register_python_type(module.get(), type_name_PointerDevice, &type_spec_PointerDevice, bases.get(), nullptr);
    if (!state->type_PointerDevice)
    {
        return nullptr;
    }

    state->type_TouchCapabilities = py::register_python_type(module.get(), type_name_TouchCapabilities, &type_spec_TouchCapabilities, bases.get(), nullptr);
    if (!state->type_TouchCapabilities)
    {
        return nullptr;
    }

    state->type_MouseDelta = py::register_python_type(module.get(), type_name_MouseDelta, &type_spec_MouseDelta, bases.get(), nullptr);
    if (!state->type_MouseDelta)
    {
        return nullptr;
    }

    state->type_PointerDeviceUsage = py::register_python_type(module.get(), type_name_PointerDeviceUsage, &type_spec_PointerDeviceUsage, bases.get(), nullptr);
    if (!state->type_PointerDeviceUsage)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Input::PointerDeviceType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PointerDeviceType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PointerDeviceType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::KeyboardCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyboardCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::KeyboardCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MouseCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::MouseCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MouseDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::MouseDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MouseEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::MouseEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenButtonListener>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenButtonListener;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenButtonListener is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenDockListener>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenDockListener;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenDockListener is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenDockedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenDockedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenTailButtonClickedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenTailButtonDoubleClickedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenTailButtonLongPressedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PenUndockedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PenUndockedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PointerDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PointerDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PointerDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::TouchCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TouchCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::TouchCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseDelta>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MouseDelta;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::MouseDelta is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PointerDeviceUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PointerDeviceUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Input::PointerDeviceUsage is not registered");
        return nullptr;
    }

    return python_type;
}
