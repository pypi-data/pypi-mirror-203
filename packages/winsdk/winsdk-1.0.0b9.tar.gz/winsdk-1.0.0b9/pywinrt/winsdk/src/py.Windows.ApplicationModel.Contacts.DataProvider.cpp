// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.ApplicationModel.Contacts.DataProvider.h"


namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider
{
    struct module_state
    {
        PyTypeObject* type_ContactDataProviderConnection;
        PyTypeObject* type_ContactDataProviderTriggerDetails;
        PyTypeObject* type_ContactListCreateOrUpdateContactRequest;
        PyTypeObject* type_ContactListCreateOrUpdateContactRequestEventArgs;
        PyTypeObject* type_ContactListDeleteContactRequest;
        PyTypeObject* type_ContactListDeleteContactRequestEventArgs;
        PyTypeObject* type_ContactListServerSearchReadBatchRequest;
        PyTypeObject* type_ContactListServerSearchReadBatchRequestEventArgs;
        PyTypeObject* type_ContactListSyncManagerSyncRequest;
        PyTypeObject* type_ContactListSyncManagerSyncRequestEventArgs;
    };

    // ----- ContactDataProviderConnection class --------------------
    static constexpr const char* const type_name_ContactDataProviderConnection = "ContactDataProviderConnection";

    static PyObject* _new_ContactDataProviderConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactDataProviderConnection);
        return nullptr;
    }

    static void _dealloc_ContactDataProviderConnection(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactDataProviderConnection_Start(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"ServerSearchReadBatchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>>(arg);

            return py::convert(self->obj.ServerSearchReadBatchRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_ServerSearchReadBatchRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"ServerSearchReadBatchRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerSearchReadBatchRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_SyncRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"SyncRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>>(arg);

            return py::convert(self->obj.SyncRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_SyncRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"SyncRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_CreateOrUpdateContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"CreateOrUpdateContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>>(arg);

            return py::convert(self->obj.CreateOrUpdateContactRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_CreateOrUpdateContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"CreateOrUpdateContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CreateOrUpdateContactRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_add_DeleteContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"DeleteContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection, winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>>(arg);

            return py::convert(self->obj.DeleteContactRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactDataProviderConnection_remove_DeleteContactRequested(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderConnection", L"DeleteContactRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeleteContactRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactDataProviderConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDataProviderConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_Start), METH_VARARGS, nullptr },
        { "add_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "remove_server_search_read_batch_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_ServerSearchReadBatchRequested), METH_O, nullptr },
        { "add_sync_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_SyncRequested), METH_O, nullptr },
        { "remove_sync_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_SyncRequested), METH_O, nullptr },
        { "add_create_or_update_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_CreateOrUpdateContactRequested), METH_O, nullptr },
        { "remove_create_or_update_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_CreateOrUpdateContactRequested), METH_O, nullptr },
        { "add_delete_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_add_DeleteContactRequested), METH_O, nullptr },
        { "remove_delete_contact_requested", reinterpret_cast<PyCFunction>(ContactDataProviderConnection_remove_DeleteContactRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContactDataProviderConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactDataProviderConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactDataProviderConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactDataProviderConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactDataProviderConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactDataProviderConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactDataProviderConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactDataProviderConnection) },
        { },
    };

    static PyType_Spec type_spec_ContactDataProviderConnection =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactDataProviderConnection",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDataProviderConnection
    };

    // ----- ContactDataProviderTriggerDetails class --------------------
    static constexpr const char* const type_name_ContactDataProviderTriggerDetails = "ContactDataProviderTriggerDetails";

    static PyObject* _new_ContactDataProviderTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactDataProviderTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ContactDataProviderTriggerDetails(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactDataProviderTriggerDetails_get_Connection(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactDataProviderTriggerDetails", L"Connection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactDataProviderTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDataProviderTriggerDetails[] = {
        { "_assign_array_", _assign_array_ContactDataProviderTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactDataProviderTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactDataProviderTriggerDetails[] = {
        { "connection", reinterpret_cast<getter>(ContactDataProviderTriggerDetails_get_Connection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactDataProviderTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactDataProviderTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactDataProviderTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactDataProviderTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactDataProviderTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ContactDataProviderTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactDataProviderTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDataProviderTriggerDetails
    };

    // ----- ContactListCreateOrUpdateContactRequest class --------------------
    static constexpr const char* const type_name_ContactListCreateOrUpdateContactRequest = "ContactListCreateOrUpdateContactRequest";

    static PyObject* _new_ContactListCreateOrUpdateContactRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListCreateOrUpdateContactRequest);
        return nullptr;
    }

    static void _dealloc_ContactListCreateOrUpdateContactRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"ReportCompletedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.ReportCompletedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_get_Contact(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListCreateOrUpdateContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListCreateOrUpdateContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListCreateOrUpdateContactRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListCreateOrUpdateContactRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListCreateOrUpdateContactRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListCreateOrUpdateContactRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListCreateOrUpdateContactRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListCreateOrUpdateContactRequest[] = {
        { "contact", reinterpret_cast<getter>(ContactListCreateOrUpdateContactRequest_get_Contact), nullptr, nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(ContactListCreateOrUpdateContactRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListCreateOrUpdateContactRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListCreateOrUpdateContactRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListCreateOrUpdateContactRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListCreateOrUpdateContactRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListCreateOrUpdateContactRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListCreateOrUpdateContactRequest =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListCreateOrUpdateContactRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListCreateOrUpdateContactRequest
    };

    // ----- ContactListCreateOrUpdateContactRequestEventArgs class --------------------
    static constexpr const char* const type_name_ContactListCreateOrUpdateContactRequestEventArgs = "ContactListCreateOrUpdateContactRequestEventArgs";

    static PyObject* _new_ContactListCreateOrUpdateContactRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListCreateOrUpdateContactRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactListCreateOrUpdateContactRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListCreateOrUpdateContactRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListCreateOrUpdateContactRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListCreateOrUpdateContactRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListCreateOrUpdateContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListCreateOrUpdateContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListCreateOrUpdateContactRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListCreateOrUpdateContactRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListCreateOrUpdateContactRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListCreateOrUpdateContactRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListCreateOrUpdateContactRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListCreateOrUpdateContactRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListCreateOrUpdateContactRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListCreateOrUpdateContactRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListCreateOrUpdateContactRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListCreateOrUpdateContactRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListCreateOrUpdateContactRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListCreateOrUpdateContactRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListCreateOrUpdateContactRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListCreateOrUpdateContactRequestEventArgs
    };

    // ----- ContactListDeleteContactRequest class --------------------
    static constexpr const char* const type_name_ContactListDeleteContactRequest = "ContactListDeleteContactRequest";

    static PyObject* _new_ContactListDeleteContactRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListDeleteContactRequest);
        return nullptr;
    }

    static void _dealloc_ContactListDeleteContactRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListDeleteContactRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequest_get_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListDeleteContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListDeleteContactRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListDeleteContactRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListDeleteContactRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListDeleteContactRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListDeleteContactRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListDeleteContactRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListDeleteContactRequest[] = {
        { "contact_id", reinterpret_cast<getter>(ContactListDeleteContactRequest_get_ContactId), nullptr, nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(ContactListDeleteContactRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListDeleteContactRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListDeleteContactRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListDeleteContactRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListDeleteContactRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListDeleteContactRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListDeleteContactRequest =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListDeleteContactRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListDeleteContactRequest
    };

    // ----- ContactListDeleteContactRequestEventArgs class --------------------
    static constexpr const char* const type_name_ContactListDeleteContactRequestEventArgs = "ContactListDeleteContactRequestEventArgs";

    static PyObject* _new_ContactListDeleteContactRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListDeleteContactRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactListDeleteContactRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListDeleteContactRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListDeleteContactRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListDeleteContactRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListDeleteContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListDeleteContactRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListDeleteContactRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListDeleteContactRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListDeleteContactRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListDeleteContactRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListDeleteContactRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListDeleteContactRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListDeleteContactRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListDeleteContactRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListDeleteContactRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListDeleteContactRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListDeleteContactRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListDeleteContactRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListDeleteContactRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListDeleteContactRequestEventArgs
    };

    // ----- ContactListServerSearchReadBatchRequest class --------------------
    static constexpr const char* const type_name_ContactListServerSearchReadBatchRequest = "ContactListServerSearchReadBatchRequest";

    static PyObject* _new_ContactListServerSearchReadBatchRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListServerSearchReadBatchRequest);
        return nullptr;
    }

    static void _dealloc_ContactListServerSearchReadBatchRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListServerSearchReadBatchRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"ReportFailedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactBatchStatus>(args, 0);

                return py::convert(self->obj.ReportFailedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_SaveContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"SaveContactAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.SaveContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_Options(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"Options"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_SessionId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"SessionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequest_get_SuggestedBatchSize(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequest", L"SuggestedBatchSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuggestedBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListServerSearchReadBatchRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListServerSearchReadBatchRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "save_contact_async", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequest_SaveContactAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListServerSearchReadBatchRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListServerSearchReadBatchRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListServerSearchReadBatchRequest[] = {
        { "contact_list_id", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { "options", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_Options), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_SessionId), nullptr, nullptr, nullptr },
        { "suggested_batch_size", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequest_get_SuggestedBatchSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListServerSearchReadBatchRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListServerSearchReadBatchRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListServerSearchReadBatchRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListServerSearchReadBatchRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListServerSearchReadBatchRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListServerSearchReadBatchRequest =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListServerSearchReadBatchRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListServerSearchReadBatchRequest
    };

    // ----- ContactListServerSearchReadBatchRequestEventArgs class --------------------
    static constexpr const char* const type_name_ContactListServerSearchReadBatchRequestEventArgs = "ContactListServerSearchReadBatchRequestEventArgs";

    static PyObject* _new_ContactListServerSearchReadBatchRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListServerSearchReadBatchRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactListServerSearchReadBatchRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListServerSearchReadBatchRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListServerSearchReadBatchRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListServerSearchReadBatchRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListServerSearchReadBatchRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListServerSearchReadBatchRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListServerSearchReadBatchRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListServerSearchReadBatchRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListServerSearchReadBatchRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListServerSearchReadBatchRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListServerSearchReadBatchRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListServerSearchReadBatchRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListServerSearchReadBatchRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListServerSearchReadBatchRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListServerSearchReadBatchRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListServerSearchReadBatchRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListServerSearchReadBatchRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListServerSearchReadBatchRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListServerSearchReadBatchRequestEventArgs
    };

    // ----- ContactListSyncManagerSyncRequest class --------------------
    static constexpr const char* const type_name_ContactListSyncManagerSyncRequest = "ContactListSyncManagerSyncRequest";

    static PyObject* _new_ContactListSyncManagerSyncRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListSyncManagerSyncRequest);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManagerSyncRequest(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListSyncManagerSyncRequest_ReportCompletedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequest", L"ReportCompletedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportCompletedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManagerSyncRequest_ReportFailedAsync(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequest", L"ReportFailedAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReportFailedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManagerSyncRequest_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequest", L"ContactListId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListSyncManagerSyncRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManagerSyncRequest[] = {
        { "report_completed_async", reinterpret_cast<PyCFunction>(ContactListSyncManagerSyncRequest_ReportCompletedAsync), METH_VARARGS, nullptr },
        { "report_failed_async", reinterpret_cast<PyCFunction>(ContactListSyncManagerSyncRequest_ReportFailedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListSyncManagerSyncRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncManagerSyncRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncManagerSyncRequest[] = {
        { "contact_list_id", reinterpret_cast<getter>(ContactListSyncManagerSyncRequest_get_ContactListId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncManagerSyncRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListSyncManagerSyncRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListSyncManagerSyncRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListSyncManagerSyncRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListSyncManagerSyncRequest) },
        { },
    };

    static PyType_Spec type_spec_ContactListSyncManagerSyncRequest =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListSyncManagerSyncRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManagerSyncRequest
    };

    // ----- ContactListSyncManagerSyncRequestEventArgs class --------------------
    static constexpr const char* const type_name_ContactListSyncManagerSyncRequestEventArgs = "ContactListSyncManagerSyncRequestEventArgs";

    static PyObject* _new_ContactListSyncManagerSyncRequestEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactListSyncManagerSyncRequestEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManagerSyncRequestEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactListSyncManagerSyncRequestEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequestEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManagerSyncRequestEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Contacts.DataProvider.ContactListSyncManagerSyncRequestEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContactListSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContactListSyncManagerSyncRequestEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManagerSyncRequestEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactListSyncManagerSyncRequestEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContactListSyncManagerSyncRequestEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncManagerSyncRequestEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncManagerSyncRequestEventArgs[] = {
        { "request", reinterpret_cast<getter>(ContactListSyncManagerSyncRequestEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncManagerSyncRequestEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContactListSyncManagerSyncRequestEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContactListSyncManagerSyncRequestEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContactListSyncManagerSyncRequestEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContactListSyncManagerSyncRequestEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContactListSyncManagerSyncRequestEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts_DataProvider.ContactListSyncManagerSyncRequestEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManagerSyncRequestEventArgs
    };

    // ----- Windows.ApplicationModel.Contacts.DataProvider Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Contacts::DataProvider");

    static PyMethodDef module_methods[] = {
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ContactDataProviderConnection);
        Py_VISIT(state->type_ContactDataProviderTriggerDetails);
        Py_VISIT(state->type_ContactListCreateOrUpdateContactRequest);
        Py_VISIT(state->type_ContactListCreateOrUpdateContactRequestEventArgs);
        Py_VISIT(state->type_ContactListDeleteContactRequest);
        Py_VISIT(state->type_ContactListDeleteContactRequestEventArgs);
        Py_VISIT(state->type_ContactListServerSearchReadBatchRequest);
        Py_VISIT(state->type_ContactListServerSearchReadBatchRequestEventArgs);
        Py_VISIT(state->type_ContactListSyncManagerSyncRequest);
        Py_VISIT(state->type_ContactListSyncManagerSyncRequestEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ContactDataProviderConnection);
        Py_CLEAR(state->type_ContactDataProviderTriggerDetails);
        Py_CLEAR(state->type_ContactListCreateOrUpdateContactRequest);
        Py_CLEAR(state->type_ContactListCreateOrUpdateContactRequestEventArgs);
        Py_CLEAR(state->type_ContactListDeleteContactRequest);
        Py_CLEAR(state->type_ContactListDeleteContactRequestEventArgs);
        Py_CLEAR(state->type_ContactListServerSearchReadBatchRequest);
        Py_CLEAR(state->type_ContactListServerSearchReadBatchRequestEventArgs);
        Py_CLEAR(state->type_ContactListSyncManagerSyncRequest);
        Py_CLEAR(state->type_ContactListSyncManagerSyncRequestEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Contacts_DataProvider",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Contacts::DataProvider

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Contacts_DataProvider(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ContactDataProviderConnection = py::register_python_type(module.get(), type_name_ContactDataProviderConnection, &type_spec_ContactDataProviderConnection, bases.get(), nullptr);
    if (!state->type_ContactDataProviderConnection)
    {
        return nullptr;
    }

    state->type_ContactDataProviderTriggerDetails = py::register_python_type(module.get(), type_name_ContactDataProviderTriggerDetails, &type_spec_ContactDataProviderTriggerDetails, bases.get(), nullptr);
    if (!state->type_ContactDataProviderTriggerDetails)
    {
        return nullptr;
    }

    state->type_ContactListCreateOrUpdateContactRequest = py::register_python_type(module.get(), type_name_ContactListCreateOrUpdateContactRequest, &type_spec_ContactListCreateOrUpdateContactRequest, bases.get(), nullptr);
    if (!state->type_ContactListCreateOrUpdateContactRequest)
    {
        return nullptr;
    }

    state->type_ContactListCreateOrUpdateContactRequestEventArgs = py::register_python_type(module.get(), type_name_ContactListCreateOrUpdateContactRequestEventArgs, &type_spec_ContactListCreateOrUpdateContactRequestEventArgs, bases.get(), nullptr);
    if (!state->type_ContactListCreateOrUpdateContactRequestEventArgs)
    {
        return nullptr;
    }

    state->type_ContactListDeleteContactRequest = py::register_python_type(module.get(), type_name_ContactListDeleteContactRequest, &type_spec_ContactListDeleteContactRequest, bases.get(), nullptr);
    if (!state->type_ContactListDeleteContactRequest)
    {
        return nullptr;
    }

    state->type_ContactListDeleteContactRequestEventArgs = py::register_python_type(module.get(), type_name_ContactListDeleteContactRequestEventArgs, &type_spec_ContactListDeleteContactRequestEventArgs, bases.get(), nullptr);
    if (!state->type_ContactListDeleteContactRequestEventArgs)
    {
        return nullptr;
    }

    state->type_ContactListServerSearchReadBatchRequest = py::register_python_type(module.get(), type_name_ContactListServerSearchReadBatchRequest, &type_spec_ContactListServerSearchReadBatchRequest, bases.get(), nullptr);
    if (!state->type_ContactListServerSearchReadBatchRequest)
    {
        return nullptr;
    }

    state->type_ContactListServerSearchReadBatchRequestEventArgs = py::register_python_type(module.get(), type_name_ContactListServerSearchReadBatchRequestEventArgs, &type_spec_ContactListServerSearchReadBatchRequestEventArgs, bases.get(), nullptr);
    if (!state->type_ContactListServerSearchReadBatchRequestEventArgs)
    {
        return nullptr;
    }

    state->type_ContactListSyncManagerSyncRequest = py::register_python_type(module.get(), type_name_ContactListSyncManagerSyncRequest, &type_spec_ContactListSyncManagerSyncRequest, bases.get(), nullptr);
    if (!state->type_ContactListSyncManagerSyncRequest)
    {
        return nullptr;
    }

    state->type_ContactListSyncManagerSyncRequestEventArgs = py::register_python_type(module.get(), type_name_ContactListSyncManagerSyncRequestEventArgs, &type_spec_ContactListSyncManagerSyncRequestEventArgs, bases.get(), nullptr);
    if (!state->type_ContactListSyncManagerSyncRequestEventArgs)
    {
        return nullptr;
    }


    return module.detach();
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactDataProviderConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactDataProviderTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactDataProviderTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListCreateOrUpdateContactRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListCreateOrUpdateContactRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListCreateOrUpdateContactRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListDeleteContactRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListDeleteContactRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListDeleteContactRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListServerSearchReadBatchRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListServerSearchReadBatchRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListServerSearchReadBatchRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListSyncManagerSyncRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Contacts::DataProvider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Contacts::DataProvider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactListSyncManagerSyncRequestEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Contacts::DataProvider::ContactListSyncManagerSyncRequestEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
