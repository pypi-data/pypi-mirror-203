// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.UI.Input.Preview.Injection.h"


PyObject* py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert(winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::convert(winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::convert(winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle");
    throw python_exception();
}

namespace py::cpp::Windows::UI::Input::Preview::Injection
{
    struct module_state
    {
        PyObject* type_InjectedInputButtonChangeKind;
        PyObject* type_InjectedInputKeyOptions;
        PyObject* type_InjectedInputMouseOptions;
        PyObject* type_InjectedInputPenButtons;
        PyObject* type_InjectedInputPenParameters;
        PyObject* type_InjectedInputPointerOptions;
        PyObject* type_InjectedInputShortcut;
        PyObject* type_InjectedInputTouchParameters;
        PyObject* type_InjectedInputVisualizationMode;
        PyTypeObject* type_InjectedInputGamepadInfo;
        PyTypeObject* type_InjectedInputKeyboardInfo;
        PyTypeObject* type_InjectedInputMouseInfo;
        PyTypeObject* type_InjectedInputPenInfo;
        PyTypeObject* type_InjectedInputTouchInfo;
        PyTypeObject* type_InputInjector;
        PyTypeObject* type_InjectedInputPoint;
        PyTypeObject* type_InjectedInputPointerInfo;
        PyTypeObject* type_InjectedInputRectangle;
    };

    static PyObject* register_InjectedInputButtonChangeKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputButtonChangeKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputButtonChangeKind = type;
        Py_INCREF(state->type_InjectedInputButtonChangeKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputKeyOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputKeyOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputKeyOptions = type;
        Py_INCREF(state->type_InjectedInputKeyOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputMouseOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputMouseOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputMouseOptions = type;
        Py_INCREF(state->type_InjectedInputMouseOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputPenButtons(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputPenButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputPenButtons = type;
        Py_INCREF(state->type_InjectedInputPenButtons);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputPenParameters(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputPenParameters)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputPenParameters = type;
        Py_INCREF(state->type_InjectedInputPenParameters);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputPointerOptions(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputPointerOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputPointerOptions = type;
        Py_INCREF(state->type_InjectedInputPointerOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputShortcut(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputShortcut)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputShortcut = type;
        Py_INCREF(state->type_InjectedInputShortcut);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputTouchParameters(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputTouchParameters)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputTouchParameters = type;
        Py_INCREF(state->type_InjectedInputTouchParameters);


        Py_RETURN_NONE;
    }

    static PyObject* register_InjectedInputVisualizationMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_InjectedInputVisualizationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_InjectedInputVisualizationMode = type;
        Py_INCREF(state->type_InjectedInputVisualizationMode);


        Py_RETURN_NONE;
    }

    // ----- InjectedInputGamepadInfo class --------------------
    static constexpr const char* const type_name_InjectedInputGamepadInfo = "InjectedInputGamepadInfo";

    static PyObject* _new_InjectedInputGamepadInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadReading>(args, 0);

                winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputGamepadInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputGamepadInfo_get_RightTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_RightThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightThumbstickY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_RightThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightThumbstickX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftThumbstickY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftThumbstickX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_Buttons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"Buttons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Buttons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_Buttons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"Buttons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(arg);

            self->obj.Buttons(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputGamepadInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputGamepadInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputGamepadInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputGamepadInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputGamepadInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputGamepadInfo[] = {
        { "right_trigger", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightTrigger), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightTrigger), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightThumbstickY), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightThumbstickX), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightThumbstickX), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftTrigger), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftTrigger), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftThumbstickY), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftThumbstickY), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftThumbstickX), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftThumbstickX), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_Buttons), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_Buttons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputGamepadInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputGamepadInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputGamepadInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputGamepadInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputGamepadInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputGamepadInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputGamepadInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputGamepadInfo
    };

    // ----- InjectedInputKeyboardInfo class --------------------
    static constexpr const char* const type_name_InjectedInputKeyboardInfo = "InjectedInputKeyboardInfo";

    static PyObject* _new_InjectedInputKeyboardInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputKeyboardInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputKeyboardInfo_get_VirtualKey(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_VirtualKey(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint16_t>(arg);

            self->obj.VirtualKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputKeyboardInfo_get_ScanCode(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"ScanCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_ScanCode(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"ScanCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint16_t>(arg);

            self->obj.ScanCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputKeyboardInfo_get_KeyOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"KeyOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_KeyOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"KeyOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyOptions>(arg);

            self->obj.KeyOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputKeyboardInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputKeyboardInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputKeyboardInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputKeyboardInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputKeyboardInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputKeyboardInfo[] = {
        { "virtual_key", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_VirtualKey), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_VirtualKey), nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_ScanCode), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_ScanCode), nullptr, nullptr },
        { "key_options", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_KeyOptions), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_KeyOptions), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputKeyboardInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputKeyboardInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputKeyboardInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputKeyboardInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputKeyboardInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputKeyboardInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputKeyboardInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputKeyboardInfo
    };

    // ----- InjectedInputMouseInfo class --------------------
    static constexpr const char* const type_name_InjectedInputMouseInfo = "InjectedInputMouseInfo";

    static PyObject* _new_InjectedInputMouseInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputMouseInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputMouseInfo_get_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"TimeOffsetInMilliseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeOffsetInMilliseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"TimeOffsetInMilliseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TimeOffsetInMilliseconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_MouseOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MouseOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_MouseOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseOptions>(arg);

            self->obj.MouseOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_MouseData(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MouseData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_MouseData(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MouseData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_DeltaY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeltaY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_DeltaY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DeltaY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_DeltaX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeltaX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_DeltaX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DeltaX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputMouseInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputMouseInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputMouseInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputMouseInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputMouseInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputMouseInfo[] = {
        { "time_offset_in_milliseconds", reinterpret_cast<getter>(InjectedInputMouseInfo_get_TimeOffsetInMilliseconds), reinterpret_cast<setter>(InjectedInputMouseInfo_put_TimeOffsetInMilliseconds), nullptr, nullptr },
        { "mouse_options", reinterpret_cast<getter>(InjectedInputMouseInfo_get_MouseOptions), reinterpret_cast<setter>(InjectedInputMouseInfo_put_MouseOptions), nullptr, nullptr },
        { "mouse_data", reinterpret_cast<getter>(InjectedInputMouseInfo_get_MouseData), reinterpret_cast<setter>(InjectedInputMouseInfo_put_MouseData), nullptr, nullptr },
        { "delta_y", reinterpret_cast<getter>(InjectedInputMouseInfo_get_DeltaY), reinterpret_cast<setter>(InjectedInputMouseInfo_put_DeltaY), nullptr, nullptr },
        { "delta_x", reinterpret_cast<getter>(InjectedInputMouseInfo_get_DeltaX), reinterpret_cast<setter>(InjectedInputMouseInfo_put_DeltaX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputMouseInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputMouseInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputMouseInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputMouseInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputMouseInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputMouseInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputMouseInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputMouseInfo
    };

    // ----- InjectedInputPenInfo class --------------------
    static constexpr const char* const type_name_InjectedInputPenInfo = "InjectedInputPenInfo";

    static PyObject* _new_InjectedInputPenInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPenInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputPenInfo_get_TiltY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_TiltY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TiltY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_TiltX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_TiltX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TiltX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_Rotation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_Rotation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);

            self->obj.PointerInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PenParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PenParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenParameters>(arg);

            self->obj.PenParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PenButtons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PenButtons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenButtons>(arg);

            self->obj.PenButtons(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputPenInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputPenInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputPenInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputPenInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputPenInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputPenInfo[] = {
        { "tilt_y", reinterpret_cast<getter>(InjectedInputPenInfo_get_TiltY), reinterpret_cast<setter>(InjectedInputPenInfo_put_TiltY), nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InjectedInputPenInfo_get_TiltX), reinterpret_cast<setter>(InjectedInputPenInfo_put_TiltX), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(InjectedInputPenInfo_get_Rotation), reinterpret_cast<setter>(InjectedInputPenInfo_put_Rotation), nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InjectedInputPenInfo_get_Pressure), reinterpret_cast<setter>(InjectedInputPenInfo_put_Pressure), nullptr, nullptr },
        { "pointer_info", reinterpret_cast<getter>(InjectedInputPenInfo_get_PointerInfo), reinterpret_cast<setter>(InjectedInputPenInfo_put_PointerInfo), nullptr, nullptr },
        { "pen_parameters", reinterpret_cast<getter>(InjectedInputPenInfo_get_PenParameters), reinterpret_cast<setter>(InjectedInputPenInfo_put_PenParameters), nullptr, nullptr },
        { "pen_buttons", reinterpret_cast<getter>(InjectedInputPenInfo_get_PenButtons), reinterpret_cast<setter>(InjectedInputPenInfo_put_PenButtons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPenInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputPenInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputPenInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputPenInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputPenInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputPenInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputPenInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPenInfo
    };

    // ----- InjectedInputTouchInfo class --------------------
    static constexpr const char* const type_name_InjectedInputTouchInfo = "InjectedInputTouchInfo";

    static PyObject* _new_InjectedInputTouchInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputTouchInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputTouchInfo_get_TouchParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"TouchParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_TouchParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"TouchParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchParameters>(arg);

            self->obj.TouchParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);

            self->obj.PointerInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Orientation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Orientation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Contact(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Contact(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputTouchInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputTouchInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputTouchInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputTouchInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputTouchInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputTouchInfo[] = {
        { "touch_parameters", reinterpret_cast<getter>(InjectedInputTouchInfo_get_TouchParameters), reinterpret_cast<setter>(InjectedInputTouchInfo_put_TouchParameters), nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Pressure), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Pressure), nullptr, nullptr },
        { "pointer_info", reinterpret_cast<getter>(InjectedInputTouchInfo_get_PointerInfo), reinterpret_cast<setter>(InjectedInputTouchInfo_put_PointerInfo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Orientation), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Orientation), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Contact), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Contact), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputTouchInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputTouchInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputTouchInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputTouchInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputTouchInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputTouchInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputTouchInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputTouchInfo
    };

    // ----- InputInjector class --------------------
    static constexpr const char* const type_name_InputInjector = "InputInjector";

    static PyObject* _new_InputInjector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InputInjector);
        return nullptr;
    }

    static void _dealloc_InputInjector(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputInjector_InitializeGamepadInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InitializeGamepadInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.InitializeGamepadInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InitializePenInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InitializePenInjection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>(args, 0);

                self->obj.InitializePenInjection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InitializeTouchInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InitializeTouchInjection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>(args, 0);

                self->obj.InitializeTouchInjection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectGamepadInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectGamepadInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>(args, 0);

                self->obj.InjectGamepadInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectKeyboardInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectKeyboardInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>>(args, 0);

                self->obj.InjectKeyboardInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectMouseInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectMouseInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>>(args, 0);

                self->obj.InjectMouseInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectPenInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectPenInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>(args, 0);

                self->obj.InjectPenInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectShortcut(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectShortcut", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputShortcut>(args, 0);

                self->obj.InjectShortcut(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectTouchInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectTouchInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>>(args, 0);

                self->obj.InjectTouchInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_TryCreate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"TryCreate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Input::Preview::Injection::InputInjector::TryCreate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_TryCreateForAppBroadcastOnly(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"TryCreateForAppBroadcastOnly", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Input::Preview::Injection::InputInjector::TryCreateForAppBroadcastOnly());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializeGamepadInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"UninitializeGamepadInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UninitializeGamepadInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializePenInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"UninitializePenInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UninitializePenInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializeTouchInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"UninitializeTouchInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UninitializeTouchInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputInjector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InputInjector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputInjector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InputInjector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputInjector[] = {
        { "initialize_gamepad_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializeGamepadInjection), METH_VARARGS, nullptr },
        { "initialize_pen_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializePenInjection), METH_VARARGS, nullptr },
        { "initialize_touch_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializeTouchInjection), METH_VARARGS, nullptr },
        { "inject_gamepad_input", reinterpret_cast<PyCFunction>(InputInjector_InjectGamepadInput), METH_VARARGS, nullptr },
        { "inject_keyboard_input", reinterpret_cast<PyCFunction>(InputInjector_InjectKeyboardInput), METH_VARARGS, nullptr },
        { "inject_mouse_input", reinterpret_cast<PyCFunction>(InputInjector_InjectMouseInput), METH_VARARGS, nullptr },
        { "inject_pen_input", reinterpret_cast<PyCFunction>(InputInjector_InjectPenInput), METH_VARARGS, nullptr },
        { "inject_shortcut", reinterpret_cast<PyCFunction>(InputInjector_InjectShortcut), METH_VARARGS, nullptr },
        { "inject_touch_input", reinterpret_cast<PyCFunction>(InputInjector_InjectTouchInput), METH_VARARGS, nullptr },
        { "try_create", reinterpret_cast<PyCFunction>(InputInjector_TryCreate), METH_VARARGS | METH_STATIC, nullptr },
        { "try_create_for_app_broadcast_only", reinterpret_cast<PyCFunction>(InputInjector_TryCreateForAppBroadcastOnly), METH_VARARGS | METH_STATIC, nullptr },
        { "uninitialize_gamepad_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializeGamepadInjection), METH_VARARGS, nullptr },
        { "uninitialize_pen_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializePenInjection), METH_VARARGS, nullptr },
        { "uninitialize_touch_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializeTouchInjection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InputInjector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputInjector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputInjector[] = {
        { }
    };

    static PyType_Slot _type_slots_InputInjector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputInjector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputInjector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputInjector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputInjector) },
        { },
    };

    static PyType_Spec type_spec_InputInjector =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InputInjector",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputInjector
    };

    // ----- InjectedInputPoint struct --------------------
    static constexpr const char* const type_name_InjectedInputPoint = "InjectedInputPoint";

    PyObject* _new_InjectedInputPoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _PositionX{};
        int32_t _PositionY{};

        static const char* kwlist[] = {"position_x", "position_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_PositionX, &_PositionY))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint return_value{ _PositionX, _PositionY };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPoint(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self) noexcept
    {
    }

    static PyObject* InjectedInputPoint_get_PositionX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPoint_set_PositionX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PositionX = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPoint_get_PositionY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPoint_set_PositionY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PositionY = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputPoint[] = {
        { "position_x", reinterpret_cast<getter>(InjectedInputPoint_get_PositionX), reinterpret_cast<setter>(InjectedInputPoint_set_PositionX), nullptr, nullptr },
        { "position_y", reinterpret_cast<getter>(InjectedInputPoint_get_PositionY), reinterpret_cast<setter>(InjectedInputPoint_set_PositionY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputPoint) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputPoint =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputPoint",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPoint
    };

    // ----- InjectedInputPointerInfo struct --------------------
    static constexpr const char* const type_name_InjectedInputPointerInfo = "InjectedInputPointerInfo";

    PyObject* _new_InjectedInputPointerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _PointerId{};
        uint32_t _PointerOptions{};
        PyObject* _PixelLocation{};
        uint32_t _TimeOffsetInMilliseconds{};
        uint64_t _PerformanceCount{};

        static const char* kwlist[] = {"pointer_id", "pointer_options", "pixel_location", "time_offset_in_milliseconds", "performance_count", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIOIK", const_cast<char**>(kwlist), &_PointerId, &_PointerOptions, &_PixelLocation, &_TimeOffsetInMilliseconds, &_PerformanceCount))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo return_value{ _PointerId, static_cast<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>(_PointerOptions), py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(_PixelLocation), _TimeOffsetInMilliseconds, _PerformanceCount };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self) noexcept
    {
    }

    static PyObject* InjectedInputPointerInfo_get_PointerId(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PointerId(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PointerId = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PointerOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerOptions);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PointerOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PointerOptions = py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PixelLocation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelLocation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PixelLocation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PixelLocation = py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeOffsetInMilliseconds);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TimeOffsetInMilliseconds = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PerformanceCount(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PerformanceCount(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PerformanceCount = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputPointerInfo[] = {
        { "pointer_id", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PointerId), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PointerId), nullptr, nullptr },
        { "pointer_options", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PointerOptions), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PointerOptions), nullptr, nullptr },
        { "pixel_location", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PixelLocation), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PixelLocation), nullptr, nullptr },
        { "time_offset_in_milliseconds", reinterpret_cast<getter>(InjectedInputPointerInfo_get_TimeOffsetInMilliseconds), reinterpret_cast<setter>(InjectedInputPointerInfo_set_TimeOffsetInMilliseconds), nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PerformanceCount), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PerformanceCount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPointerInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputPointerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputPointerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputPointerInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputPointerInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputPointerInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPointerInfo
    };

    // ----- InjectedInputRectangle struct --------------------
    static constexpr const char* const type_name_InjectedInputRectangle = "InjectedInputRectangle";

    PyObject* _new_InjectedInputRectangle(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _Left{};
        int32_t _Top{};
        int32_t _Bottom{};
        int32_t _Right{};

        static const char* kwlist[] = {"left", "top", "bottom", "right", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_Left, &_Top, &_Bottom, &_Right))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle return_value{ _Left, _Top, _Bottom, _Right };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputRectangle(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self) noexcept
    {
    }

    static PyObject* InjectedInputRectangle_get_Left(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Left);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Left(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Left = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Top(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Top);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Top(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Top = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Bottom(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bottom);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Bottom(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Bottom = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Right(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Right);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Right(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Right = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputRectangle[] = {
        { "left", reinterpret_cast<getter>(InjectedInputRectangle_get_Left), reinterpret_cast<setter>(InjectedInputRectangle_set_Left), nullptr, nullptr },
        { "top", reinterpret_cast<getter>(InjectedInputRectangle_get_Top), reinterpret_cast<setter>(InjectedInputRectangle_set_Top), nullptr, nullptr },
        { "bottom", reinterpret_cast<getter>(InjectedInputRectangle_get_Bottom), reinterpret_cast<setter>(InjectedInputRectangle_set_Bottom), nullptr, nullptr },
        { "right", reinterpret_cast<getter>(InjectedInputRectangle_get_Right), reinterpret_cast<setter>(InjectedInputRectangle_set_Right), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputRectangle[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputRectangle) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputRectangle) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputRectangle) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputRectangle =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputRectangle",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputRectangle
    };

    // ----- Windows.UI.Input.Preview.Injection Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Input::Preview::Injection");

    static PyMethodDef module_methods[] = {
        {"_register_InjectedInputButtonChangeKind", register_InjectedInputButtonChangeKind, METH_O, "registers type"},
        {"_register_InjectedInputKeyOptions", register_InjectedInputKeyOptions, METH_O, "registers type"},
        {"_register_InjectedInputMouseOptions", register_InjectedInputMouseOptions, METH_O, "registers type"},
        {"_register_InjectedInputPenButtons", register_InjectedInputPenButtons, METH_O, "registers type"},
        {"_register_InjectedInputPenParameters", register_InjectedInputPenParameters, METH_O, "registers type"},
        {"_register_InjectedInputPointerOptions", register_InjectedInputPointerOptions, METH_O, "registers type"},
        {"_register_InjectedInputShortcut", register_InjectedInputShortcut, METH_O, "registers type"},
        {"_register_InjectedInputTouchParameters", register_InjectedInputTouchParameters, METH_O, "registers type"},
        {"_register_InjectedInputVisualizationMode", register_InjectedInputVisualizationMode, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_InjectedInputButtonChangeKind);
        Py_VISIT(state->type_InjectedInputKeyOptions);
        Py_VISIT(state->type_InjectedInputMouseOptions);
        Py_VISIT(state->type_InjectedInputPenButtons);
        Py_VISIT(state->type_InjectedInputPenParameters);
        Py_VISIT(state->type_InjectedInputPointerOptions);
        Py_VISIT(state->type_InjectedInputShortcut);
        Py_VISIT(state->type_InjectedInputTouchParameters);
        Py_VISIT(state->type_InjectedInputVisualizationMode);
        Py_VISIT(state->type_InjectedInputGamepadInfo);
        Py_VISIT(state->type_InjectedInputKeyboardInfo);
        Py_VISIT(state->type_InjectedInputMouseInfo);
        Py_VISIT(state->type_InjectedInputPenInfo);
        Py_VISIT(state->type_InjectedInputTouchInfo);
        Py_VISIT(state->type_InputInjector);
        Py_VISIT(state->type_InjectedInputPoint);
        Py_VISIT(state->type_InjectedInputPointerInfo);
        Py_VISIT(state->type_InjectedInputRectangle);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_InjectedInputButtonChangeKind);
        Py_CLEAR(state->type_InjectedInputKeyOptions);
        Py_CLEAR(state->type_InjectedInputMouseOptions);
        Py_CLEAR(state->type_InjectedInputPenButtons);
        Py_CLEAR(state->type_InjectedInputPenParameters);
        Py_CLEAR(state->type_InjectedInputPointerOptions);
        Py_CLEAR(state->type_InjectedInputShortcut);
        Py_CLEAR(state->type_InjectedInputTouchParameters);
        Py_CLEAR(state->type_InjectedInputVisualizationMode);
        Py_CLEAR(state->type_InjectedInputGamepadInfo);
        Py_CLEAR(state->type_InjectedInputKeyboardInfo);
        Py_CLEAR(state->type_InjectedInputMouseInfo);
        Py_CLEAR(state->type_InjectedInputPenInfo);
        Py_CLEAR(state->type_InjectedInputTouchInfo);
        Py_CLEAR(state->type_InputInjector);
        Py_CLEAR(state->type_InjectedInputPoint);
        Py_CLEAR(state->type_InjectedInputPointerInfo);
        Py_CLEAR(state->type_InjectedInputRectangle);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Input_Preview_Injection",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Input::Preview::Injection

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_Input_Preview_Injection(void) noexcept
{
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_InjectedInputGamepadInfo = py::register_python_type(module.get(), type_name_InjectedInputGamepadInfo, &type_spec_InjectedInputGamepadInfo, bases.get(), nullptr);
    if (!state->type_InjectedInputGamepadInfo)
    {
        return nullptr;
    }

    state->type_InjectedInputKeyboardInfo = py::register_python_type(module.get(), type_name_InjectedInputKeyboardInfo, &type_spec_InjectedInputKeyboardInfo, bases.get(), nullptr);
    if (!state->type_InjectedInputKeyboardInfo)
    {
        return nullptr;
    }

    state->type_InjectedInputMouseInfo = py::register_python_type(module.get(), type_name_InjectedInputMouseInfo, &type_spec_InjectedInputMouseInfo, bases.get(), nullptr);
    if (!state->type_InjectedInputMouseInfo)
    {
        return nullptr;
    }

    state->type_InjectedInputPenInfo = py::register_python_type(module.get(), type_name_InjectedInputPenInfo, &type_spec_InjectedInputPenInfo, bases.get(), nullptr);
    if (!state->type_InjectedInputPenInfo)
    {
        return nullptr;
    }

    state->type_InjectedInputTouchInfo = py::register_python_type(module.get(), type_name_InjectedInputTouchInfo, &type_spec_InjectedInputTouchInfo, bases.get(), nullptr);
    if (!state->type_InjectedInputTouchInfo)
    {
        return nullptr;
    }

    state->type_InputInjector = py::register_python_type(module.get(), type_name_InputInjector, &type_spec_InputInjector, bases.get(), nullptr);
    if (!state->type_InputInjector)
    {
        return nullptr;
    }

    state->type_InjectedInputPoint = py::register_python_type(module.get(), type_name_InjectedInputPoint, &type_spec_InjectedInputPoint, bases.get(), nullptr);
    if (!state->type_InjectedInputPoint)
    {
        return nullptr;
    }

    state->type_InjectedInputPointerInfo = py::register_python_type(module.get(), type_name_InjectedInputPointerInfo, &type_spec_InjectedInputPointerInfo, bases.get(), nullptr);
    if (!state->type_InjectedInputPointerInfo)
    {
        return nullptr;
    }

    state->type_InjectedInputRectangle = py::register_python_type(module.get(), type_name_InjectedInputRectangle, &type_spec_InjectedInputRectangle, bases.get(), nullptr);
    if (!state->type_InjectedInputRectangle)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputButtonChangeKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputButtonChangeKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputButtonChangeKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputKeyOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputMouseOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputPenButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputPenParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputPointerOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputShortcut>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputShortcut;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputShortcut is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputTouchParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputVisualizationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputGamepadInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputKeyboardInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputMouseInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputPenInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputTouchInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InputInjector>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InputInjector;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InputInjector is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputPoint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputPointerInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Input::Preview::Injection");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InjectedInputRectangle;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle is not registered");
        return nullptr;
    }

    return python_type;
}
