// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Devices.Scanners.h"


PyObject* py::converter<winrt::Windows::Devices::Scanners::ImageScannerResolution>::convert(winrt::Windows::Devices::Scanners::ImageScannerResolution instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Devices::Scanners::ImageScannerResolution>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Devices::Scanners::ImageScannerResolution py::converter<winrt::Windows::Devices::Scanners::ImageScannerResolution>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Devices::Scanners::ImageScannerResolution>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Scanners::ImageScannerResolution>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Devices::Scanners::ImageScannerResolution");
    throw python_exception();
}

namespace py::cpp::Windows::Devices::Scanners
{
    struct module_state
    {
        PyObject* type_ImageScannerAutoCroppingMode;
        PyObject* type_ImageScannerColorMode;
        PyObject* type_ImageScannerFormat;
        PyObject* type_ImageScannerScanSource;
        PyTypeObject* type_ImageScanner;
        PyTypeObject* type_ImageScannerAutoConfiguration;
        PyTypeObject* type_ImageScannerFeederConfiguration;
        PyTypeObject* type_ImageScannerFlatbedConfiguration;
        PyTypeObject* type_ImageScannerPreviewResult;
        PyTypeObject* type_ImageScannerScanResult;
        PyTypeObject* type_IImageScannerFormatConfiguration;
        PyTypeObject* type_IImageScannerSourceConfiguration;
        PyTypeObject* type_ImageScannerResolution;
    };

    static PyObject* register_ImageScannerAutoCroppingMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ImageScannerAutoCroppingMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ImageScannerAutoCroppingMode = type;
        Py_INCREF(state->type_ImageScannerAutoCroppingMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ImageScannerColorMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ImageScannerColorMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ImageScannerColorMode = type;
        Py_INCREF(state->type_ImageScannerColorMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ImageScannerFormat(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ImageScannerFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ImageScannerFormat = type;
        Py_INCREF(state->type_ImageScannerFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_ImageScannerScanSource(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ImageScannerScanSource)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ImageScannerScanSource = type;
        Py_INCREF(state->type_ImageScannerScanSource);


        Py_RETURN_NONE;
    }

    // ----- ImageScanner class --------------------
    static constexpr const char* const type_name_ImageScanner = "ImageScanner";

    static PyObject* _new_ImageScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageScanner);
        return nullptr;
    }

    static void _dealloc_ImageScanner(py::wrapper::Windows::Devices::Scanners::ImageScanner* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScanner_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Scanners::ImageScanner::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Scanners::ImageScanner::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_IsPreviewSupported(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"IsPreviewSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);

                return py::convert(self->obj.IsPreviewSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_IsScanSourceSupported(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"IsScanSourceSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);

                return py::convert(self->obj.IsScanSourceSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_ScanFilesToFolderAsync(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"ScanFilesToFolderAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 1);

                return py::convert(self->obj.ScanFilesToFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_ScanPreviewToStreamAsync(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScanner", L"ScanPreviewToStreamAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerScanSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.ScanPreviewToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_AutoConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"AutoConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_DefaultScanSource(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"DefaultScanSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultScanSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_DeviceId(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_FeederConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"FeederConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FeederConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScanner_get_FlatbedConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScanner* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScanner", L"FlatbedConfiguration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlatbedConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScanner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScanner[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(ImageScanner_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ImageScanner_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "is_preview_supported", reinterpret_cast<PyCFunction>(ImageScanner_IsPreviewSupported), METH_VARARGS, nullptr },
        { "is_scan_source_supported", reinterpret_cast<PyCFunction>(ImageScanner_IsScanSourceSupported), METH_VARARGS, nullptr },
        { "scan_files_to_folder_async", reinterpret_cast<PyCFunction>(ImageScanner_ScanFilesToFolderAsync), METH_VARARGS, nullptr },
        { "scan_preview_to_stream_async", reinterpret_cast<PyCFunction>(ImageScanner_ScanPreviewToStreamAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScanner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScanner), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScanner[] = {
        { "auto_configuration", reinterpret_cast<getter>(ImageScanner_get_AutoConfiguration), nullptr, nullptr, nullptr },
        { "default_scan_source", reinterpret_cast<getter>(ImageScanner_get_DefaultScanSource), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ImageScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "feeder_configuration", reinterpret_cast<getter>(ImageScanner_get_FeederConfiguration), nullptr, nullptr, nullptr },
        { "flatbed_configuration", reinterpret_cast<getter>(ImageScanner_get_FlatbedConfiguration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScanner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScanner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScanner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScanner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScanner) },
        { },
    };

    static PyType_Spec type_spec_ImageScanner =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScanner",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScanner
    };

    // ----- ImageScannerAutoConfiguration class --------------------
    static constexpr const char* const type_name_ImageScannerAutoConfiguration = "ImageScannerAutoConfiguration";

    static PyObject* _new_ImageScannerAutoConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageScannerAutoConfiguration);
        return nullptr;
    }

    static void _dealloc_ImageScannerAutoConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerAutoConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerAutoConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerAutoConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerAutoConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerAutoConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerAutoConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerAutoConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerAutoConfiguration[] = {
        { "is_format_supported", reinterpret_cast<PyCFunction>(ImageScannerAutoConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScannerAutoConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerAutoConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerAutoConfiguration[] = {
        { "format", reinterpret_cast<getter>(ImageScannerAutoConfiguration_get_Format), reinterpret_cast<setter>(ImageScannerAutoConfiguration_put_Format), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(ImageScannerAutoConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerAutoConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerAutoConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerAutoConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerAutoConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerAutoConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerAutoConfiguration =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScannerAutoConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerAutoConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerAutoConfiguration
    };

    // ----- ImageScannerFeederConfiguration class --------------------
    static constexpr const char* const type_name_ImageScannerFeederConfiguration = "ImageScannerFeederConfiguration";

    static PyObject* _new_ImageScannerFeederConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageScannerFeederConfiguration);
        return nullptr;
    }

    static void _dealloc_ImageScannerFeederConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerFeederConfiguration_IsAutoCroppingModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsAutoCroppingModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(args, 0);

                return py::convert(self->obj.IsAutoCroppingModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_IsColorModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsColorModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(args, 0);

                return py::convert(self->obj.IsColorModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_IsPageSizeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"IsPageSizeSupported", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintMediaSize>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Printing::PrintOrientation>(args, 1);

                return py::convert(self->obj.IsPageSizeSupported(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ScanAhead(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ScanAhead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanAhead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_ScanAhead(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ScanAhead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ScanAhead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_AutoDetectPageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoDetectPageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoDetectPageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_AutoDetectPageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoDetectPageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoDetectPageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Duplex(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Duplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duplex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Duplex(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Duplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Duplex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxNumberOfPages(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxNumberOfPages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxNumberOfPages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_MaxNumberOfPages(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxNumberOfPages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxNumberOfPages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_PageOrientation(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_PageOrientation(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintOrientation>(arg);

            self->obj.PageOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_PageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_PageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing::PrintMediaSize>(arg);

            self->obj.PageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_PageSizeDimensions(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"PageSizeDimensions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageSizeDimensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_CanScanDuplex(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"CanScanDuplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanScanDuplex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_CanScanAhead(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"CanScanAhead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanScanAhead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_CanAutoDetectPageSize(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"CanAutoDetectPageSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanAutoDetectPageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerResolution>(arg);

            self->obj.DesiredResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Contrast(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoCroppingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(arg);

            self->obj.AutoCroppingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedScanRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFeederConfiguration_put_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.SelectedScanRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MinScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MinScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_OpticalResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"OpticalResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_MaxBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"MaxBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_DefaultBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"DefaultBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ContrastStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ContrastStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContrastStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_BrightnessStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"BrightnessStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrightnessStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFeederConfiguration_get_ActualResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFeederConfiguration", L"ActualResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerFeederConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerFeederConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerFeederConfiguration[] = {
        { "is_auto_cropping_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsAutoCroppingModeSupported), METH_VARARGS, nullptr },
        { "is_color_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsColorModeSupported), METH_VARARGS, nullptr },
        { "is_format_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "is_page_size_supported", reinterpret_cast<PyCFunction>(ImageScannerFeederConfiguration_IsPageSizeSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScannerFeederConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerFeederConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerFeederConfiguration[] = {
        { "scan_ahead", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ScanAhead), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_ScanAhead), nullptr, nullptr },
        { "auto_detect_page_size", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_AutoDetectPageSize), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_AutoDetectPageSize), nullptr, nullptr },
        { "duplex", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Duplex), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Duplex), nullptr, nullptr },
        { "max_number_of_pages", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxNumberOfPages), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_MaxNumberOfPages), nullptr, nullptr },
        { "page_orientation", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_PageOrientation), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_PageOrientation), nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_PageSize), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_PageSize), nullptr, nullptr },
        { "page_size_dimensions", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_PageSizeDimensions), nullptr, nullptr, nullptr },
        { "can_scan_duplex", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_CanScanDuplex), nullptr, nullptr, nullptr },
        { "can_scan_ahead", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_CanScanAhead), nullptr, nullptr, nullptr },
        { "can_auto_detect_page_size", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_CanAutoDetectPageSize), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Format), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Format), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "desired_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DesiredResolution), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_DesiredResolution), nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Contrast), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Contrast), nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ColorMode), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_ColorMode), nullptr, nullptr },
        { "auto_cropping_mode", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_AutoCroppingMode), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_AutoCroppingMode), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_Brightness), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_Brightness), nullptr, nullptr },
        { "selected_scan_region", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_SelectedScanRegion), reinterpret_cast<setter>(ImageScannerFeederConfiguration_put_SelectedScanRegion), nullptr, nullptr },
        { "min_brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinBrightness), nullptr, nullptr, nullptr },
        { "min_contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinContrast), nullptr, nullptr, nullptr },
        { "min_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinResolution), nullptr, nullptr, nullptr },
        { "min_scan_area", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MinScanArea), nullptr, nullptr, nullptr },
        { "optical_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_OpticalResolution), nullptr, nullptr, nullptr },
        { "max_scan_area", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxScanArea), nullptr, nullptr, nullptr },
        { "max_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxResolution), nullptr, nullptr, nullptr },
        { "max_contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxContrast), nullptr, nullptr, nullptr },
        { "max_brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_MaxBrightness), nullptr, nullptr, nullptr },
        { "default_contrast", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultContrast), nullptr, nullptr, nullptr },
        { "default_color_mode", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultColorMode), nullptr, nullptr, nullptr },
        { "default_brightness", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_DefaultBrightness), nullptr, nullptr, nullptr },
        { "contrast_step", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ContrastStep), nullptr, nullptr, nullptr },
        { "brightness_step", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_BrightnessStep), nullptr, nullptr, nullptr },
        { "actual_resolution", reinterpret_cast<getter>(ImageScannerFeederConfiguration_get_ActualResolution), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerFeederConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerFeederConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerFeederConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerFeederConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerFeederConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerFeederConfiguration =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScannerFeederConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerFeederConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerFeederConfiguration
    };

    // ----- ImageScannerFlatbedConfiguration class --------------------
    static constexpr const char* const type_name_ImageScannerFlatbedConfiguration = "ImageScannerFlatbedConfiguration";

    static PyObject* _new_ImageScannerFlatbedConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageScannerFlatbedConfiguration);
        return nullptr;
    }

    static void _dealloc_ImageScannerFlatbedConfiguration(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerFlatbedConfiguration_IsAutoCroppingModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"IsAutoCroppingModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(args, 0);

                return py::convert(self->obj.IsAutoCroppingModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_IsColorModeSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"IsColorModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(args, 0);

                return py::convert(self->obj.IsColorModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedScanRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.SelectedScanRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_DesiredResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerResolution>(arg);

            self->obj.DesiredResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_Contrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Contrast(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_Brightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoCroppingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(arg);

            self->obj.AutoCroppingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerFlatbedConfiguration_put_ColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_ContrastStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ContrastStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContrastStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultColorMode(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_DefaultContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"DefaultContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_ActualResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"ActualResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MaxScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MaxScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinBrightness(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_BrightnessStep(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"BrightnessStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrightnessStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinContrast(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_OpticalResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"OpticalResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerFlatbedConfiguration_get_MinScanArea(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerFlatbedConfiguration", L"MinScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerFlatbedConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerFlatbedConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerFlatbedConfiguration[] = {
        { "is_auto_cropping_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFlatbedConfiguration_IsAutoCroppingModeSupported), METH_VARARGS, nullptr },
        { "is_color_mode_supported", reinterpret_cast<PyCFunction>(ImageScannerFlatbedConfiguration_IsColorModeSupported), METH_VARARGS, nullptr },
        { "is_format_supported", reinterpret_cast<PyCFunction>(ImageScannerFlatbedConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageScannerFlatbedConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerFlatbedConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerFlatbedConfiguration[] = {
        { "format", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_Format), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_Format), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "selected_scan_region", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_SelectedScanRegion), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_SelectedScanRegion), nullptr, nullptr },
        { "desired_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DesiredResolution), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_DesiredResolution), nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_Contrast), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_Contrast), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_Brightness), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_Brightness), nullptr, nullptr },
        { "auto_cropping_mode", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_AutoCroppingMode), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_AutoCroppingMode), nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_ColorMode), reinterpret_cast<setter>(ImageScannerFlatbedConfiguration_put_ColorMode), nullptr, nullptr },
        { "contrast_step", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_ContrastStep), nullptr, nullptr, nullptr },
        { "default_brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultBrightness), nullptr, nullptr, nullptr },
        { "default_color_mode", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultColorMode), nullptr, nullptr, nullptr },
        { "default_contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_DefaultContrast), nullptr, nullptr, nullptr },
        { "actual_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_ActualResolution), nullptr, nullptr, nullptr },
        { "max_brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxBrightness), nullptr, nullptr, nullptr },
        { "max_contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxContrast), nullptr, nullptr, nullptr },
        { "max_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxResolution), nullptr, nullptr, nullptr },
        { "max_scan_area", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MaxScanArea), nullptr, nullptr, nullptr },
        { "min_brightness", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinBrightness), nullptr, nullptr, nullptr },
        { "brightness_step", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_BrightnessStep), nullptr, nullptr, nullptr },
        { "min_contrast", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinContrast), nullptr, nullptr, nullptr },
        { "min_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinResolution), nullptr, nullptr, nullptr },
        { "optical_resolution", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_OpticalResolution), nullptr, nullptr, nullptr },
        { "min_scan_area", reinterpret_cast<getter>(ImageScannerFlatbedConfiguration_get_MinScanArea), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerFlatbedConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerFlatbedConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerFlatbedConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerFlatbedConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerFlatbedConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerFlatbedConfiguration =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScannerFlatbedConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerFlatbedConfiguration
    };

    // ----- ImageScannerPreviewResult class --------------------
    static constexpr const char* const type_name_ImageScannerPreviewResult = "ImageScannerPreviewResult";

    static PyObject* _new_ImageScannerPreviewResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageScannerPreviewResult);
        return nullptr;
    }

    static void _dealloc_ImageScannerPreviewResult(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerPreviewResult_get_Format(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerPreviewResult", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageScannerPreviewResult_get_Succeeded(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerPreviewResult", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerPreviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerPreviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerPreviewResult[] = {
        { "_assign_array_", _assign_array_ImageScannerPreviewResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerPreviewResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerPreviewResult[] = {
        { "format", reinterpret_cast<getter>(ImageScannerPreviewResult_get_Format), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(ImageScannerPreviewResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerPreviewResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerPreviewResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerPreviewResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerPreviewResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerPreviewResult) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerPreviewResult =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScannerPreviewResult",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerPreviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerPreviewResult
    };

    // ----- ImageScannerScanResult class --------------------
    static constexpr const char* const type_name_ImageScannerScanResult = "ImageScannerScanResult";

    static PyObject* _new_ImageScannerScanResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageScannerScanResult);
        return nullptr;
    }

    static void _dealloc_ImageScannerScanResult(py::wrapper::Windows::Devices::Scanners::ImageScannerScanResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageScannerScanResult_get_ScannedFiles(py::wrapper::Windows::Devices::Scanners::ImageScannerScanResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.ImageScannerScanResult", L"ScannedFiles"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScannedFiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageScannerScanResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::ImageScannerScanResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageScannerScanResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::ImageScannerScanResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageScannerScanResult[] = {
        { "_assign_array_", _assign_array_ImageScannerScanResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageScannerScanResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageScannerScanResult[] = {
        { "scanned_files", reinterpret_cast<getter>(ImageScannerScanResult_get_ScannedFiles), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerScanResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerScanResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerScanResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageScannerScanResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerScanResult) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerScanResult =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScannerScanResult",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerScanResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerScanResult
    };

    // ----- IImageScannerFormatConfiguration interface --------------------
    static constexpr const char* const type_name_IImageScannerFormatConfiguration = "IImageScannerFormatConfiguration";

    static PyObject* _new_IImageScannerFormatConfiguration(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IImageScannerFormatConfiguration);
        return nullptr;
    }

    static void _dealloc_IImageScannerFormatConfiguration(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IImageScannerFormatConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerFormatConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerFormatConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerFormatConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IImageScannerFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IImageScannerFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IImageScannerFormatConfiguration[] = {
        { "is_format_supported", reinterpret_cast<PyCFunction>(IImageScannerFormatConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IImageScannerFormatConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IImageScannerFormatConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IImageScannerFormatConfiguration[] = {
        { "default_format", reinterpret_cast<getter>(IImageScannerFormatConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(IImageScannerFormatConfiguration_get_Format), reinterpret_cast<setter>(IImageScannerFormatConfiguration_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IImageScannerFormatConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IImageScannerFormatConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IImageScannerFormatConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IImageScannerFormatConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IImageScannerFormatConfiguration) },
        { },
    };

    static PyType_Spec type_spec_IImageScannerFormatConfiguration =
    {
        "_winsdk_Windows_Devices_Scanners.IImageScannerFormatConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::IImageScannerFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IImageScannerFormatConfiguration
    };

    // ----- IImageScannerSourceConfiguration interface --------------------
    static constexpr const char* const type_name_IImageScannerSourceConfiguration = "IImageScannerSourceConfiguration";

    static PyObject* _new_IImageScannerSourceConfiguration(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IImageScannerSourceConfiguration);
        return nullptr;
    }

    static void _dealloc_IImageScannerSourceConfiguration(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IImageScannerSourceConfiguration_IsAutoCroppingModeSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"IsAutoCroppingModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(args, 0);

                return py::convert(self->obj.IsAutoCroppingModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_IsColorModeSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"IsColorModeSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(args, 0);

                return py::convert(self->obj.IsColorModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_IsFormatSupported(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"IsFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(args, 0);

                return py::convert(self->obj.IsFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_ActualResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ActualResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoCroppingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_AutoCroppingMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"AutoCroppingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>(arg);

            self->obj.AutoCroppingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_Brightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_Brightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Brightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_BrightnessStep(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"BrightnessStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrightnessStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_ColorMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_ColorMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_Contrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_Contrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"Contrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Contrast(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_ContrastStep(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"ContrastStep"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContrastStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultBrightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DefaultBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultColorMode(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DefaultColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultContrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DefaultContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DesiredResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_DesiredResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"DesiredResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerResolution>(arg);

            self->obj.DesiredResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxBrightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxContrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MaxScanArea(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MaxScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinBrightness(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinBrightness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinBrightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinContrast(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinContrast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_MinScanArea(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"MinScanArea"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinScanArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_OpticalResolution(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"OpticalResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OpticalResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedScanRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_SelectedScanRegion(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerSourceConfiguration", L"SelectedScanRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.SelectedScanRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_DefaultFormat(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"DefaultFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IImageScannerSourceConfiguration_get_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IImageScannerSourceConfiguration_put_Format(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Scanners.IImageScannerFormatConfiguration", L"Format"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Scanners::ImageScannerFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IImageScannerSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IImageScannerSourceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IImageScannerSourceConfiguration[] = {
        { "is_auto_cropping_mode_supported", reinterpret_cast<PyCFunction>(IImageScannerSourceConfiguration_IsAutoCroppingModeSupported), METH_VARARGS, nullptr },
        { "is_color_mode_supported", reinterpret_cast<PyCFunction>(IImageScannerSourceConfiguration_IsColorModeSupported), METH_VARARGS, nullptr },
        { "is_format_supported", reinterpret_cast<PyCFunction>(IImageScannerSourceConfiguration_IsFormatSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IImageScannerSourceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IImageScannerSourceConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IImageScannerSourceConfiguration[] = {
        { "actual_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_ActualResolution), nullptr, nullptr, nullptr },
        { "auto_cropping_mode", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_AutoCroppingMode), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_AutoCroppingMode), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_Brightness), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_Brightness), nullptr, nullptr },
        { "brightness_step", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_BrightnessStep), nullptr, nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_ColorMode), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_ColorMode), nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_Contrast), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_Contrast), nullptr, nullptr },
        { "contrast_step", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_ContrastStep), nullptr, nullptr, nullptr },
        { "default_brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultBrightness), nullptr, nullptr, nullptr },
        { "default_color_mode", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultColorMode), nullptr, nullptr, nullptr },
        { "default_contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultContrast), nullptr, nullptr, nullptr },
        { "desired_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DesiredResolution), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_DesiredResolution), nullptr, nullptr },
        { "max_brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxBrightness), nullptr, nullptr, nullptr },
        { "max_contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxContrast), nullptr, nullptr, nullptr },
        { "max_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxResolution), nullptr, nullptr, nullptr },
        { "max_scan_area", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MaxScanArea), nullptr, nullptr, nullptr },
        { "min_brightness", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinBrightness), nullptr, nullptr, nullptr },
        { "min_contrast", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinContrast), nullptr, nullptr, nullptr },
        { "min_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinResolution), nullptr, nullptr, nullptr },
        { "min_scan_area", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_MinScanArea), nullptr, nullptr, nullptr },
        { "optical_resolution", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_OpticalResolution), nullptr, nullptr, nullptr },
        { "selected_scan_region", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_SelectedScanRegion), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_SelectedScanRegion), nullptr, nullptr },
        { "default_format", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_DefaultFormat), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(IImageScannerSourceConfiguration_get_Format), reinterpret_cast<setter>(IImageScannerSourceConfiguration_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IImageScannerSourceConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IImageScannerSourceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IImageScannerSourceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IImageScannerSourceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IImageScannerSourceConfiguration) },
        { },
    };

    static PyType_Spec type_spec_IImageScannerSourceConfiguration =
    {
        "_winsdk_Windows_Devices_Scanners.IImageScannerSourceConfiguration",
        sizeof(py::wrapper::Windows::Devices::Scanners::IImageScannerSourceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IImageScannerSourceConfiguration
    };

    // ----- ImageScannerResolution struct --------------------
    static constexpr const char* const type_name_ImageScannerResolution = "ImageScannerResolution";

    PyObject* _new_ImageScannerResolution(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Scanners::ImageScannerResolution return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        float _DpiX{};
        float _DpiY{};

        static const char* kwlist[] = {"dpi_x", "dpi_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_DpiX, &_DpiY))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Scanners::ImageScannerResolution return_value{ _DpiX, _DpiY };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ImageScannerResolution(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self) noexcept
    {
    }

    static PyObject* ImageScannerResolution_get_DpiX(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerResolution_set_DpiX(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.DpiX = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageScannerResolution_get_DpiY(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageScannerResolution_set_DpiY(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.DpiY = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ImageScannerResolution[] = {
        { "dpi_x", reinterpret_cast<getter>(ImageScannerResolution_get_DpiX), reinterpret_cast<setter>(ImageScannerResolution_set_DpiX), nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(ImageScannerResolution_get_DpiY), reinterpret_cast<setter>(ImageScannerResolution_set_DpiY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageScannerResolution[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageScannerResolution) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageScannerResolution) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageScannerResolution) },
        { },
    };

    static PyType_Spec type_spec_ImageScannerResolution =
    {
        "_winsdk_Windows_Devices_Scanners.ImageScannerResolution",
        sizeof(py::wrapper::Windows::Devices::Scanners::ImageScannerResolution),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageScannerResolution
    };

    // ----- Windows.Devices.Scanners Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Scanners");

    static PyMethodDef module_methods[] = {
        {"_register_ImageScannerAutoCroppingMode", register_ImageScannerAutoCroppingMode, METH_O, "registers type"},
        {"_register_ImageScannerColorMode", register_ImageScannerColorMode, METH_O, "registers type"},
        {"_register_ImageScannerFormat", register_ImageScannerFormat, METH_O, "registers type"},
        {"_register_ImageScannerScanSource", register_ImageScannerScanSource, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ImageScannerAutoCroppingMode);
        Py_VISIT(state->type_ImageScannerColorMode);
        Py_VISIT(state->type_ImageScannerFormat);
        Py_VISIT(state->type_ImageScannerScanSource);
        Py_VISIT(state->type_ImageScanner);
        Py_VISIT(state->type_ImageScannerAutoConfiguration);
        Py_VISIT(state->type_ImageScannerFeederConfiguration);
        Py_VISIT(state->type_ImageScannerFlatbedConfiguration);
        Py_VISIT(state->type_ImageScannerPreviewResult);
        Py_VISIT(state->type_ImageScannerScanResult);
        Py_VISIT(state->type_IImageScannerFormatConfiguration);
        Py_VISIT(state->type_IImageScannerSourceConfiguration);
        Py_VISIT(state->type_ImageScannerResolution);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ImageScannerAutoCroppingMode);
        Py_CLEAR(state->type_ImageScannerColorMode);
        Py_CLEAR(state->type_ImageScannerFormat);
        Py_CLEAR(state->type_ImageScannerScanSource);
        Py_CLEAR(state->type_ImageScanner);
        Py_CLEAR(state->type_ImageScannerAutoConfiguration);
        Py_CLEAR(state->type_ImageScannerFeederConfiguration);
        Py_CLEAR(state->type_ImageScannerFlatbedConfiguration);
        Py_CLEAR(state->type_ImageScannerPreviewResult);
        Py_CLEAR(state->type_ImageScannerScanResult);
        Py_CLEAR(state->type_IImageScannerFormatConfiguration);
        Py_CLEAR(state->type_IImageScannerSourceConfiguration);
        Py_CLEAR(state->type_ImageScannerResolution);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Scanners",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Scanners

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Scanners(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Scanners;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ImageScanner = py::register_python_type(module.get(), type_name_ImageScanner, &type_spec_ImageScanner, bases.get(), nullptr);
    if (!state->type_ImageScanner)
    {
        return nullptr;
    }

    state->type_ImageScannerAutoConfiguration = py::register_python_type(module.get(), type_name_ImageScannerAutoConfiguration, &type_spec_ImageScannerAutoConfiguration, bases.get(), nullptr);
    if (!state->type_ImageScannerAutoConfiguration)
    {
        return nullptr;
    }

    state->type_ImageScannerFeederConfiguration = py::register_python_type(module.get(), type_name_ImageScannerFeederConfiguration, &type_spec_ImageScannerFeederConfiguration, bases.get(), nullptr);
    if (!state->type_ImageScannerFeederConfiguration)
    {
        return nullptr;
    }

    state->type_ImageScannerFlatbedConfiguration = py::register_python_type(module.get(), type_name_ImageScannerFlatbedConfiguration, &type_spec_ImageScannerFlatbedConfiguration, bases.get(), nullptr);
    if (!state->type_ImageScannerFlatbedConfiguration)
    {
        return nullptr;
    }

    state->type_ImageScannerPreviewResult = py::register_python_type(module.get(), type_name_ImageScannerPreviewResult, &type_spec_ImageScannerPreviewResult, bases.get(), nullptr);
    if (!state->type_ImageScannerPreviewResult)
    {
        return nullptr;
    }

    state->type_ImageScannerScanResult = py::register_python_type(module.get(), type_name_ImageScannerScanResult, &type_spec_ImageScannerScanResult, bases.get(), nullptr);
    if (!state->type_ImageScannerScanResult)
    {
        return nullptr;
    }

    state->type_IImageScannerFormatConfiguration = py::register_python_type(module.get(), type_name_IImageScannerFormatConfiguration, &type_spec_IImageScannerFormatConfiguration, bases.get(), nullptr);
    if (!state->type_IImageScannerFormatConfiguration)
    {
        return nullptr;
    }

    state->type_IImageScannerSourceConfiguration = py::register_python_type(module.get(), type_name_IImageScannerSourceConfiguration, &type_spec_IImageScannerSourceConfiguration, bases.get(), nullptr);
    if (!state->type_IImageScannerSourceConfiguration)
    {
        return nullptr;
    }

    state->type_ImageScannerResolution = py::register_python_type(module.get(), type_name_ImageScannerResolution, &type_spec_ImageScannerResolution, bases.get(), nullptr);
    if (!state->type_ImageScannerResolution)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerAutoCroppingMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerAutoCroppingMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Scanners::ImageScannerColorMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerColorMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerColorMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Scanners::ImageScannerFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Scanners::ImageScannerScanSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerScanSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerScanSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScanner>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScanner;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScanner is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerAutoConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerAutoConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerFeederConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerFeederConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerFlatbedConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerFlatbedConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScannerPreviewResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerPreviewResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerPreviewResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScannerScanResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerScanResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerScanResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IImageScannerFormatConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::IImageScannerFormatConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IImageScannerSourceConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::IImageScannerSourceConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Scanners::ImageScannerResolution>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Scanners;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Scanners");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageScannerResolution;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Scanners::ImageScannerResolution is not registered");
        return nullptr;
    }

    return python_type;
}
