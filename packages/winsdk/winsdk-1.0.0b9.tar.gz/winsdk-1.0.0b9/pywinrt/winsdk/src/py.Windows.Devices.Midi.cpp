// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Devices.Midi.h"


namespace py::cpp::Windows::Devices::Midi
{
    struct module_state
    {
        PyObject* type_MidiMessageType;
        PyTypeObject* type_MidiActiveSensingMessage;
        PyTypeObject* type_MidiChannelPressureMessage;
        PyTypeObject* type_MidiContinueMessage;
        PyTypeObject* type_MidiControlChangeMessage;
        PyTypeObject* type_MidiInPort;
        PyTypeObject* type_MidiMessageReceivedEventArgs;
        PyTypeObject* type_MidiNoteOffMessage;
        PyTypeObject* type_MidiNoteOnMessage;
        PyTypeObject* type_MidiOutPort;
        PyTypeObject* type_MidiPitchBendChangeMessage;
        PyTypeObject* type_MidiPolyphonicKeyPressureMessage;
        PyTypeObject* type_MidiProgramChangeMessage;
        PyTypeObject* type_MidiSongPositionPointerMessage;
        PyTypeObject* type_MidiSongSelectMessage;
        PyTypeObject* type_MidiStartMessage;
        PyTypeObject* type_MidiStopMessage;
        PyTypeObject* type_MidiSynthesizer;
        PyTypeObject* type_MidiSystemExclusiveMessage;
        PyTypeObject* type_MidiSystemResetMessage;
        PyTypeObject* type_MidiTimeCodeMessage;
        PyTypeObject* type_MidiTimingClockMessage;
        PyTypeObject* type_MidiTuneRequestMessage;
        PyTypeObject* type_IMidiMessage;
        PyTypeObject* type_IMidiOutPort;
    };

    static PyObject* register_MidiMessageType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MidiMessageType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MidiMessageType = type;
        Py_INCREF(state->type_MidiMessageType);


        Py_RETURN_NONE;
    }

    // ----- MidiActiveSensingMessage class --------------------
    static constexpr const char* const type_name_MidiActiveSensingMessage = "MidiActiveSensingMessage";

    static PyObject* _new_MidiActiveSensingMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiActiveSensingMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiActiveSensingMessage(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiActiveSensingMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiActiveSensingMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiActiveSensingMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiActiveSensingMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiActiveSensingMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiActiveSensingMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiActiveSensingMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiActiveSensingMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiActiveSensingMessage[] = {
        { "_assign_array_", _assign_array_MidiActiveSensingMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiActiveSensingMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiActiveSensingMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiActiveSensingMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiActiveSensingMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiActiveSensingMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiActiveSensingMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiActiveSensingMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiActiveSensingMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiActiveSensingMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiActiveSensingMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiActiveSensingMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiActiveSensingMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiActiveSensingMessage
    };

    // ----- MidiChannelPressureMessage class --------------------
    static constexpr const char* const type_name_MidiChannelPressureMessage = "MidiChannelPressureMessage";

    static PyObject* _new_MidiChannelPressureMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiChannelPressureMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiChannelPressureMessage(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiChannelPressureMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Pressure(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiChannelPressureMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiChannelPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiChannelPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiChannelPressureMessage[] = {
        { "_assign_array_", _assign_array_MidiChannelPressureMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiChannelPressureMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiChannelPressureMessage[] = {
        { "channel", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Channel), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Pressure), nullptr, nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(MidiChannelPressureMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiChannelPressureMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiChannelPressureMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiChannelPressureMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiChannelPressureMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiChannelPressureMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiChannelPressureMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiChannelPressureMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiChannelPressureMessage
    };

    // ----- MidiContinueMessage class --------------------
    static constexpr const char* const type_name_MidiContinueMessage = "MidiContinueMessage";

    static PyObject* _new_MidiContinueMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiContinueMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiContinueMessage(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiContinueMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiContinueMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiContinueMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiContinueMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiContinueMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiContinueMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiContinueMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiContinueMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiContinueMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiContinueMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiContinueMessage[] = {
        { "_assign_array_", _assign_array_MidiContinueMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiContinueMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiContinueMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiContinueMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiContinueMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiContinueMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiContinueMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiContinueMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiContinueMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiContinueMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiContinueMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiContinueMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiContinueMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiContinueMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiContinueMessage
    };

    // ----- MidiControlChangeMessage class --------------------
    static constexpr const char* const type_name_MidiControlChangeMessage = "MidiControlChangeMessage";

    static PyObject* _new_MidiControlChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiControlChangeMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiControlChangeMessage(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiControlChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_ControlValue(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"ControlValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Controller(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Controller"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Controller());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiControlChangeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiControlChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiControlChangeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiControlChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiControlChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiControlChangeMessage[] = {
        { "_assign_array_", _assign_array_MidiControlChangeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiControlChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiControlChangeMessage[] = {
        { "channel", reinterpret_cast<getter>(MidiControlChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { "control_value", reinterpret_cast<getter>(MidiControlChangeMessage_get_ControlValue), nullptr, nullptr, nullptr },
        { "controller", reinterpret_cast<getter>(MidiControlChangeMessage_get_Controller), nullptr, nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(MidiControlChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiControlChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiControlChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiControlChangeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiControlChangeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiControlChangeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiControlChangeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiControlChangeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiControlChangeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiControlChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiControlChangeMessage
    };

    // ----- MidiInPort class --------------------
    static constexpr const char* const type_name_MidiInPort = "MidiInPort";

    static PyObject* _new_MidiInPort(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiInPort);
        return nullptr;
    }

    static void _dealloc_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiInPort_Close(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiInPort", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiInPort", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiInPort::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiInPort", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiInPort::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiInPort* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiInPort", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiInPort_add_MessageReceived(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Midi.MidiInPort", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Midi::MidiInPort, winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiInPort_remove_MessageReceived(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Midi.MidiInPort", L"MessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiInPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiInPort>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiInPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiInPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiInPort[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiInPort_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(MidiInPort_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MidiInPort_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(MidiInPort_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(MidiInPort_remove_MessageReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_MidiInPort, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiInPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiInPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiInPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiInPort[] = {
        { "device_id", reinterpret_cast<getter>(MidiInPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiInPort[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiInPort) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiInPort) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiInPort) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiInPort) },
        { },
    };

    static PyType_Spec type_spec_MidiInPort =
    {
        "_winsdk_Windows_Devices_Midi.MidiInPort",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiInPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiInPort
    };

    // ----- MidiMessageReceivedEventArgs class --------------------
    static constexpr const char* const type_name_MidiMessageReceivedEventArgs = "MidiMessageReceivedEventArgs";

    static PyObject* _new_MidiMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MidiMessageReceivedEventArgs(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiMessageReceivedEventArgs_get_Message(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiMessageReceivedEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiMessageReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MidiMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiMessageReceivedEventArgs[] = {
        { "message", reinterpret_cast<getter>(MidiMessageReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiMessageReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MidiMessageReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_Midi.MidiMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiMessageReceivedEventArgs
    };

    // ----- MidiNoteOffMessage class --------------------
    static constexpr const char* const type_name_MidiNoteOffMessage = "MidiNoteOffMessage";

    static PyObject* _new_MidiNoteOffMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiNoteOffMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiNoteOffMessage(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiNoteOffMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Note"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Velocity(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOffMessage", L"Velocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiNoteOffMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiNoteOffMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiNoteOffMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiNoteOffMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiNoteOffMessage[] = {
        { "_assign_array_", _assign_array_MidiNoteOffMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiNoteOffMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiNoteOffMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiNoteOffMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiNoteOffMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiNoteOffMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiNoteOffMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiNoteOffMessage_get_Note), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(MidiNoteOffMessage_get_Velocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiNoteOffMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiNoteOffMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiNoteOffMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiNoteOffMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiNoteOffMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiNoteOffMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiNoteOffMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiNoteOffMessage
    };

    // ----- MidiNoteOnMessage class --------------------
    static constexpr const char* const type_name_MidiNoteOnMessage = "MidiNoteOnMessage";

    static PyObject* _new_MidiNoteOnMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiNoteOnMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiNoteOnMessage(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiNoteOnMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Note"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Velocity(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiNoteOnMessage", L"Velocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiNoteOnMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiNoteOnMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiNoteOnMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiNoteOnMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiNoteOnMessage[] = {
        { "_assign_array_", _assign_array_MidiNoteOnMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiNoteOnMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiNoteOnMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiNoteOnMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiNoteOnMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiNoteOnMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiNoteOnMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiNoteOnMessage_get_Note), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(MidiNoteOnMessage_get_Velocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiNoteOnMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiNoteOnMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiNoteOnMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiNoteOnMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiNoteOnMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiNoteOnMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiNoteOnMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiNoteOnMessage
    };

    // ----- MidiOutPort class --------------------
    static constexpr const char* const type_name_MidiOutPort = "MidiOutPort";

    static PyObject* _new_MidiOutPort(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiOutPort);
        return nullptr;
    }

    static void _dealloc_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiOutPort_Close(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiOutPort::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiOutPort::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_SendBuffer(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"SendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_SendMessage(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiOutPort", L"SendMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiOutPort", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiOutPort>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiOutPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiOutPort[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiOutPort_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(MidiOutPort_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MidiOutPort_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(MidiOutPort_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(MidiOutPort_SendMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MidiOutPort, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiOutPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiOutPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiOutPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiOutPort[] = {
        { "device_id", reinterpret_cast<getter>(MidiOutPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiOutPort[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiOutPort) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiOutPort) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiOutPort) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiOutPort) },
        { },
    };

    static PyType_Spec type_spec_MidiOutPort =
    {
        "_winsdk_Windows_Devices_Midi.MidiOutPort",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiOutPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiOutPort
    };

    // ----- MidiPitchBendChangeMessage class --------------------
    static constexpr const char* const type_name_MidiPitchBendChangeMessage = "MidiPitchBendChangeMessage";

    static PyObject* _new_MidiPitchBendChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiPitchBendChangeMessage(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiPitchBendChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Bend(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Bend"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bend());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPitchBendChangeMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiPitchBendChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiPitchBendChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiPitchBendChangeMessage[] = {
        { "_assign_array_", _assign_array_MidiPitchBendChangeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiPitchBendChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiPitchBendChangeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { "bend", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Bend), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiPitchBendChangeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiPitchBendChangeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiPitchBendChangeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiPitchBendChangeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiPitchBendChangeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiPitchBendChangeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiPitchBendChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiPitchBendChangeMessage
    };

    // ----- MidiPolyphonicKeyPressureMessage class --------------------
    static constexpr const char* const type_name_MidiPolyphonicKeyPressureMessage = "MidiPolyphonicKeyPressureMessage";

    static PyObject* _new_MidiPolyphonicKeyPressureMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiPolyphonicKeyPressureMessage(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Note"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Pressure(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiPolyphonicKeyPressureMessage", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiPolyphonicKeyPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiPolyphonicKeyPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiPolyphonicKeyPressureMessage[] = {
        { "_assign_array_", _assign_array_MidiPolyphonicKeyPressureMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiPolyphonicKeyPressureMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiPolyphonicKeyPressureMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Note), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Pressure), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiPolyphonicKeyPressureMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiPolyphonicKeyPressureMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiPolyphonicKeyPressureMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiPolyphonicKeyPressureMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiPolyphonicKeyPressureMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiPolyphonicKeyPressureMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiPolyphonicKeyPressureMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiPolyphonicKeyPressureMessage
    };

    // ----- MidiProgramChangeMessage class --------------------
    static constexpr const char* const type_name_MidiProgramChangeMessage = "MidiProgramChangeMessage";

    static PyObject* _new_MidiProgramChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiProgramChangeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiProgramChangeMessage(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiProgramChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Channel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Program(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiProgramChangeMessage", L"Program"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Program());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiProgramChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiProgramChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiProgramChangeMessage[] = {
        { "_assign_array_", _assign_array_MidiProgramChangeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiProgramChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiProgramChangeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiProgramChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { "program", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Program), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiProgramChangeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiProgramChangeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiProgramChangeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiProgramChangeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiProgramChangeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiProgramChangeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiProgramChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiProgramChangeMessage
    };

    // ----- MidiSongPositionPointerMessage class --------------------
    static constexpr const char* const type_name_MidiSongPositionPointerMessage = "MidiSongPositionPointerMessage";

    static PyObject* _new_MidiSongPositionPointerMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSongPositionPointerMessage(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSongPositionPointerMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Beats(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongPositionPointerMessage", L"Beats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Beats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSongPositionPointerMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSongPositionPointerMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSongPositionPointerMessage[] = {
        { "_assign_array_", _assign_array_MidiSongPositionPointerMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSongPositionPointerMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSongPositionPointerMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Type), nullptr, nullptr, nullptr },
        { "beats", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Beats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSongPositionPointerMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSongPositionPointerMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSongPositionPointerMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSongPositionPointerMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSongPositionPointerMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSongPositionPointerMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSongPositionPointerMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSongPositionPointerMessage
    };

    // ----- MidiSongSelectMessage class --------------------
    static constexpr const char* const type_name_MidiSongSelectMessage = "MidiSongSelectMessage";

    static PyObject* _new_MidiSongSelectMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                winrt::Windows::Devices::Midi::MidiSongSelectMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSongSelectMessage(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSongSelectMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Song(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSongSelectMessage", L"Song"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Song());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSongSelectMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSongSelectMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSongSelectMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSongSelectMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSongSelectMessage[] = {
        { "_assign_array_", _assign_array_MidiSongSelectMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSongSelectMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSongSelectMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSongSelectMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSongSelectMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSongSelectMessage_get_Type), nullptr, nullptr, nullptr },
        { "song", reinterpret_cast<getter>(MidiSongSelectMessage_get_Song), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSongSelectMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSongSelectMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSongSelectMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSongSelectMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSongSelectMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSongSelectMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSongSelectMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSongSelectMessage
    };

    // ----- MidiStartMessage class --------------------
    static constexpr const char* const type_name_MidiStartMessage = "MidiStartMessage";

    static PyObject* _new_MidiStartMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiStartMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiStartMessage(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiStartMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStartMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStartMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStartMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStartMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStartMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiStartMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiStartMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiStartMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiStartMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiStartMessage[] = {
        { "_assign_array_", _assign_array_MidiStartMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiStartMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiStartMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiStartMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiStartMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiStartMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiStartMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiStartMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiStartMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiStartMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiStartMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiStartMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiStartMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiStartMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiStartMessage
    };

    // ----- MidiStopMessage class --------------------
    static constexpr const char* const type_name_MidiStopMessage = "MidiStopMessage";

    static PyObject* _new_MidiStopMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiStopMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiStopMessage(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiStopMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStopMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStopMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStopMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStopMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiStopMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiStopMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiStopMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiStopMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiStopMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiStopMessage[] = {
        { "_assign_array_", _assign_array_MidiStopMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiStopMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiStopMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiStopMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiStopMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiStopMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiStopMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiStopMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiStopMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiStopMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiStopMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiStopMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiStopMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiStopMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiStopMessage
    };

    // ----- MidiSynthesizer class --------------------
    static constexpr const char* const type_name_MidiSynthesizer = "MidiSynthesizer";

    static PyObject* _new_MidiSynthesizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiSynthesizer);
        return nullptr;
    }

    static void _dealloc_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSynthesizer_Close(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"CreateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::CreateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_IsSynthesizer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"IsSynthesizer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::IsSynthesizer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_SendBuffer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"SendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_SendMessage(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"SendMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_get_Volume(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MidiSynthesizer_put_Volume(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"Volume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Volume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MidiSynthesizer_get_AudioDevice(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSynthesizer", L"AudioDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSynthesizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSynthesizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSynthesizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSynthesizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSynthesizer[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiSynthesizer_Close), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(MidiSynthesizer_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_synthesizer", reinterpret_cast<PyCFunction>(MidiSynthesizer_IsSynthesizer), METH_VARARGS | METH_STATIC, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(MidiSynthesizer_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(MidiSynthesizer_SendMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MidiSynthesizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSynthesizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiSynthesizer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiSynthesizer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSynthesizer[] = {
        { "device_id", reinterpret_cast<getter>(MidiSynthesizer_get_DeviceId), nullptr, nullptr, nullptr },
        { "volume", reinterpret_cast<getter>(MidiSynthesizer_get_Volume), reinterpret_cast<setter>(MidiSynthesizer_put_Volume), nullptr, nullptr },
        { "audio_device", reinterpret_cast<getter>(MidiSynthesizer_get_AudioDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSynthesizer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSynthesizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSynthesizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSynthesizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSynthesizer) },
        { },
    };

    static PyType_Spec type_spec_MidiSynthesizer =
    {
        "_winsdk_Windows_Devices_Midi.MidiSynthesizer",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSynthesizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSynthesizer
    };

    // ----- MidiSystemExclusiveMessage class --------------------
    static constexpr const char* const type_name_MidiSystemExclusiveMessage = "MidiSystemExclusiveMessage";

    static PyObject* _new_MidiSystemExclusiveMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSystemExclusiveMessage(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSystemExclusiveMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemExclusiveMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemExclusiveMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemExclusiveMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemExclusiveMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemExclusiveMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSystemExclusiveMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSystemExclusiveMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSystemExclusiveMessage[] = {
        { "_assign_array_", _assign_array_MidiSystemExclusiveMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSystemExclusiveMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSystemExclusiveMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSystemExclusiveMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSystemExclusiveMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSystemExclusiveMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSystemExclusiveMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSystemExclusiveMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSystemExclusiveMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSystemExclusiveMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSystemExclusiveMessage
    };

    // ----- MidiSystemResetMessage class --------------------
    static constexpr const char* const type_name_MidiSystemResetMessage = "MidiSystemResetMessage";

    static PyObject* _new_MidiSystemResetMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiSystemResetMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSystemResetMessage(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSystemResetMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemResetMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemResetMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemResetMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemResetMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiSystemResetMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiSystemResetMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiSystemResetMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiSystemResetMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSystemResetMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSystemResetMessage[] = {
        { "_assign_array_", _assign_array_MidiSystemResetMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSystemResetMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSystemResetMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSystemResetMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSystemResetMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSystemResetMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSystemResetMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiSystemResetMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiSystemResetMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiSystemResetMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiSystemResetMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiSystemResetMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSystemResetMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSystemResetMessage
    };

    // ----- MidiTimeCodeMessage class --------------------
    static constexpr const char* const type_name_MidiTimeCodeMessage = "MidiTimeCodeMessage";

    static PyObject* _new_MidiTimeCodeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiTimeCodeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTimeCodeMessage(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTimeCodeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_FrameType(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"FrameType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Values(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimeCodeMessage", L"Values"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiTimeCodeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiTimeCodeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTimeCodeMessage[] = {
        { "_assign_array_", _assign_array_MidiTimeCodeMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTimeCodeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTimeCodeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTimeCodeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Type), nullptr, nullptr, nullptr },
        { "frame_type", reinterpret_cast<getter>(MidiTimeCodeMessage_get_FrameType), nullptr, nullptr, nullptr },
        { "values", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTimeCodeMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiTimeCodeMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiTimeCodeMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiTimeCodeMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiTimeCodeMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiTimeCodeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiTimeCodeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTimeCodeMessage
    };

    // ----- MidiTimingClockMessage class --------------------
    static constexpr const char* const type_name_MidiTimingClockMessage = "MidiTimingClockMessage";

    static PyObject* _new_MidiTimingClockMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiTimingClockMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTimingClockMessage(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTimingClockMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimingClockMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimingClockMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimingClockMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimingClockMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTimingClockMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiTimingClockMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiTimingClockMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiTimingClockMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTimingClockMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTimingClockMessage[] = {
        { "_assign_array_", _assign_array_MidiTimingClockMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTimingClockMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTimingClockMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTimingClockMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTimingClockMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTimingClockMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTimingClockMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiTimingClockMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiTimingClockMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiTimingClockMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiTimingClockMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiTimingClockMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiTimingClockMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTimingClockMessage
    };

    // ----- MidiTuneRequestMessage class --------------------
    static constexpr const char* const type_name_MidiTuneRequestMessage = "MidiTuneRequestMessage";

    static PyObject* _new_MidiTuneRequestMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiTuneRequestMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTuneRequestMessage(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTuneRequestMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTuneRequestMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTuneRequestMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTuneRequestMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTuneRequestMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.MidiTuneRequestMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MidiTuneRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MidiTuneRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTuneRequestMessage[] = {
        { "_assign_array_", _assign_array_MidiTuneRequestMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTuneRequestMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTuneRequestMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTuneRequestMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTuneRequestMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTuneRequestMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTuneRequestMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MidiTuneRequestMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MidiTuneRequestMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MidiTuneRequestMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MidiTuneRequestMessage) },
        { },
    };

    static PyType_Spec type_spec_MidiTuneRequestMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiTuneRequestMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTuneRequestMessage
    };

    // ----- IMidiMessage interface --------------------
    static constexpr const char* const type_name_IMidiMessage = "IMidiMessage";

    static PyObject* _new_IMidiMessage(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMidiMessage);
        return nullptr;
    }

    static void _dealloc_IMidiMessage(py::wrapper::Windows::Devices::Midi::IMidiMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMidiMessage_get_RawData(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiMessage", L"RawData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMidiMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiMessage", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMidiMessage_get_Type(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiMessage", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMidiMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::IMidiMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMidiMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::IMidiMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMidiMessage[] = {
        { "_assign_array_", _assign_array_IMidiMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMidiMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMidiMessage[] = {
        { "raw_data", reinterpret_cast<getter>(IMidiMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(IMidiMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMidiMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMidiMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMidiMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMidiMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMidiMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMidiMessage) },
        { },
    };

    static PyType_Spec type_spec_IMidiMessage =
    {
        "_winsdk_Windows_Devices_Midi.IMidiMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::IMidiMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMidiMessage
    };

    // ----- IMidiOutPort interface --------------------
    static constexpr const char* const type_name_IMidiOutPort = "IMidiOutPort";

    static PyObject* _new_IMidiOutPort(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IMidiOutPort);
        return nullptr;
    }

    static void _dealloc_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMidiOutPort_Close(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_SendBuffer(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.IMidiOutPort", L"SendBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_SendMessage(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Midi.IMidiOutPort", L"SendMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Midi.IMidiOutPort", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Midi::IMidiOutPort>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::IMidiOutPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMidiOutPort[] = {
        { "close", reinterpret_cast<PyCFunction>(IMidiOutPort_Close), METH_VARARGS, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(IMidiOutPort_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(IMidiOutPort_SendMessage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMidiOutPort, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMidiOutPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMidiOutPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IMidiOutPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMidiOutPort[] = {
        { "device_id", reinterpret_cast<getter>(IMidiOutPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMidiOutPort[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMidiOutPort) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMidiOutPort) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMidiOutPort) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMidiOutPort) },
        { },
    };

    static PyType_Spec type_spec_IMidiOutPort =
    {
        "_winsdk_Windows_Devices_Midi.IMidiOutPort",
        sizeof(py::wrapper::Windows::Devices::Midi::IMidiOutPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMidiOutPort
    };

    // ----- Windows.Devices.Midi Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Midi");

    static PyMethodDef module_methods[] = {
        {"_register_MidiMessageType", register_MidiMessageType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_MidiMessageType);
        Py_VISIT(state->type_MidiActiveSensingMessage);
        Py_VISIT(state->type_MidiChannelPressureMessage);
        Py_VISIT(state->type_MidiContinueMessage);
        Py_VISIT(state->type_MidiControlChangeMessage);
        Py_VISIT(state->type_MidiInPort);
        Py_VISIT(state->type_MidiMessageReceivedEventArgs);
        Py_VISIT(state->type_MidiNoteOffMessage);
        Py_VISIT(state->type_MidiNoteOnMessage);
        Py_VISIT(state->type_MidiOutPort);
        Py_VISIT(state->type_MidiPitchBendChangeMessage);
        Py_VISIT(state->type_MidiPolyphonicKeyPressureMessage);
        Py_VISIT(state->type_MidiProgramChangeMessage);
        Py_VISIT(state->type_MidiSongPositionPointerMessage);
        Py_VISIT(state->type_MidiSongSelectMessage);
        Py_VISIT(state->type_MidiStartMessage);
        Py_VISIT(state->type_MidiStopMessage);
        Py_VISIT(state->type_MidiSynthesizer);
        Py_VISIT(state->type_MidiSystemExclusiveMessage);
        Py_VISIT(state->type_MidiSystemResetMessage);
        Py_VISIT(state->type_MidiTimeCodeMessage);
        Py_VISIT(state->type_MidiTimingClockMessage);
        Py_VISIT(state->type_MidiTuneRequestMessage);
        Py_VISIT(state->type_IMidiMessage);
        Py_VISIT(state->type_IMidiOutPort);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_MidiMessageType);
        Py_CLEAR(state->type_MidiActiveSensingMessage);
        Py_CLEAR(state->type_MidiChannelPressureMessage);
        Py_CLEAR(state->type_MidiContinueMessage);
        Py_CLEAR(state->type_MidiControlChangeMessage);
        Py_CLEAR(state->type_MidiInPort);
        Py_CLEAR(state->type_MidiMessageReceivedEventArgs);
        Py_CLEAR(state->type_MidiNoteOffMessage);
        Py_CLEAR(state->type_MidiNoteOnMessage);
        Py_CLEAR(state->type_MidiOutPort);
        Py_CLEAR(state->type_MidiPitchBendChangeMessage);
        Py_CLEAR(state->type_MidiPolyphonicKeyPressureMessage);
        Py_CLEAR(state->type_MidiProgramChangeMessage);
        Py_CLEAR(state->type_MidiSongPositionPointerMessage);
        Py_CLEAR(state->type_MidiSongSelectMessage);
        Py_CLEAR(state->type_MidiStartMessage);
        Py_CLEAR(state->type_MidiStopMessage);
        Py_CLEAR(state->type_MidiSynthesizer);
        Py_CLEAR(state->type_MidiSystemExclusiveMessage);
        Py_CLEAR(state->type_MidiSystemResetMessage);
        Py_CLEAR(state->type_MidiTimeCodeMessage);
        Py_CLEAR(state->type_MidiTimingClockMessage);
        Py_CLEAR(state->type_MidiTuneRequestMessage);
        Py_CLEAR(state->type_IMidiMessage);
        Py_CLEAR(state->type_IMidiOutPort);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Midi",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Midi

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Midi(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Midi;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_MidiActiveSensingMessage = py::register_python_type(module.get(), type_name_MidiActiveSensingMessage, &type_spec_MidiActiveSensingMessage, bases.get(), nullptr);
    if (!state->type_MidiActiveSensingMessage)
    {
        return nullptr;
    }

    state->type_MidiChannelPressureMessage = py::register_python_type(module.get(), type_name_MidiChannelPressureMessage, &type_spec_MidiChannelPressureMessage, bases.get(), nullptr);
    if (!state->type_MidiChannelPressureMessage)
    {
        return nullptr;
    }

    state->type_MidiContinueMessage = py::register_python_type(module.get(), type_name_MidiContinueMessage, &type_spec_MidiContinueMessage, bases.get(), nullptr);
    if (!state->type_MidiContinueMessage)
    {
        return nullptr;
    }

    state->type_MidiControlChangeMessage = py::register_python_type(module.get(), type_name_MidiControlChangeMessage, &type_spec_MidiControlChangeMessage, bases.get(), nullptr);
    if (!state->type_MidiControlChangeMessage)
    {
        return nullptr;
    }

    state->type_MidiInPort = py::register_python_type(module.get(), type_name_MidiInPort, &type_spec_MidiInPort, bases.get(), nullptr);
    if (!state->type_MidiInPort)
    {
        return nullptr;
    }

    state->type_MidiMessageReceivedEventArgs = py::register_python_type(module.get(), type_name_MidiMessageReceivedEventArgs, &type_spec_MidiMessageReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_MidiMessageReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_MidiNoteOffMessage = py::register_python_type(module.get(), type_name_MidiNoteOffMessage, &type_spec_MidiNoteOffMessage, bases.get(), nullptr);
    if (!state->type_MidiNoteOffMessage)
    {
        return nullptr;
    }

    state->type_MidiNoteOnMessage = py::register_python_type(module.get(), type_name_MidiNoteOnMessage, &type_spec_MidiNoteOnMessage, bases.get(), nullptr);
    if (!state->type_MidiNoteOnMessage)
    {
        return nullptr;
    }

    state->type_MidiOutPort = py::register_python_type(module.get(), type_name_MidiOutPort, &type_spec_MidiOutPort, bases.get(), nullptr);
    if (!state->type_MidiOutPort)
    {
        return nullptr;
    }

    state->type_MidiPitchBendChangeMessage = py::register_python_type(module.get(), type_name_MidiPitchBendChangeMessage, &type_spec_MidiPitchBendChangeMessage, bases.get(), nullptr);
    if (!state->type_MidiPitchBendChangeMessage)
    {
        return nullptr;
    }

    state->type_MidiPolyphonicKeyPressureMessage = py::register_python_type(module.get(), type_name_MidiPolyphonicKeyPressureMessage, &type_spec_MidiPolyphonicKeyPressureMessage, bases.get(), nullptr);
    if (!state->type_MidiPolyphonicKeyPressureMessage)
    {
        return nullptr;
    }

    state->type_MidiProgramChangeMessage = py::register_python_type(module.get(), type_name_MidiProgramChangeMessage, &type_spec_MidiProgramChangeMessage, bases.get(), nullptr);
    if (!state->type_MidiProgramChangeMessage)
    {
        return nullptr;
    }

    state->type_MidiSongPositionPointerMessage = py::register_python_type(module.get(), type_name_MidiSongPositionPointerMessage, &type_spec_MidiSongPositionPointerMessage, bases.get(), nullptr);
    if (!state->type_MidiSongPositionPointerMessage)
    {
        return nullptr;
    }

    state->type_MidiSongSelectMessage = py::register_python_type(module.get(), type_name_MidiSongSelectMessage, &type_spec_MidiSongSelectMessage, bases.get(), nullptr);
    if (!state->type_MidiSongSelectMessage)
    {
        return nullptr;
    }

    state->type_MidiStartMessage = py::register_python_type(module.get(), type_name_MidiStartMessage, &type_spec_MidiStartMessage, bases.get(), nullptr);
    if (!state->type_MidiStartMessage)
    {
        return nullptr;
    }

    state->type_MidiStopMessage = py::register_python_type(module.get(), type_name_MidiStopMessage, &type_spec_MidiStopMessage, bases.get(), nullptr);
    if (!state->type_MidiStopMessage)
    {
        return nullptr;
    }

    state->type_MidiSynthesizer = py::register_python_type(module.get(), type_name_MidiSynthesizer, &type_spec_MidiSynthesizer, bases.get(), nullptr);
    if (!state->type_MidiSynthesizer)
    {
        return nullptr;
    }

    state->type_MidiSystemExclusiveMessage = py::register_python_type(module.get(), type_name_MidiSystemExclusiveMessage, &type_spec_MidiSystemExclusiveMessage, bases.get(), nullptr);
    if (!state->type_MidiSystemExclusiveMessage)
    {
        return nullptr;
    }

    state->type_MidiSystemResetMessage = py::register_python_type(module.get(), type_name_MidiSystemResetMessage, &type_spec_MidiSystemResetMessage, bases.get(), nullptr);
    if (!state->type_MidiSystemResetMessage)
    {
        return nullptr;
    }

    state->type_MidiTimeCodeMessage = py::register_python_type(module.get(), type_name_MidiTimeCodeMessage, &type_spec_MidiTimeCodeMessage, bases.get(), nullptr);
    if (!state->type_MidiTimeCodeMessage)
    {
        return nullptr;
    }

    state->type_MidiTimingClockMessage = py::register_python_type(module.get(), type_name_MidiTimingClockMessage, &type_spec_MidiTimingClockMessage, bases.get(), nullptr);
    if (!state->type_MidiTimingClockMessage)
    {
        return nullptr;
    }

    state->type_MidiTuneRequestMessage = py::register_python_type(module.get(), type_name_MidiTuneRequestMessage, &type_spec_MidiTuneRequestMessage, bases.get(), nullptr);
    if (!state->type_MidiTuneRequestMessage)
    {
        return nullptr;
    }

    state->type_IMidiMessage = py::register_python_type(module.get(), type_name_IMidiMessage, &type_spec_IMidiMessage, bases.get(), nullptr);
    if (!state->type_IMidiMessage)
    {
        return nullptr;
    }

    state->type_IMidiOutPort = py::register_python_type(module.get(), type_name_IMidiOutPort, &type_spec_IMidiOutPort, bases.get(), nullptr);
    if (!state->type_IMidiOutPort)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Midi::MidiMessageType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiMessageType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiMessageType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiActiveSensingMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiActiveSensingMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiChannelPressureMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiChannelPressureMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiContinueMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiContinueMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiContinueMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiControlChangeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiControlChangeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiControlChangeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiInPort>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiInPort;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiInPort is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiMessageReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiNoteOffMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiNoteOffMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiNoteOffMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiNoteOnMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiNoteOnMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiNoteOnMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiOutPort>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiOutPort;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiOutPort is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiPitchBendChangeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiPolyphonicKeyPressureMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiProgramChangeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiProgramChangeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSongPositionPointerMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSongSelectMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSongSelectMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSongSelectMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiStartMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiStartMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiStartMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiStopMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiStopMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiStopMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSynthesizer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSynthesizer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSynthesizer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSystemExclusiveMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSystemResetMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSystemResetMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSystemResetMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiTimeCodeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiTimeCodeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiTimingClockMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiTimingClockMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiTimingClockMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiTuneRequestMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiTuneRequestMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::IMidiMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMidiMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::IMidiMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::IMidiOutPort>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMidiOutPort;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::IMidiOutPort is not registered");
        return nullptr;
    }

    return python_type;
}
