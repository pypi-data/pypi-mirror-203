// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Gaming.Input.Custom.h"


PyObject* py::converter<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::convert(winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo py::converter<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::convert(winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress py::converter<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress");
    throw python_exception();
}

namespace py::cpp::Windows::Gaming::Input::Custom
{
    struct module_state
    {
        PyObject* type_GipFirmwareUpdateStatus;
        PyObject* type_GipMessageClass;
        PyObject* type_XusbDeviceSubtype;
        PyObject* type_XusbDeviceType;
        PyTypeObject* type_GameControllerFactoryManager;
        PyTypeObject* type_GipFirmwareUpdateResult;
        PyTypeObject* type_GipGameControllerProvider;
        PyTypeObject* type_HidGameControllerProvider;
        PyTypeObject* type_XusbGameControllerProvider;
        PyTypeObject* type_ICustomGameControllerFactory;
        PyTypeObject* type_IGameControllerInputSink;
        PyTypeObject* type_IGameControllerProvider;
        PyTypeObject* type_IGipGameControllerInputSink;
        PyTypeObject* type_IHidGameControllerInputSink;
        PyTypeObject* type_IXusbGameControllerInputSink;
        PyTypeObject* type_GameControllerVersionInfo;
        PyTypeObject* type_GipFirmwareUpdateProgress;
    };

    static PyObject* register_GipFirmwareUpdateStatus(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GipFirmwareUpdateStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GipFirmwareUpdateStatus = type;
        Py_INCREF(state->type_GipFirmwareUpdateStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_GipMessageClass(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GipMessageClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GipMessageClass = type;
        Py_INCREF(state->type_GipMessageClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_XusbDeviceSubtype(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_XusbDeviceSubtype)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_XusbDeviceSubtype = type;
        Py_INCREF(state->type_XusbDeviceSubtype);


        Py_RETURN_NONE;
    }

    static PyObject* register_XusbDeviceType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_XusbDeviceType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_XusbDeviceType = type;
        Py_INCREF(state->type_XusbDeviceType);


        Py_RETURN_NONE;
    }

    // ----- GameControllerFactoryManager class --------------------
    static constexpr const char* const type_name_GameControllerFactoryManager = "GameControllerFactoryManager";

    static PyObject* _new_GameControllerFactoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GameControllerFactoryManager);
        return nullptr;
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForGipInterface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForGipInterface", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForGipInterface(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForHardwareId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForHardwareId", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForHardwareId(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForXusbType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForXusbType", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceSubtype>(args, 2);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForXusbType(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_TryGetFactoryControllerFromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"TryGetFactoryControllerFromGameController", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 1);

                return py::convert(winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::TryGetFactoryControllerFromGameController(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameControllerFactoryManager[] = {
        { "register_custom_factory_for_gip_interface", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForGipInterface), METH_VARARGS | METH_STATIC, nullptr },
        { "register_custom_factory_for_hardware_id", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForHardwareId), METH_VARARGS | METH_STATIC, nullptr },
        { "register_custom_factory_for_xusb_type", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForXusbType), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_factory_controller_from_game_controller", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_TryGetFactoryControllerFromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameControllerFactoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_GameControllerFactoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameControllerFactoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameControllerFactoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameControllerFactoryManager) },
        { },
    };

    static PyType_Spec type_spec_GameControllerFactoryManager =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GameControllerFactoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerFactoryManager
    };

    // ----- GipFirmwareUpdateResult class --------------------
    static constexpr const char* const type_name_GipFirmwareUpdateResult = "GipFirmwareUpdateResult";

    static PyObject* _new_GipFirmwareUpdateResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GipFirmwareUpdateResult);
        return nullptr;
    }

    static void _dealloc_GipFirmwareUpdateResult(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GipFirmwareUpdateResult_get_ExtendedErrorCode(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_FinalComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"FinalComponentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FinalComponentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_Status(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipFirmwareUpdateResult[] = {
        { "_assign_array_", _assign_array_GipFirmwareUpdateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipFirmwareUpdateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GipFirmwareUpdateResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "final_component_id", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_FinalComponentId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipFirmwareUpdateResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipFirmwareUpdateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipFirmwareUpdateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipFirmwareUpdateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipFirmwareUpdateResult) },
        { },
    };

    static PyType_Spec type_spec_GipFirmwareUpdateResult =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GipFirmwareUpdateResult",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateResult
    };

    // ----- GipGameControllerProvider class --------------------
    static constexpr const char* const type_name_GipGameControllerProvider = "GipGameControllerProvider";

    static PyObject* _new_GipGameControllerProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_GipGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_GipGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GipGameControllerProvider_SendMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"SendMessage", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.SendMessage(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_SendReceiveMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"SendReceiveMessage", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 3);

                self->obj.SendReceiveMessage(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_UpdateFirmwareAsync(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"UpdateFirmwareAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.UpdateFirmwareAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipGameControllerProvider[] = {
        { "send_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendMessage), METH_VARARGS, nullptr },
        { "send_receive_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendReceiveMessage), METH_VARARGS, nullptr },
        { "update_firmware_async", reinterpret_cast<PyCFunction>(GipGameControllerProvider_UpdateFirmwareAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GipGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GipGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(GipGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_GipGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GipGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipGameControllerProvider
    };

    // ----- HidGameControllerProvider class --------------------
    static constexpr const char* const type_name_HidGameControllerProvider = "HidGameControllerProvider";

    static PyObject* _new_HidGameControllerProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_HidGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidGameControllerProvider_GetFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"GetFeatureReport", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 1);

                self->obj.GetFeatureReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"SendFeatureReport", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                self->obj.SendFeatureReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendOutputReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"SendOutputReport", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                self->obj.SendOutputReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsageId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsagePage(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidGameControllerProvider[] = {
        { "get_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_GetFeatureReport), METH_VARARGS, nullptr },
        { "send_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendFeatureReport), METH_VARARGS, nullptr },
        { "send_output_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendOutputReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(HidGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidGameControllerProvider_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidGameControllerProvider_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_HidGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.HidGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidGameControllerProvider
    };

    // ----- XusbGameControllerProvider class --------------------
    static constexpr const char* const type_name_XusbGameControllerProvider = "XusbGameControllerProvider";

    static PyObject* _new_XusbGameControllerProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_XusbGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_XusbGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XusbGameControllerProvider_SetVibration(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"SetVibration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetVibration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XusbGameControllerProvider[] = {
        { "set_vibration", reinterpret_cast<PyCFunction>(XusbGameControllerProvider_SetVibration), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XusbGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XusbGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XusbGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(XusbGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XusbGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XusbGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XusbGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XusbGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XusbGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_XusbGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.XusbGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XusbGameControllerProvider
    };

    // ----- ICustomGameControllerFactory interface --------------------
    static constexpr const char* const type_name_ICustomGameControllerFactory = "ICustomGameControllerFactory";

    static PyObject* _new_ICustomGameControllerFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_ICustomGameControllerFactory);
        return nullptr;
    }

    static void _dealloc_ICustomGameControllerFactory(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomGameControllerFactory_CreateGameController(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"CreateGameController", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>(args, 0);

                return py::convert(self->obj.CreateGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerAdded(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"OnGameControllerAdded", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                self->obj.OnGameControllerAdded(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerRemoved(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"OnGameControllerRemoved", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                self->obj.OnGameControllerRemoved(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomGameControllerFactory[] = {
        { "create_game_controller", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_CreateGameController), METH_VARARGS, nullptr },
        { "on_game_controller_added", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerAdded), METH_VARARGS, nullptr },
        { "on_game_controller_removed", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerRemoved), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICustomGameControllerFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomGameControllerFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICustomGameControllerFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_ICustomGameControllerFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomGameControllerFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomGameControllerFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomGameControllerFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomGameControllerFactory) },
        { },
    };

    static PyType_Spec type_spec_ICustomGameControllerFactory =
    {
        "_winsdk_Windows_Gaming_Input_Custom.ICustomGameControllerFactory",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomGameControllerFactory
    };

    // ----- IGameControllerInputSink interface --------------------
    static constexpr const char* const type_name_IGameControllerInputSink = "IGameControllerInputSink";

    static PyObject* _new_IGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerInputSink
    };

    // ----- IGameControllerProvider interface --------------------
    static constexpr const char* const type_name_IGameControllerProvider = "IGameControllerProvider";

    static PyObject* _new_IGameControllerProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_IGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerProvider[] = {
        { "_assign_array_", _assign_array_IGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(IGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_IGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerProvider
    };

    // ----- IGipGameControllerInputSink interface --------------------
    static constexpr const char* const type_name_IGipGameControllerInputSink = "IGipGameControllerInputSink";

    static PyObject* _new_IGipGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IGipGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IGipGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGipGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnKeyReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGipGameControllerInputSink", L"OnKeyReceived", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.OnKeyReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnMessageReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGipGameControllerInputSink", L"OnMessageReceived", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 4);

                self->obj.OnMessageReceived(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGipGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "on_key_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnKeyReceived), METH_VARARGS, nullptr },
        { "on_message_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnMessageReceived), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGipGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGipGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGipGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IGipGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGipGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGipGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGipGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGipGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IGipGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IGipGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGipGameControllerInputSink
    };

    // ----- IHidGameControllerInputSink interface --------------------
    static constexpr const char* const type_name_IHidGameControllerInputSink = "IHidGameControllerInputSink";

    static PyObject* _new_IHidGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IHidGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IHidGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IHidGameControllerInputSink_OnInputReportReceived(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IHidGameControllerInputSink", L"OnInputReportReceived", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.OnInputReportReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHidGameControllerInputSink[] = {
        { "on_input_report_received", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputReportReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IHidGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IHidGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IHidGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IHidGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IHidGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IHidGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IHidGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IHidGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IHidGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IHidGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHidGameControllerInputSink
    };

    // ----- IXusbGameControllerInputSink interface --------------------
    static constexpr const char* const type_name_IXusbGameControllerInputSink = "IXusbGameControllerInputSink";

    static PyObject* _new_IXusbGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IXusbGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IXusbGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXusbGameControllerInputSink_OnInputReceived(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IXusbGameControllerInputSink", L"OnInputReceived", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.OnInputReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXusbGameControllerInputSink[] = {
        { "on_input_received", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXusbGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXusbGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXusbGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IXusbGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXusbGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXusbGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXusbGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXusbGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IXusbGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IXusbGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXusbGameControllerInputSink
    };

    // ----- GameControllerVersionInfo struct --------------------
    static constexpr const char* const type_name_GameControllerVersionInfo = "GameControllerVersionInfo";

    PyObject* _new_GameControllerVersionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo return_value{ _Major, _Minor, _Build, _Revision };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GameControllerVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self) noexcept
    {
    }

    static PyObject* GameControllerVersionInfo_get_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GameControllerVersionInfo[] = {
        { "major", reinterpret_cast<getter>(GameControllerVersionInfo_get_Major), reinterpret_cast<setter>(GameControllerVersionInfo_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(GameControllerVersionInfo_get_Minor), reinterpret_cast<setter>(GameControllerVersionInfo_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(GameControllerVersionInfo_get_Build), reinterpret_cast<setter>(GameControllerVersionInfo_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(GameControllerVersionInfo_get_Revision), reinterpret_cast<setter>(GameControllerVersionInfo_set_Revision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameControllerVersionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameControllerVersionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameControllerVersionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameControllerVersionInfo) },
        { },
    };

    static PyType_Spec type_spec_GameControllerVersionInfo =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GameControllerVersionInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerVersionInfo
    };

    // ----- GipFirmwareUpdateProgress struct --------------------
    static constexpr const char* const type_name_GipFirmwareUpdateProgress = "GipFirmwareUpdateProgress";

    PyObject* _new_GipFirmwareUpdateProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _PercentCompleted{};
        uint32_t _CurrentComponentId{};

        static const char* kwlist[] = {"percent_completed", "current_component_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dI", const_cast<char**>(kwlist), &_PercentCompleted, &_CurrentComponentId))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress return_value{ _PercentCompleted, _CurrentComponentId };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GipFirmwareUpdateProgress(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self) noexcept
    {
    }

    static PyObject* GipFirmwareUpdateProgress_get_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentCompleted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentCompleted = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GipFirmwareUpdateProgress_get_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentComponentId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.CurrentComponentId = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GipFirmwareUpdateProgress[] = {
        { "percent_completed", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_PercentCompleted), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_PercentCompleted), nullptr, nullptr },
        { "current_component_id", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_CurrentComponentId), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_CurrentComponentId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipFirmwareUpdateProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipFirmwareUpdateProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipFirmwareUpdateProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipFirmwareUpdateProgress) },
        { },
    };

    static PyType_Spec type_spec_GipFirmwareUpdateProgress =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GipFirmwareUpdateProgress",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateProgress
    };

    // ----- Windows.Gaming.Input.Custom Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Gaming::Input::Custom");

    static PyMethodDef module_methods[] = {
        {"_register_GipFirmwareUpdateStatus", register_GipFirmwareUpdateStatus, METH_O, "registers type"},
        {"_register_GipMessageClass", register_GipMessageClass, METH_O, "registers type"},
        {"_register_XusbDeviceSubtype", register_XusbDeviceSubtype, METH_O, "registers type"},
        {"_register_XusbDeviceType", register_XusbDeviceType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_GipFirmwareUpdateStatus);
        Py_VISIT(state->type_GipMessageClass);
        Py_VISIT(state->type_XusbDeviceSubtype);
        Py_VISIT(state->type_XusbDeviceType);
        Py_VISIT(state->type_GameControllerFactoryManager);
        Py_VISIT(state->type_GipFirmwareUpdateResult);
        Py_VISIT(state->type_GipGameControllerProvider);
        Py_VISIT(state->type_HidGameControllerProvider);
        Py_VISIT(state->type_XusbGameControllerProvider);
        Py_VISIT(state->type_ICustomGameControllerFactory);
        Py_VISIT(state->type_IGameControllerInputSink);
        Py_VISIT(state->type_IGameControllerProvider);
        Py_VISIT(state->type_IGipGameControllerInputSink);
        Py_VISIT(state->type_IHidGameControllerInputSink);
        Py_VISIT(state->type_IXusbGameControllerInputSink);
        Py_VISIT(state->type_GameControllerVersionInfo);
        Py_VISIT(state->type_GipFirmwareUpdateProgress);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_GipFirmwareUpdateStatus);
        Py_CLEAR(state->type_GipMessageClass);
        Py_CLEAR(state->type_XusbDeviceSubtype);
        Py_CLEAR(state->type_XusbDeviceType);
        Py_CLEAR(state->type_GameControllerFactoryManager);
        Py_CLEAR(state->type_GipFirmwareUpdateResult);
        Py_CLEAR(state->type_GipGameControllerProvider);
        Py_CLEAR(state->type_HidGameControllerProvider);
        Py_CLEAR(state->type_XusbGameControllerProvider);
        Py_CLEAR(state->type_ICustomGameControllerFactory);
        Py_CLEAR(state->type_IGameControllerInputSink);
        Py_CLEAR(state->type_IGameControllerProvider);
        Py_CLEAR(state->type_IGipGameControllerInputSink);
        Py_CLEAR(state->type_IHidGameControllerInputSink);
        Py_CLEAR(state->type_IXusbGameControllerInputSink);
        Py_CLEAR(state->type_GameControllerVersionInfo);
        Py_CLEAR(state->type_GipFirmwareUpdateProgress);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Gaming_Input_Custom",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Gaming::Input::Custom

PyMODINIT_FUNC PyInit__winsdk_Windows_Gaming_Input_Custom(void) noexcept
{
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_GameControllerFactoryManager = py::register_python_type(module.get(), type_name_GameControllerFactoryManager, &type_spec_GameControllerFactoryManager, nullptr, nullptr);
    if (!state->type_GameControllerFactoryManager)
    {
        return nullptr;
    }

    state->type_GipFirmwareUpdateResult = py::register_python_type(module.get(), type_name_GipFirmwareUpdateResult, &type_spec_GipFirmwareUpdateResult, bases.get(), nullptr);
    if (!state->type_GipFirmwareUpdateResult)
    {
        return nullptr;
    }

    state->type_GipGameControllerProvider = py::register_python_type(module.get(), type_name_GipGameControllerProvider, &type_spec_GipGameControllerProvider, bases.get(), nullptr);
    if (!state->type_GipGameControllerProvider)
    {
        return nullptr;
    }

    state->type_HidGameControllerProvider = py::register_python_type(module.get(), type_name_HidGameControllerProvider, &type_spec_HidGameControllerProvider, bases.get(), nullptr);
    if (!state->type_HidGameControllerProvider)
    {
        return nullptr;
    }

    state->type_XusbGameControllerProvider = py::register_python_type(module.get(), type_name_XusbGameControllerProvider, &type_spec_XusbGameControllerProvider, bases.get(), nullptr);
    if (!state->type_XusbGameControllerProvider)
    {
        return nullptr;
    }

    state->type_ICustomGameControllerFactory = py::register_python_type(module.get(), type_name_ICustomGameControllerFactory, &type_spec_ICustomGameControllerFactory, bases.get(), nullptr);
    if (!state->type_ICustomGameControllerFactory)
    {
        return nullptr;
    }

    state->type_IGameControllerInputSink = py::register_python_type(module.get(), type_name_IGameControllerInputSink, &type_spec_IGameControllerInputSink, bases.get(), nullptr);
    if (!state->type_IGameControllerInputSink)
    {
        return nullptr;
    }

    state->type_IGameControllerProvider = py::register_python_type(module.get(), type_name_IGameControllerProvider, &type_spec_IGameControllerProvider, bases.get(), nullptr);
    if (!state->type_IGameControllerProvider)
    {
        return nullptr;
    }

    state->type_IGipGameControllerInputSink = py::register_python_type(module.get(), type_name_IGipGameControllerInputSink, &type_spec_IGipGameControllerInputSink, bases.get(), nullptr);
    if (!state->type_IGipGameControllerInputSink)
    {
        return nullptr;
    }

    state->type_IHidGameControllerInputSink = py::register_python_type(module.get(), type_name_IHidGameControllerInputSink, &type_spec_IHidGameControllerInputSink, bases.get(), nullptr);
    if (!state->type_IHidGameControllerInputSink)
    {
        return nullptr;
    }

    state->type_IXusbGameControllerInputSink = py::register_python_type(module.get(), type_name_IXusbGameControllerInputSink, &type_spec_IXusbGameControllerInputSink, bases.get(), nullptr);
    if (!state->type_IXusbGameControllerInputSink)
    {
        return nullptr;
    }

    state->type_GameControllerVersionInfo = py::register_python_type(module.get(), type_name_GameControllerVersionInfo, &type_spec_GameControllerVersionInfo, bases.get(), nullptr);
    if (!state->type_GameControllerVersionInfo)
    {
        return nullptr;
    }

    state->type_GipFirmwareUpdateProgress = py::register_python_type(module.get(), type_name_GipFirmwareUpdateProgress, &type_spec_GipFirmwareUpdateProgress, bases.get(), nullptr);
    if (!state->type_GipFirmwareUpdateProgress)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GipFirmwareUpdateStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::Custom::GipMessageClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GipMessageClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GipMessageClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::Custom::XusbDeviceSubtype>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_XusbDeviceSubtype;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::XusbDeviceSubtype is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::Custom::XusbDeviceType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_XusbDeviceType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::XusbDeviceType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameControllerFactoryManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GipFirmwareUpdateResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GipGameControllerProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidGameControllerProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_XusbGameControllerProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICustomGameControllerFactory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IGameControllerInputSink;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IGameControllerProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::IGameControllerProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IGipGameControllerInputSink;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IHidGameControllerInputSink;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IXusbGameControllerInputSink;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameControllerVersionInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input::Custom");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GipFirmwareUpdateProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress is not registered");
        return nullptr;
    }

    return python_type;
}
