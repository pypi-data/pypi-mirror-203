// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Media.Effects.h"


namespace py::cpp::Windows::Media::Effects
{
    struct module_state
    {
        PyObject* type_AudioEffectType;
        PyObject* type_MediaEffectClosedReason;
        PyObject* type_MediaMemoryTypes;
        PyTypeObject* type_AudioCaptureEffectsManager;
        PyTypeObject* type_AudioEffect;
        PyTypeObject* type_AudioEffectDefinition;
        PyTypeObject* type_AudioEffectsManager;
        PyTypeObject* type_AudioRenderEffectsManager;
        PyTypeObject* type_CompositeVideoFrameContext;
        PyTypeObject* type_ProcessAudioFrameContext;
        PyTypeObject* type_ProcessVideoFrameContext;
        PyTypeObject* type_SlowMotionEffectDefinition;
        PyTypeObject* type_VideoCompositorDefinition;
        PyTypeObject* type_VideoEffectDefinition;
        PyTypeObject* type_VideoTransformEffectDefinition;
        PyTypeObject* type_VideoTransformSphericalProjection;
        PyTypeObject* type_IAudioEffectDefinition;
        PyTypeObject* type_IBasicAudioEffect;
        PyTypeObject* type_IBasicVideoEffect;
        PyTypeObject* type_IVideoCompositor;
        PyTypeObject* type_IVideoCompositorDefinition;
        PyTypeObject* type_IVideoEffectDefinition;
    };

    static PyObject* register_AudioEffectType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioEffectType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioEffectType = type;
        Py_INCREF(state->type_AudioEffectType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaEffectClosedReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaEffectClosedReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaEffectClosedReason = type;
        Py_INCREF(state->type_MediaEffectClosedReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaMemoryTypes(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaMemoryTypes)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaMemoryTypes = type;
        Py_INCREF(state->type_MediaMemoryTypes);


        Py_RETURN_NONE;
    }

    // ----- AudioCaptureEffectsManager class --------------------
    static constexpr const char* const type_name_AudioCaptureEffectsManager = "AudioCaptureEffectsManager";

    static PyObject* _new_AudioCaptureEffectsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioCaptureEffectsManager);
        return nullptr;
    }

    static void _dealloc_AudioCaptureEffectsManager(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioCaptureEffectsManager_GetAudioCaptureEffects(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioCaptureEffectsManager", L"GetAudioCaptureEffects", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioCaptureEffects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioCaptureEffectsManager_add_AudioCaptureEffectsChanged(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioCaptureEffectsManager", L"AudioCaptureEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Effects::AudioCaptureEffectsManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioCaptureEffectsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioCaptureEffectsManager_remove_AudioCaptureEffectsChanged(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioCaptureEffectsManager", L"AudioCaptureEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioCaptureEffectsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioCaptureEffectsManager[] = {
        { "get_audio_capture_effects", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_GetAudioCaptureEffects), METH_VARARGS, nullptr },
        { "add_audio_capture_effects_changed", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_add_AudioCaptureEffectsChanged), METH_O, nullptr },
        { "remove_audio_capture_effects_changed", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_remove_AudioCaptureEffectsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioCaptureEffectsManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioCaptureEffectsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioCaptureEffectsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioCaptureEffectsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioCaptureEffectsManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioCaptureEffectsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioCaptureEffectsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioCaptureEffectsManager) },
        { },
    };

    static PyType_Spec type_spec_AudioCaptureEffectsManager =
    {
        "_winsdk_Windows_Media_Effects.AudioCaptureEffectsManager",
        sizeof(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioCaptureEffectsManager
    };

    // ----- AudioEffect class --------------------
    static constexpr const char* const type_name_AudioEffect = "AudioEffect";

    static PyObject* _new_AudioEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioEffect);
        return nullptr;
    }

    static void _dealloc_AudioEffect(py::wrapper::Windows::Media::Effects::AudioEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEffect_get_AudioEffectType(py::wrapper::Windows::Media::Effects::AudioEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioEffect", L"AudioEffectType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioEffectType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffect[] = {
        { "_assign_array_", _assign_array_AudioEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffect[] = {
        { "audio_effect_type", reinterpret_cast<getter>(AudioEffect_get_AudioEffectType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffect) },
        { },
    };

    static PyType_Spec type_spec_AudioEffect =
    {
        "_winsdk_Windows_Media_Effects.AudioEffect",
        sizeof(py::wrapper::Windows::Media::Effects::AudioEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffect
    };

    // ----- AudioEffectDefinition class --------------------
    static constexpr const char* const type_name_AudioEffectDefinition = "AudioEffectDefinition";

    static PyObject* _new_AudioEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::AudioEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::AudioEffectDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEffectDefinition(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectDefinition[] = {
        { "_assign_array_", _assign_array_AudioEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(AudioEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AudioEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_AudioEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.AudioEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::AudioEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectDefinition
    };

    // ----- AudioEffectsManager class --------------------
    static constexpr const char* const type_name_AudioEffectsManager = "AudioEffectsManager";

    static PyObject* _new_AudioEffectsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioEffectsManager);
        return nullptr;
    }

    static PyObject* AudioEffectsManager_CreateAudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioCaptureEffectsManager", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 1);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioCaptureEffectsManager(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioCaptureEffectsManager", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::AudioProcessing>(args, 2);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioCaptureEffectsManager(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEffectsManager_CreateAudioRenderEffectsManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioRenderEffectsManager", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 1);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioRenderEffectsManager(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioEffectsManager", L"CreateAudioRenderEffectsManager", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::AudioProcessing>(args, 2);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioRenderEffectsManager(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectsManager[] = {
        { "create_audio_capture_effects_manager", reinterpret_cast<PyCFunction>(AudioEffectsManager_CreateAudioCaptureEffectsManager), METH_VARARGS | METH_STATIC, nullptr },
        { "create_audio_render_effects_manager", reinterpret_cast<PyCFunction>(AudioEffectsManager_CreateAudioRenderEffectsManager), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffectsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioEffectsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioEffectsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioEffectsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioEffectsManager) },
        { },
    };

    static PyType_Spec type_spec_AudioEffectsManager =
    {
        "_winsdk_Windows_Media_Effects.AudioEffectsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectsManager
    };

    // ----- AudioRenderEffectsManager class --------------------
    static constexpr const char* const type_name_AudioRenderEffectsManager = "AudioRenderEffectsManager";

    static PyObject* _new_AudioRenderEffectsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioRenderEffectsManager);
        return nullptr;
    }

    static void _dealloc_AudioRenderEffectsManager(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioRenderEffectsManager_GetAudioRenderEffects(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"GetAudioRenderEffects", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioRenderEffects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_ShowSettingsUI(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"ShowSettingsUI", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_get_EffectsProviderSettingsLabel(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"EffectsProviderSettingsLabel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectsProviderSettingsLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_get_EffectsProviderThumbnail(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"EffectsProviderThumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectsProviderThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_add_AudioRenderEffectsChanged(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"AudioRenderEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Effects::AudioRenderEffectsManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRenderEffectsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_remove_AudioRenderEffectsChanged(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Effects.AudioRenderEffectsManager", L"AudioRenderEffectsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRenderEffectsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioRenderEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::AudioRenderEffectsManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioRenderEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioRenderEffectsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioRenderEffectsManager[] = {
        { "get_audio_render_effects", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_GetAudioRenderEffects), METH_VARARGS, nullptr },
        { "show_settings_u_i", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_ShowSettingsUI), METH_VARARGS, nullptr },
        { "add_audio_render_effects_changed", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_add_AudioRenderEffectsChanged), METH_O, nullptr },
        { "remove_audio_render_effects_changed", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_remove_AudioRenderEffectsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioRenderEffectsManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioRenderEffectsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioRenderEffectsManager[] = {
        { "effects_provider_settings_label", reinterpret_cast<getter>(AudioRenderEffectsManager_get_EffectsProviderSettingsLabel), nullptr, nullptr, nullptr },
        { "effects_provider_thumbnail", reinterpret_cast<getter>(AudioRenderEffectsManager_get_EffectsProviderThumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioRenderEffectsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioRenderEffectsManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioRenderEffectsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioRenderEffectsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioRenderEffectsManager) },
        { },
    };

    static PyType_Spec type_spec_AudioRenderEffectsManager =
    {
        "_winsdk_Windows_Media_Effects.AudioRenderEffectsManager",
        sizeof(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioRenderEffectsManager
    };

    // ----- CompositeVideoFrameContext class --------------------
    static constexpr const char* const type_name_CompositeVideoFrameContext = "CompositeVideoFrameContext";

    static PyObject* _new_CompositeVideoFrameContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CompositeVideoFrameContext);
        return nullptr;
    }

    static void _dealloc_CompositeVideoFrameContext(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositeVideoFrameContext_GetOverlayForSurface(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"GetOverlayForSurface", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(self->obj.GetOverlayForSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_BackgroundFrame(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"BackgroundFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BackgroundFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"OutputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_SurfacesToOverlay(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.CompositeVideoFrameContext", L"SurfacesToOverlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SurfacesToOverlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositeVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::CompositeVideoFrameContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositeVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::CompositeVideoFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositeVideoFrameContext[] = {
        { "get_overlay_for_surface", reinterpret_cast<PyCFunction>(CompositeVideoFrameContext_GetOverlayForSurface), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CompositeVideoFrameContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositeVideoFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositeVideoFrameContext[] = {
        { "background_frame", reinterpret_cast<getter>(CompositeVideoFrameContext_get_BackgroundFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(CompositeVideoFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { "surfaces_to_overlay", reinterpret_cast<getter>(CompositeVideoFrameContext_get_SurfacesToOverlay), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositeVideoFrameContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositeVideoFrameContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositeVideoFrameContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositeVideoFrameContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositeVideoFrameContext) },
        { },
    };

    static PyType_Spec type_spec_CompositeVideoFrameContext =
    {
        "_winsdk_Windows_Media_Effects.CompositeVideoFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositeVideoFrameContext
    };

    // ----- ProcessAudioFrameContext class --------------------
    static constexpr const char* const type_name_ProcessAudioFrameContext = "ProcessAudioFrameContext";

    static PyObject* _new_ProcessAudioFrameContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessAudioFrameContext);
        return nullptr;
    }

    static void _dealloc_ProcessAudioFrameContext(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessAudioFrameContext_get_InputFrame(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessAudioFrameContext", L"InputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessAudioFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessAudioFrameContext", L"OutputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessAudioFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::ProcessAudioFrameContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessAudioFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::ProcessAudioFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessAudioFrameContext[] = {
        { "_assign_array_", _assign_array_ProcessAudioFrameContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessAudioFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessAudioFrameContext[] = {
        { "input_frame", reinterpret_cast<getter>(ProcessAudioFrameContext_get_InputFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(ProcessAudioFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessAudioFrameContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessAudioFrameContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessAudioFrameContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessAudioFrameContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessAudioFrameContext) },
        { },
    };

    static PyType_Spec type_spec_ProcessAudioFrameContext =
    {
        "_winsdk_Windows_Media_Effects.ProcessAudioFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessAudioFrameContext
    };

    // ----- ProcessVideoFrameContext class --------------------
    static constexpr const char* const type_name_ProcessVideoFrameContext = "ProcessVideoFrameContext";

    static PyObject* _new_ProcessVideoFrameContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProcessVideoFrameContext);
        return nullptr;
    }

    static void _dealloc_ProcessVideoFrameContext(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProcessVideoFrameContext_get_InputFrame(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessVideoFrameContext", L"InputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessVideoFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.ProcessVideoFrameContext", L"OutputFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProcessVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::ProcessVideoFrameContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProcessVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::ProcessVideoFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessVideoFrameContext[] = {
        { "_assign_array_", _assign_array_ProcessVideoFrameContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessVideoFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessVideoFrameContext[] = {
        { "input_frame", reinterpret_cast<getter>(ProcessVideoFrameContext_get_InputFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(ProcessVideoFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessVideoFrameContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProcessVideoFrameContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProcessVideoFrameContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProcessVideoFrameContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProcessVideoFrameContext) },
        { },
    };

    static PyType_Spec type_spec_ProcessVideoFrameContext =
    {
        "_winsdk_Windows_Media_Effects.ProcessVideoFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessVideoFrameContext
    };

    // ----- SlowMotionEffectDefinition class --------------------
    static constexpr const char* const type_name_SlowMotionEffectDefinition = "SlowMotionEffectDefinition";

    static PyObject* _new_SlowMotionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Effects::SlowMotionEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SlowMotionEffectDefinition(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlowMotionEffectDefinition_get_TimeStretchRate(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"TimeStretchRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeStretchRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SlowMotionEffectDefinition_put_TimeStretchRate(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"TimeStretchRate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TimeStretchRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SlowMotionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlowMotionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.SlowMotionEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlowMotionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::SlowMotionEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlowMotionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::SlowMotionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlowMotionEffectDefinition[] = {
        { "_assign_array_", _assign_array_SlowMotionEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlowMotionEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlowMotionEffectDefinition[] = {
        { "time_stretch_rate", reinterpret_cast<getter>(SlowMotionEffectDefinition_get_TimeStretchRate), reinterpret_cast<setter>(SlowMotionEffectDefinition_put_TimeStretchRate), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(SlowMotionEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SlowMotionEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SlowMotionEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlowMotionEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlowMotionEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlowMotionEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlowMotionEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_SlowMotionEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.SlowMotionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::SlowMotionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlowMotionEffectDefinition
    };

    // ----- VideoCompositorDefinition class --------------------
    static constexpr const char* const type_name_VideoCompositorDefinition = "VideoCompositorDefinition";

    static PyObject* _new_VideoCompositorDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::VideoCompositorDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::VideoCompositorDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoCompositorDefinition(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoCompositorDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoCompositorDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoCompositorDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoCompositorDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoCompositorDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoCompositorDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoCompositorDefinition[] = {
        { "_assign_array_", _assign_array_VideoCompositorDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoCompositorDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoCompositorDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoCompositorDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoCompositorDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoCompositorDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoCompositorDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoCompositorDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoCompositorDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoCompositorDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoCompositorDefinition =
    {
        "_winsdk_Windows_Media_Effects.VideoCompositorDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoCompositorDefinition
    };

    // ----- VideoEffectDefinition class --------------------
    static constexpr const char* const type_name_VideoEffectDefinition = "VideoEffectDefinition";

    static PyObject* _new_VideoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::VideoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::VideoEffectDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEffectDefinition(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEffectDefinition[] = {
        { "_assign_array_", _assign_array_VideoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.VideoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEffectDefinition
    };

    // ----- VideoTransformEffectDefinition class --------------------
    static constexpr const char* const type_name_VideoTransformEffectDefinition = "VideoTransformEffectDefinition";

    static PyObject* _new_VideoTransformEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Effects::VideoTransformEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoTransformEffectDefinition(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTransformEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Rotation(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_Rotation(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_ProcessingAlgorithm(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"ProcessingAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessingAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_ProcessingAlgorithm(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"ProcessingAlgorithm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Transcoding::MediaVideoProcessingAlgorithm>(arg);

            self->obj.ProcessingAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_PaddingColor(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"PaddingColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PaddingColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_PaddingColor(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"PaddingColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.PaddingColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_OutputSize(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"OutputSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutputSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_OutputSize(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"OutputSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.OutputSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Mirror(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Mirror"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Mirror());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_Mirror(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"Mirror"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaMirroringOptions>(arg);

            self->obj.Mirror(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_CropRectangle(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"CropRectangle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CropRectangle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_CropRectangle(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"CropRectangle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.CropRectangle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_SphericalProjection(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformEffectDefinition", L"SphericalProjection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SphericalProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VideoTransformEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTransformEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTransformEffectDefinition[] = {
        { "_assign_array_", _assign_array_VideoTransformEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTransformEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTransformEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Rotation), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_Rotation), nullptr, nullptr },
        { "processing_algorithm", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_ProcessingAlgorithm), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_ProcessingAlgorithm), nullptr, nullptr },
        { "padding_color", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_PaddingColor), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_PaddingColor), nullptr, nullptr },
        { "output_size", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_OutputSize), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_OutputSize), nullptr, nullptr },
        { "mirror", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Mirror), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_Mirror), nullptr, nullptr },
        { "crop_rectangle", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_CropRectangle), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_CropRectangle), nullptr, nullptr },
        { "spherical_projection", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_SphericalProjection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTransformEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTransformEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTransformEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTransformEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTransformEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_VideoTransformEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.VideoTransformEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTransformEffectDefinition
    };

    // ----- VideoTransformSphericalProjection class --------------------
    static constexpr const char* const type_name_VideoTransformSphericalProjection = "VideoTransformSphericalProjection";

    static PyObject* _new_VideoTransformSphericalProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTransformSphericalProjection);
        return nullptr;
    }

    static void _dealloc_VideoTransformSphericalProjection(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTransformSphericalProjection_get_ViewOrientation(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ViewOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_ViewOrientation(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ViewOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.ViewOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_ProjectionMode(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ProjectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProjectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_ProjectionMode(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"ProjectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::SphericalVideoProjectionMode>(arg);

            self->obj.ProjectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_IsEnabled(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_IsEnabled(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"HorizontalFieldOfViewInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalFieldOfViewInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"HorizontalFieldOfViewInDegrees"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalFieldOfViewInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_FrameFormat(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"FrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_FrameFormat(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.VideoTransformSphericalProjection", L"FrameFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat>(arg);

            self->obj.FrameFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_VideoTransformSphericalProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VideoTransformSphericalProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTransformSphericalProjection[] = {
        { "_assign_array_", _assign_array_VideoTransformSphericalProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTransformSphericalProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTransformSphericalProjection[] = {
        { "view_orientation", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_ViewOrientation), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_ViewOrientation), nullptr, nullptr },
        { "projection_mode", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_ProjectionMode), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_ProjectionMode), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_IsEnabled), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_IsEnabled), nullptr, nullptr },
        { "horizontal_field_of_view_in_degrees", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_HorizontalFieldOfViewInDegrees), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_HorizontalFieldOfViewInDegrees), nullptr, nullptr },
        { "frame_format", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_FrameFormat), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_FrameFormat), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTransformSphericalProjection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VideoTransformSphericalProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VideoTransformSphericalProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VideoTransformSphericalProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VideoTransformSphericalProjection) },
        { },
    };

    static PyType_Spec type_spec_VideoTransformSphericalProjection =
    {
        "_winsdk_Windows_Media_Effects.VideoTransformSphericalProjection",
        sizeof(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTransformSphericalProjection
    };

    // ----- IAudioEffectDefinition interface --------------------
    static constexpr const char* const type_name_IAudioEffectDefinition = "IAudioEffectDefinition";

    static PyObject* _new_IAudioEffectDefinition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAudioEffectDefinition);
        return nullptr;
    }

    static void _dealloc_IAudioEffectDefinition(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IAudioEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IAudioEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IAudioEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IAudioEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioEffectDefinition[] = {
        { "_assign_array_", _assign_array_IAudioEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IAudioEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IAudioEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_IAudioEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.IAudioEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioEffectDefinition
    };

    // ----- IBasicAudioEffect interface --------------------
    static constexpr const char* const type_name_IBasicAudioEffect = "IBasicAudioEffect";

    static PyObject* _new_IBasicAudioEffect(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBasicAudioEffect);
        return nullptr;
    }

    static void _dealloc_IBasicAudioEffect(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBasicAudioEffect_Close(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"Close", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_ProcessFrame(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"ProcessFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::ProcessAudioFrameContext>(args, 0);

                self->obj.ProcessFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"SetEncodingProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                self->obj.SetEncodingProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_SetProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_get_SupportedEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"SupportedEncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedEncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_get_UseInputFrameForOutput(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicAudioEffect", L"UseInputFrameForOutput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UseInputFrameForOutput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBasicAudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IBasicAudioEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBasicAudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IBasicAudioEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBasicAudioEffect[] = {
        { "close", reinterpret_cast<PyCFunction>(IBasicAudioEffect_Close), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IBasicAudioEffect_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "process_frame", reinterpret_cast<PyCFunction>(IBasicAudioEffect_ProcessFrame), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IBasicAudioEffect_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IBasicAudioEffect_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBasicAudioEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBasicAudioEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBasicAudioEffect[] = {
        { "supported_encoding_properties", reinterpret_cast<getter>(IBasicAudioEffect_get_SupportedEncodingProperties), nullptr, nullptr, nullptr },
        { "use_input_frame_for_output", reinterpret_cast<getter>(IBasicAudioEffect_get_UseInputFrameForOutput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBasicAudioEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBasicAudioEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBasicAudioEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBasicAudioEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBasicAudioEffect) },
        { },
    };

    static PyType_Spec type_spec_IBasicAudioEffect =
    {
        "_winsdk_Windows_Media_Effects.IBasicAudioEffect",
        sizeof(py::wrapper::Windows::Media::Effects::IBasicAudioEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBasicAudioEffect
    };

    // ----- IBasicVideoEffect interface --------------------
    static constexpr const char* const type_name_IBasicVideoEffect = "IBasicVideoEffect";

    static PyObject* _new_IBasicVideoEffect(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IBasicVideoEffect);
        return nullptr;
    }

    static void _dealloc_IBasicVideoEffect(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBasicVideoEffect_Close(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"Close", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_ProcessFrame(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"ProcessFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::ProcessVideoFrameContext>(args, 0);

                self->obj.ProcessFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"SetEncodingProperties", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 1);

                self->obj.SetEncodingProperties(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_SetProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_IsReadOnly(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_SupportedEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"SupportedEncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedEncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_SupportedMemoryTypes(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"SupportedMemoryTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedMemoryTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_TimeIndependent(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IBasicVideoEffect", L"TimeIndependent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBasicVideoEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IBasicVideoEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBasicVideoEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IBasicVideoEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBasicVideoEffect[] = {
        { "close", reinterpret_cast<PyCFunction>(IBasicVideoEffect_Close), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IBasicVideoEffect_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "process_frame", reinterpret_cast<PyCFunction>(IBasicVideoEffect_ProcessFrame), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IBasicVideoEffect_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IBasicVideoEffect_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBasicVideoEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBasicVideoEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBasicVideoEffect[] = {
        { "is_read_only", reinterpret_cast<getter>(IBasicVideoEffect_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "supported_encoding_properties", reinterpret_cast<getter>(IBasicVideoEffect_get_SupportedEncodingProperties), nullptr, nullptr, nullptr },
        { "supported_memory_types", reinterpret_cast<getter>(IBasicVideoEffect_get_SupportedMemoryTypes), nullptr, nullptr, nullptr },
        { "time_independent", reinterpret_cast<getter>(IBasicVideoEffect_get_TimeIndependent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBasicVideoEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBasicVideoEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBasicVideoEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBasicVideoEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBasicVideoEffect) },
        { },
    };

    static PyType_Spec type_spec_IBasicVideoEffect =
    {
        "_winsdk_Windows_Media_Effects.IBasicVideoEffect",
        sizeof(py::wrapper::Windows::Media::Effects::IBasicVideoEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBasicVideoEffect
    };

    // ----- IVideoCompositor interface --------------------
    static constexpr const char* const type_name_IVideoCompositor = "IVideoCompositor";

    static PyObject* _new_IVideoCompositor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IVideoCompositor);
        return nullptr;
    }

    static void _dealloc_IVideoCompositor(py::wrapper::Windows::Media::Effects::IVideoCompositor* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVideoCompositor_Close(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"Close", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_CompositeFrame(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"CompositeFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::CompositeVideoFrameContext>(args, 0);

                self->obj.CompositeFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Effects.IVideoCompositor", L"SetEncodingProperties", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 1);

                self->obj.SetEncodingProperties(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_SetProperties(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.IMediaExtension", L"SetProperties", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_get_TimeIndependent(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoCompositor", L"TimeIndependent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVideoCompositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IVideoCompositor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVideoCompositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoCompositor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoCompositor[] = {
        { "close", reinterpret_cast<PyCFunction>(IVideoCompositor_Close), METH_VARARGS, nullptr },
        { "composite_frame", reinterpret_cast<PyCFunction>(IVideoCompositor_CompositeFrame), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IVideoCompositor_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IVideoCompositor_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IVideoCompositor_SetProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVideoCompositor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoCompositor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoCompositor[] = {
        { "time_independent", reinterpret_cast<getter>(IVideoCompositor_get_TimeIndependent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoCompositor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVideoCompositor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVideoCompositor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVideoCompositor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVideoCompositor) },
        { },
    };

    static PyType_Spec type_spec_IVideoCompositor =
    {
        "_winsdk_Windows_Media_Effects.IVideoCompositor",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoCompositor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoCompositor
    };

    // ----- IVideoCompositorDefinition interface --------------------
    static constexpr const char* const type_name_IVideoCompositorDefinition = "IVideoCompositorDefinition";

    static PyObject* _new_IVideoCompositorDefinition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IVideoCompositorDefinition);
        return nullptr;
    }

    static void _dealloc_IVideoCompositorDefinition(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVideoCompositorDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoCompositorDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVideoCompositorDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoCompositorDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IVideoCompositorDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoCompositorDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoCompositorDefinition[] = {
        { "_assign_array_", _assign_array_IVideoCompositorDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoCompositorDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoCompositorDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IVideoCompositorDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IVideoCompositorDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoCompositorDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVideoCompositorDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVideoCompositorDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVideoCompositorDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVideoCompositorDefinition) },
        { },
    };

    static PyType_Spec type_spec_IVideoCompositorDefinition =
    {
        "_winsdk_Windows_Media_Effects.IVideoCompositorDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoCompositorDefinition
    };

    // ----- IVideoEffectDefinition interface --------------------
    static constexpr const char* const type_name_IVideoEffectDefinition = "IVideoEffectDefinition";

    static PyObject* _new_IVideoEffectDefinition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IVideoEffectDefinition);
        return nullptr;
    }

    static void _dealloc_IVideoEffectDefinition(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVideoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVideoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Effects.IVideoEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Effects::IVideoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoEffectDefinition[] = {
        { "_assign_array_", _assign_array_IVideoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IVideoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IVideoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVideoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVideoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVideoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVideoEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_IVideoEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.IVideoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoEffectDefinition
    };

    // ----- Windows.Media.Effects Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Effects");

    static PyMethodDef module_methods[] = {
        {"_register_AudioEffectType", register_AudioEffectType, METH_O, "registers type"},
        {"_register_MediaEffectClosedReason", register_MediaEffectClosedReason, METH_O, "registers type"},
        {"_register_MediaMemoryTypes", register_MediaMemoryTypes, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AudioEffectType);
        Py_VISIT(state->type_MediaEffectClosedReason);
        Py_VISIT(state->type_MediaMemoryTypes);
        Py_VISIT(state->type_AudioCaptureEffectsManager);
        Py_VISIT(state->type_AudioEffect);
        Py_VISIT(state->type_AudioEffectDefinition);
        Py_VISIT(state->type_AudioEffectsManager);
        Py_VISIT(state->type_AudioRenderEffectsManager);
        Py_VISIT(state->type_CompositeVideoFrameContext);
        Py_VISIT(state->type_ProcessAudioFrameContext);
        Py_VISIT(state->type_ProcessVideoFrameContext);
        Py_VISIT(state->type_SlowMotionEffectDefinition);
        Py_VISIT(state->type_VideoCompositorDefinition);
        Py_VISIT(state->type_VideoEffectDefinition);
        Py_VISIT(state->type_VideoTransformEffectDefinition);
        Py_VISIT(state->type_VideoTransformSphericalProjection);
        Py_VISIT(state->type_IAudioEffectDefinition);
        Py_VISIT(state->type_IBasicAudioEffect);
        Py_VISIT(state->type_IBasicVideoEffect);
        Py_VISIT(state->type_IVideoCompositor);
        Py_VISIT(state->type_IVideoCompositorDefinition);
        Py_VISIT(state->type_IVideoEffectDefinition);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AudioEffectType);
        Py_CLEAR(state->type_MediaEffectClosedReason);
        Py_CLEAR(state->type_MediaMemoryTypes);
        Py_CLEAR(state->type_AudioCaptureEffectsManager);
        Py_CLEAR(state->type_AudioEffect);
        Py_CLEAR(state->type_AudioEffectDefinition);
        Py_CLEAR(state->type_AudioEffectsManager);
        Py_CLEAR(state->type_AudioRenderEffectsManager);
        Py_CLEAR(state->type_CompositeVideoFrameContext);
        Py_CLEAR(state->type_ProcessAudioFrameContext);
        Py_CLEAR(state->type_ProcessVideoFrameContext);
        Py_CLEAR(state->type_SlowMotionEffectDefinition);
        Py_CLEAR(state->type_VideoCompositorDefinition);
        Py_CLEAR(state->type_VideoEffectDefinition);
        Py_CLEAR(state->type_VideoTransformEffectDefinition);
        Py_CLEAR(state->type_VideoTransformSphericalProjection);
        Py_CLEAR(state->type_IAudioEffectDefinition);
        Py_CLEAR(state->type_IBasicAudioEffect);
        Py_CLEAR(state->type_IBasicVideoEffect);
        Py_CLEAR(state->type_IVideoCompositor);
        Py_CLEAR(state->type_IVideoCompositorDefinition);
        Py_CLEAR(state->type_IVideoEffectDefinition);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Effects",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::Effects

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_Effects(void) noexcept
{
    using namespace py::cpp::Windows::Media::Effects;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AudioCaptureEffectsManager = py::register_python_type(module.get(), type_name_AudioCaptureEffectsManager, &type_spec_AudioCaptureEffectsManager, bases.get(), nullptr);
    if (!state->type_AudioCaptureEffectsManager)
    {
        return nullptr;
    }

    state->type_AudioEffect = py::register_python_type(module.get(), type_name_AudioEffect, &type_spec_AudioEffect, bases.get(), nullptr);
    if (!state->type_AudioEffect)
    {
        return nullptr;
    }

    state->type_AudioEffectDefinition = py::register_python_type(module.get(), type_name_AudioEffectDefinition, &type_spec_AudioEffectDefinition, bases.get(), nullptr);
    if (!state->type_AudioEffectDefinition)
    {
        return nullptr;
    }

    state->type_AudioEffectsManager = py::register_python_type(module.get(), type_name_AudioEffectsManager, &type_spec_AudioEffectsManager, nullptr, nullptr);
    if (!state->type_AudioEffectsManager)
    {
        return nullptr;
    }

    state->type_AudioRenderEffectsManager = py::register_python_type(module.get(), type_name_AudioRenderEffectsManager, &type_spec_AudioRenderEffectsManager, bases.get(), nullptr);
    if (!state->type_AudioRenderEffectsManager)
    {
        return nullptr;
    }

    state->type_CompositeVideoFrameContext = py::register_python_type(module.get(), type_name_CompositeVideoFrameContext, &type_spec_CompositeVideoFrameContext, bases.get(), nullptr);
    if (!state->type_CompositeVideoFrameContext)
    {
        return nullptr;
    }

    state->type_ProcessAudioFrameContext = py::register_python_type(module.get(), type_name_ProcessAudioFrameContext, &type_spec_ProcessAudioFrameContext, bases.get(), nullptr);
    if (!state->type_ProcessAudioFrameContext)
    {
        return nullptr;
    }

    state->type_ProcessVideoFrameContext = py::register_python_type(module.get(), type_name_ProcessVideoFrameContext, &type_spec_ProcessVideoFrameContext, bases.get(), nullptr);
    if (!state->type_ProcessVideoFrameContext)
    {
        return nullptr;
    }

    state->type_SlowMotionEffectDefinition = py::register_python_type(module.get(), type_name_SlowMotionEffectDefinition, &type_spec_SlowMotionEffectDefinition, bases.get(), nullptr);
    if (!state->type_SlowMotionEffectDefinition)
    {
        return nullptr;
    }

    state->type_VideoCompositorDefinition = py::register_python_type(module.get(), type_name_VideoCompositorDefinition, &type_spec_VideoCompositorDefinition, bases.get(), nullptr);
    if (!state->type_VideoCompositorDefinition)
    {
        return nullptr;
    }

    state->type_VideoEffectDefinition = py::register_python_type(module.get(), type_name_VideoEffectDefinition, &type_spec_VideoEffectDefinition, bases.get(), nullptr);
    if (!state->type_VideoEffectDefinition)
    {
        return nullptr;
    }

    state->type_VideoTransformEffectDefinition = py::register_python_type(module.get(), type_name_VideoTransformEffectDefinition, &type_spec_VideoTransformEffectDefinition, bases.get(), nullptr);
    if (!state->type_VideoTransformEffectDefinition)
    {
        return nullptr;
    }

    state->type_VideoTransformSphericalProjection = py::register_python_type(module.get(), type_name_VideoTransformSphericalProjection, &type_spec_VideoTransformSphericalProjection, bases.get(), nullptr);
    if (!state->type_VideoTransformSphericalProjection)
    {
        return nullptr;
    }

    state->type_IAudioEffectDefinition = py::register_python_type(module.get(), type_name_IAudioEffectDefinition, &type_spec_IAudioEffectDefinition, bases.get(), nullptr);
    if (!state->type_IAudioEffectDefinition)
    {
        return nullptr;
    }

    state->type_IBasicAudioEffect = py::register_python_type(module.get(), type_name_IBasicAudioEffect, &type_spec_IBasicAudioEffect, bases.get(), nullptr);
    if (!state->type_IBasicAudioEffect)
    {
        return nullptr;
    }

    state->type_IBasicVideoEffect = py::register_python_type(module.get(), type_name_IBasicVideoEffect, &type_spec_IBasicVideoEffect, bases.get(), nullptr);
    if (!state->type_IBasicVideoEffect)
    {
        return nullptr;
    }

    state->type_IVideoCompositor = py::register_python_type(module.get(), type_name_IVideoCompositor, &type_spec_IVideoCompositor, bases.get(), nullptr);
    if (!state->type_IVideoCompositor)
    {
        return nullptr;
    }

    state->type_IVideoCompositorDefinition = py::register_python_type(module.get(), type_name_IVideoCompositorDefinition, &type_spec_IVideoCompositorDefinition, bases.get(), nullptr);
    if (!state->type_IVideoCompositorDefinition)
    {
        return nullptr;
    }

    state->type_IVideoEffectDefinition = py::register_python_type(module.get(), type_name_IVideoEffectDefinition, &type_spec_IVideoEffectDefinition, bases.get(), nullptr);
    if (!state->type_IVideoEffectDefinition)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::Effects::AudioEffectType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioEffectType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::AudioEffectType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Effects::MediaEffectClosedReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaEffectClosedReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::MediaEffectClosedReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Effects::MediaMemoryTypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaMemoryTypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::MediaMemoryTypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioCaptureEffectsManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::AudioCaptureEffectsManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioEffect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioEffect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::AudioEffect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::AudioEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioEffectsManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioEffectsManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::AudioEffectsManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioRenderEffectsManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioRenderEffectsManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::AudioRenderEffectsManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::CompositeVideoFrameContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CompositeVideoFrameContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::CompositeVideoFrameContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::ProcessAudioFrameContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessAudioFrameContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::ProcessAudioFrameContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::ProcessVideoFrameContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProcessVideoFrameContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::ProcessVideoFrameContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::SlowMotionEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SlowMotionEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::SlowMotionEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoCompositorDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoCompositorDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::VideoCompositorDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::VideoEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoTransformEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::VideoTransformEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoTransformSphericalProjection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::VideoTransformSphericalProjection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IAudioEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAudioEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::IAudioEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IBasicAudioEffect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBasicAudioEffect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::IBasicAudioEffect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IBasicVideoEffect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBasicVideoEffect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::IBasicVideoEffect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IVideoCompositor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IVideoCompositor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::IVideoCompositor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IVideoCompositorDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IVideoCompositorDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::IVideoCompositorDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IVideoEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Effects;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Effects");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IVideoEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Effects::IVideoEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}
