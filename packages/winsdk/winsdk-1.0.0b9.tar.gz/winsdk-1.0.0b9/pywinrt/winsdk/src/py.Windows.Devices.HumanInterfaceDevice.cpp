// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.Devices.HumanInterfaceDevice.h"


namespace py::cpp::Windows::Devices::HumanInterfaceDevice
{
    struct module_state
    {
        PyObject* type_HidCollectionType;
        PyObject* type_HidReportType;
        PyTypeObject* type_HidBooleanControl;
        PyTypeObject* type_HidBooleanControlDescription;
        PyTypeObject* type_HidCollection;
        PyTypeObject* type_HidDevice;
        PyTypeObject* type_HidFeatureReport;
        PyTypeObject* type_HidInputReport;
        PyTypeObject* type_HidInputReportReceivedEventArgs;
        PyTypeObject* type_HidNumericControl;
        PyTypeObject* type_HidNumericControlDescription;
        PyTypeObject* type_HidOutputReport;
    };

    static PyObject* register_HidCollectionType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HidCollectionType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HidCollectionType = type;
        Py_INCREF(state->type_HidCollectionType);


        Py_RETURN_NONE;
    }

    static PyObject* register_HidReportType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HidReportType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HidReportType = type;
        Py_INCREF(state->type_HidReportType);


        Py_RETURN_NONE;
    }

    // ----- HidBooleanControl class --------------------
    static constexpr const char* const type_name_HidBooleanControl = "HidBooleanControl";

    static PyObject* _new_HidBooleanControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidBooleanControl);
        return nullptr;
    }

    static void _dealloc_HidBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidBooleanControl_get_IsActive(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidBooleanControl_put_IsActive(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsActive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidBooleanControl_get_ControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"ControlDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControl_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControl_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControl_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControl", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidBooleanControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidBooleanControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidBooleanControl[] = {
        { "_assign_array_", _assign_array_HidBooleanControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidBooleanControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidBooleanControl[] = {
        { "is_active", reinterpret_cast<getter>(HidBooleanControl_get_IsActive), reinterpret_cast<setter>(HidBooleanControl_put_IsActive), nullptr, nullptr },
        { "control_description", reinterpret_cast<getter>(HidBooleanControl_get_ControlDescription), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidBooleanControl_get_Id), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidBooleanControl_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidBooleanControl_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidBooleanControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidBooleanControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidBooleanControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidBooleanControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidBooleanControl) },
        { },
    };

    static PyType_Spec type_spec_HidBooleanControl =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidBooleanControl",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidBooleanControl
    };

    // ----- HidBooleanControlDescription class --------------------
    static constexpr const char* const type_name_HidBooleanControlDescription = "HidBooleanControlDescription";

    static PyObject* _new_HidBooleanControlDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidBooleanControlDescription);
        return nullptr;
    }

    static void _dealloc_HidBooleanControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidBooleanControlDescription_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_ParentCollections(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"ParentCollections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentCollections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_ReportId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"ReportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_ReportType(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"ReportType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidBooleanControlDescription_get_IsAbsolute(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription", L"IsAbsolute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAbsolute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidBooleanControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidBooleanControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidBooleanControlDescription[] = {
        { "_assign_array_", _assign_array_HidBooleanControlDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidBooleanControlDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidBooleanControlDescription[] = {
        { "id", reinterpret_cast<getter>(HidBooleanControlDescription_get_Id), nullptr, nullptr, nullptr },
        { "parent_collections", reinterpret_cast<getter>(HidBooleanControlDescription_get_ParentCollections), nullptr, nullptr, nullptr },
        { "report_id", reinterpret_cast<getter>(HidBooleanControlDescription_get_ReportId), nullptr, nullptr, nullptr },
        { "report_type", reinterpret_cast<getter>(HidBooleanControlDescription_get_ReportType), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidBooleanControlDescription_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidBooleanControlDescription_get_UsagePage), nullptr, nullptr, nullptr },
        { "is_absolute", reinterpret_cast<getter>(HidBooleanControlDescription_get_IsAbsolute), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidBooleanControlDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidBooleanControlDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidBooleanControlDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidBooleanControlDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidBooleanControlDescription) },
        { },
    };

    static PyType_Spec type_spec_HidBooleanControlDescription =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidBooleanControlDescription",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidBooleanControlDescription
    };

    // ----- HidCollection class --------------------
    static constexpr const char* const type_name_HidCollection = "HidCollection";

    static PyObject* _new_HidCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidCollection);
        return nullptr;
    }

    static void _dealloc_HidCollection(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidCollection_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidCollection_get_Type(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidCollection_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidCollection_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidCollection", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidCollection[] = {
        { "_assign_array_", _assign_array_HidCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidCollection[] = {
        { "id", reinterpret_cast<getter>(HidCollection_get_Id), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(HidCollection_get_Type), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidCollection_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidCollection_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidCollection) },
        { },
    };

    static PyType_Spec type_spec_HidCollection =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidCollection",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidCollection
    };

    // ----- HidDevice class --------------------
    static constexpr const char* const type_name_HidDevice = "HidDevice";

    static PyObject* _new_HidDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidDevice);
        return nullptr;
    }

    static void _dealloc_HidDevice(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidDevice_Close(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_CreateFeatureReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateFeatureReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateFeatureReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateFeatureReport", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(self->obj.CreateFeatureReport(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_CreateOutputReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateOutputReport", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateOutputReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"CreateOutputReport", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(self->obj.CreateOutputReport(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"FromIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);

                return py::convert(winrt::Windows::Devices::HumanInterfaceDevice::HidDevice::FromIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetBooleanControlDescriptions(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetBooleanControlDescriptions", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidReportType>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                return py::convert(self->obj.GetBooleanControlDescriptions(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetDeviceSelector", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(winrt::Windows::Devices::HumanInterfaceDevice::HidDevice::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetDeviceSelector", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);
                auto param3 = py::convert_to<uint16_t>(args, 3);

                return py::convert(winrt::Windows::Devices::HumanInterfaceDevice::HidDevice::GetDeviceSelector(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetFeatureReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetFeatureReportAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFeatureReportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetFeatureReportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(self->obj.GetFeatureReportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetInputReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetInputReportAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetInputReportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetInputReportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(self->obj.GetInputReportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_GetNumericControlDescriptions(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"GetNumericControlDescriptions", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidReportType>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                return py::convert(self->obj.GetNumericControlDescriptions(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_SendFeatureReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"SendFeatureReportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>(args, 0);

                return py::convert(self->obj.SendFeatureReportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_SendOutputReportAsync(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"SendOutputReportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>(args, 0);

                return py::convert(self->obj.SendOutputReportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_ProductId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"ProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_VendorId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"VendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_get_Version(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"Version"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_add_InputReportReceived(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"InputReportReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice, winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>>(arg);

            return py::convert(self->obj.InputReportReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidDevice_remove_InputReportReceived(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.HumanInterfaceDevice.HidDevice", L"InputReportReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputReportReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_HidDevice(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_HidDevice(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(HidDevice_Close), METH_VARARGS, nullptr },
        { "create_feature_report", reinterpret_cast<PyCFunction>(HidDevice_CreateFeatureReport), METH_VARARGS, nullptr },
        { "create_output_report", reinterpret_cast<PyCFunction>(HidDevice_CreateOutputReport), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(HidDevice_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_boolean_control_descriptions", reinterpret_cast<PyCFunction>(HidDevice_GetBooleanControlDescriptions), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(HidDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_feature_report_async", reinterpret_cast<PyCFunction>(HidDevice_GetFeatureReportAsync), METH_VARARGS, nullptr },
        { "get_input_report_async", reinterpret_cast<PyCFunction>(HidDevice_GetInputReportAsync), METH_VARARGS, nullptr },
        { "get_numeric_control_descriptions", reinterpret_cast<PyCFunction>(HidDevice_GetNumericControlDescriptions), METH_VARARGS, nullptr },
        { "send_feature_report_async", reinterpret_cast<PyCFunction>(HidDevice_SendFeatureReportAsync), METH_VARARGS, nullptr },
        { "send_output_report_async", reinterpret_cast<PyCFunction>(HidDevice_SendOutputReportAsync), METH_VARARGS, nullptr },
        { "add_input_report_received", reinterpret_cast<PyCFunction>(HidDevice_add_InputReportReceived), METH_O, nullptr },
        { "remove_input_report_received", reinterpret_cast<PyCFunction>(HidDevice_remove_InputReportReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_HidDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_HidDevice), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_HidDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidDevice[] = {
        { "product_id", reinterpret_cast<getter>(HidDevice_get_ProductId), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidDevice_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidDevice_get_UsagePage), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(HidDevice_get_VendorId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(HidDevice_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidDevice) },
        { },
    };

    static PyType_Spec type_spec_HidDevice =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidDevice",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidDevice
    };

    // ----- HidFeatureReport class --------------------
    static constexpr const char* const type_name_HidFeatureReport = "HidFeatureReport";

    static PyObject* _new_HidFeatureReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidFeatureReport);
        return nullptr;
    }

    static void _dealloc_HidFeatureReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidFeatureReport_GetBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetBooleanControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(self->obj.GetBooleanControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_GetBooleanControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetBooleanControlByDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>(args, 0);

                return py::convert(self->obj.GetBooleanControlByDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_GetNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetNumericControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(self->obj.GetNumericControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_GetNumericControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"GetNumericControlByDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>(args, 0);

                return py::convert(self->obj.GetNumericControlByDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidFeatureReport_get_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidFeatureReport_put_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidFeatureReport_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidFeatureReport", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidFeatureReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidFeatureReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidFeatureReport[] = {
        { "get_boolean_control", reinterpret_cast<PyCFunction>(HidFeatureReport_GetBooleanControl), METH_VARARGS, nullptr },
        { "get_boolean_control_by_description", reinterpret_cast<PyCFunction>(HidFeatureReport_GetBooleanControlByDescription), METH_VARARGS, nullptr },
        { "get_numeric_control", reinterpret_cast<PyCFunction>(HidFeatureReport_GetNumericControl), METH_VARARGS, nullptr },
        { "get_numeric_control_by_description", reinterpret_cast<PyCFunction>(HidFeatureReport_GetNumericControlByDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidFeatureReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidFeatureReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidFeatureReport[] = {
        { "data", reinterpret_cast<getter>(HidFeatureReport_get_Data), reinterpret_cast<setter>(HidFeatureReport_put_Data), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidFeatureReport_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidFeatureReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidFeatureReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidFeatureReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidFeatureReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidFeatureReport) },
        { },
    };

    static PyType_Spec type_spec_HidFeatureReport =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidFeatureReport",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidFeatureReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidFeatureReport
    };

    // ----- HidInputReport class --------------------
    static constexpr const char* const type_name_HidInputReport = "HidInputReport";

    static PyObject* _new_HidInputReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidInputReport);
        return nullptr;
    }

    static void _dealloc_HidInputReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidInputReport_GetBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetBooleanControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(self->obj.GetBooleanControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_GetBooleanControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetBooleanControlByDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>(args, 0);

                return py::convert(self->obj.GetBooleanControlByDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_GetNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetNumericControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(self->obj.GetNumericControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_GetNumericControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"GetNumericControlByDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>(args, 0);

                return py::convert(self->obj.GetNumericControlByDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_ActivatedBooleanControls(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"ActivatedBooleanControls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatedBooleanControls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidInputReport_get_TransitionedBooleanControls(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReport", L"TransitionedBooleanControls"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitionedBooleanControls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidInputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidInputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidInputReport[] = {
        { "get_boolean_control", reinterpret_cast<PyCFunction>(HidInputReport_GetBooleanControl), METH_VARARGS, nullptr },
        { "get_boolean_control_by_description", reinterpret_cast<PyCFunction>(HidInputReport_GetBooleanControlByDescription), METH_VARARGS, nullptr },
        { "get_numeric_control", reinterpret_cast<PyCFunction>(HidInputReport_GetNumericControl), METH_VARARGS, nullptr },
        { "get_numeric_control_by_description", reinterpret_cast<PyCFunction>(HidInputReport_GetNumericControlByDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidInputReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidInputReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidInputReport[] = {
        { "activated_boolean_controls", reinterpret_cast<getter>(HidInputReport_get_ActivatedBooleanControls), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(HidInputReport_get_Data), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidInputReport_get_Id), nullptr, nullptr, nullptr },
        { "transitioned_boolean_controls", reinterpret_cast<getter>(HidInputReport_get_TransitionedBooleanControls), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidInputReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidInputReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidInputReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidInputReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidInputReport) },
        { },
    };

    static PyType_Spec type_spec_HidInputReport =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidInputReport",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidInputReport
    };

    // ----- HidInputReportReceivedEventArgs class --------------------
    static constexpr const char* const type_name_HidInputReportReceivedEventArgs = "HidInputReportReceivedEventArgs";

    static PyObject* _new_HidInputReportReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidInputReportReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_HidInputReportReceivedEventArgs(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidInputReportReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs", L"Report"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidInputReportReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidInputReportReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidInputReportReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_HidInputReportReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidInputReportReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidInputReportReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(HidInputReportReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidInputReportReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidInputReportReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidInputReportReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidInputReportReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidInputReportReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HidInputReportReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidInputReportReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidInputReportReceivedEventArgs
    };

    // ----- HidNumericControl class --------------------
    static constexpr const char* const type_name_HidNumericControl = "HidNumericControl";

    static PyObject* _new_HidNumericControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidNumericControl);
        return nullptr;
    }

    static void _dealloc_HidNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidNumericControl_get_Value(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidNumericControl_put_Value(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int64_t>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidNumericControl_get_ScaledValue(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"ScaledValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaledValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidNumericControl_put_ScaledValue(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"ScaledValue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int64_t>(arg);

            self->obj.ScaledValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidNumericControl_get_ControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"ControlDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_IsGrouped(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"IsGrouped"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGrouped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControl_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControl", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidNumericControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidNumericControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidNumericControl[] = {
        { "_assign_array_", _assign_array_HidNumericControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidNumericControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidNumericControl[] = {
        { "value", reinterpret_cast<getter>(HidNumericControl_get_Value), reinterpret_cast<setter>(HidNumericControl_put_Value), nullptr, nullptr },
        { "scaled_value", reinterpret_cast<getter>(HidNumericControl_get_ScaledValue), reinterpret_cast<setter>(HidNumericControl_put_ScaledValue), nullptr, nullptr },
        { "control_description", reinterpret_cast<getter>(HidNumericControl_get_ControlDescription), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidNumericControl_get_Id), nullptr, nullptr, nullptr },
        { "is_grouped", reinterpret_cast<getter>(HidNumericControl_get_IsGrouped), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidNumericControl_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidNumericControl_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidNumericControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidNumericControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidNumericControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidNumericControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidNumericControl) },
        { },
    };

    static PyType_Spec type_spec_HidNumericControl =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidNumericControl",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidNumericControl
    };

    // ----- HidNumericControlDescription class --------------------
    static constexpr const char* const type_name_HidNumericControlDescription = "HidNumericControlDescription";

    static PyObject* _new_HidNumericControlDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidNumericControlDescription);
        return nullptr;
    }

    static void _dealloc_HidNumericControlDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidNumericControlDescription_get_HasNull(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"HasNull"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasNull());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_IsAbsolute(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"IsAbsolute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAbsolute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_LogicalMaximum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"LogicalMaximum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogicalMaximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_LogicalMinimum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"LogicalMinimum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogicalMinimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ParentCollections(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ParentCollections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentCollections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_PhysicalMaximum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"PhysicalMaximum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalMaximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_PhysicalMinimum(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"PhysicalMinimum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalMinimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportCount(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportSize(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_ReportType(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"ReportType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReportType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_Unit(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"Unit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_UnitExponent(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"UnitExponent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnitExponent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_UsageId(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidNumericControlDescription_get_UsagePage(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidNumericControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidNumericControlDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidNumericControlDescription[] = {
        { "_assign_array_", _assign_array_HidNumericControlDescription, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidNumericControlDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidNumericControlDescription[] = {
        { "has_null", reinterpret_cast<getter>(HidNumericControlDescription_get_HasNull), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidNumericControlDescription_get_Id), nullptr, nullptr, nullptr },
        { "is_absolute", reinterpret_cast<getter>(HidNumericControlDescription_get_IsAbsolute), nullptr, nullptr, nullptr },
        { "logical_maximum", reinterpret_cast<getter>(HidNumericControlDescription_get_LogicalMaximum), nullptr, nullptr, nullptr },
        { "logical_minimum", reinterpret_cast<getter>(HidNumericControlDescription_get_LogicalMinimum), nullptr, nullptr, nullptr },
        { "parent_collections", reinterpret_cast<getter>(HidNumericControlDescription_get_ParentCollections), nullptr, nullptr, nullptr },
        { "physical_maximum", reinterpret_cast<getter>(HidNumericControlDescription_get_PhysicalMaximum), nullptr, nullptr, nullptr },
        { "physical_minimum", reinterpret_cast<getter>(HidNumericControlDescription_get_PhysicalMinimum), nullptr, nullptr, nullptr },
        { "report_count", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportCount), nullptr, nullptr, nullptr },
        { "report_id", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportId), nullptr, nullptr, nullptr },
        { "report_size", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportSize), nullptr, nullptr, nullptr },
        { "report_type", reinterpret_cast<getter>(HidNumericControlDescription_get_ReportType), nullptr, nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(HidNumericControlDescription_get_Unit), nullptr, nullptr, nullptr },
        { "unit_exponent", reinterpret_cast<getter>(HidNumericControlDescription_get_UnitExponent), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidNumericControlDescription_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidNumericControlDescription_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidNumericControlDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidNumericControlDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidNumericControlDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidNumericControlDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidNumericControlDescription) },
        { },
    };

    static PyType_Spec type_spec_HidNumericControlDescription =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidNumericControlDescription",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidNumericControlDescription
    };

    // ----- HidOutputReport class --------------------
    static constexpr const char* const type_name_HidOutputReport = "HidOutputReport";

    static PyObject* _new_HidOutputReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HidOutputReport);
        return nullptr;
    }

    static void _dealloc_HidOutputReport(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidOutputReport_GetBooleanControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetBooleanControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(self->obj.GetBooleanControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_GetBooleanControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetBooleanControlByDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>(args, 0);

                return py::convert(self->obj.GetBooleanControlByDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_GetNumericControl(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetNumericControl", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(self->obj.GetNumericControl(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_GetNumericControlByDescription(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"GetNumericControlByDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>(args, 0);

                return py::convert(self->obj.GetNumericControlByDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidOutputReport_get_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HidOutputReport_put_Data(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HidOutputReport_get_Id(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.HumanInterfaceDevice.HidOutputReport", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidOutputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidOutputReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidOutputReport[] = {
        { "get_boolean_control", reinterpret_cast<PyCFunction>(HidOutputReport_GetBooleanControl), METH_VARARGS, nullptr },
        { "get_boolean_control_by_description", reinterpret_cast<PyCFunction>(HidOutputReport_GetBooleanControlByDescription), METH_VARARGS, nullptr },
        { "get_numeric_control", reinterpret_cast<PyCFunction>(HidOutputReport_GetNumericControl), METH_VARARGS, nullptr },
        { "get_numeric_control_by_description", reinterpret_cast<PyCFunction>(HidOutputReport_GetNumericControlByDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidOutputReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidOutputReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidOutputReport[] = {
        { "data", reinterpret_cast<getter>(HidOutputReport_get_Data), reinterpret_cast<setter>(HidOutputReport_put_Data), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HidOutputReport_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidOutputReport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidOutputReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidOutputReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidOutputReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidOutputReport) },
        { },
    };

    static PyType_Spec type_spec_HidOutputReport =
    {
        "_winsdk_Windows_Devices_HumanInterfaceDevice.HidOutputReport",
        sizeof(py::wrapper::Windows::Devices::HumanInterfaceDevice::HidOutputReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidOutputReport
    };

    // ----- Windows.Devices.HumanInterfaceDevice Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::HumanInterfaceDevice");

    static PyMethodDef module_methods[] = {
        {"_register_HidCollectionType", register_HidCollectionType, METH_O, "registers type"},
        {"_register_HidReportType", register_HidReportType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_HidCollectionType);
        Py_VISIT(state->type_HidReportType);
        Py_VISIT(state->type_HidBooleanControl);
        Py_VISIT(state->type_HidBooleanControlDescription);
        Py_VISIT(state->type_HidCollection);
        Py_VISIT(state->type_HidDevice);
        Py_VISIT(state->type_HidFeatureReport);
        Py_VISIT(state->type_HidInputReport);
        Py_VISIT(state->type_HidInputReportReceivedEventArgs);
        Py_VISIT(state->type_HidNumericControl);
        Py_VISIT(state->type_HidNumericControlDescription);
        Py_VISIT(state->type_HidOutputReport);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_HidCollectionType);
        Py_CLEAR(state->type_HidReportType);
        Py_CLEAR(state->type_HidBooleanControl);
        Py_CLEAR(state->type_HidBooleanControlDescription);
        Py_CLEAR(state->type_HidCollection);
        Py_CLEAR(state->type_HidDevice);
        Py_CLEAR(state->type_HidFeatureReport);
        Py_CLEAR(state->type_HidInputReport);
        Py_CLEAR(state->type_HidInputReportReceivedEventArgs);
        Py_CLEAR(state->type_HidNumericControl);
        Py_CLEAR(state->type_HidNumericControlDescription);
        Py_CLEAR(state->type_HidOutputReport);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_HumanInterfaceDevice",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::HumanInterfaceDevice

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_HumanInterfaceDevice(void) noexcept
{
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_HidBooleanControl = py::register_python_type(module.get(), type_name_HidBooleanControl, &type_spec_HidBooleanControl, bases.get(), nullptr);
    if (!state->type_HidBooleanControl)
    {
        return nullptr;
    }

    state->type_HidBooleanControlDescription = py::register_python_type(module.get(), type_name_HidBooleanControlDescription, &type_spec_HidBooleanControlDescription, bases.get(), nullptr);
    if (!state->type_HidBooleanControlDescription)
    {
        return nullptr;
    }

    state->type_HidCollection = py::register_python_type(module.get(), type_name_HidCollection, &type_spec_HidCollection, bases.get(), nullptr);
    if (!state->type_HidCollection)
    {
        return nullptr;
    }

    state->type_HidDevice = py::register_python_type(module.get(), type_name_HidDevice, &type_spec_HidDevice, bases.get(), nullptr);
    if (!state->type_HidDevice)
    {
        return nullptr;
    }

    state->type_HidFeatureReport = py::register_python_type(module.get(), type_name_HidFeatureReport, &type_spec_HidFeatureReport, bases.get(), nullptr);
    if (!state->type_HidFeatureReport)
    {
        return nullptr;
    }

    state->type_HidInputReport = py::register_python_type(module.get(), type_name_HidInputReport, &type_spec_HidInputReport, bases.get(), nullptr);
    if (!state->type_HidInputReport)
    {
        return nullptr;
    }

    state->type_HidInputReportReceivedEventArgs = py::register_python_type(module.get(), type_name_HidInputReportReceivedEventArgs, &type_spec_HidInputReportReceivedEventArgs, bases.get(), nullptr);
    if (!state->type_HidInputReportReceivedEventArgs)
    {
        return nullptr;
    }

    state->type_HidNumericControl = py::register_python_type(module.get(), type_name_HidNumericControl, &type_spec_HidNumericControl, bases.get(), nullptr);
    if (!state->type_HidNumericControl)
    {
        return nullptr;
    }

    state->type_HidNumericControlDescription = py::register_python_type(module.get(), type_name_HidNumericControlDescription, &type_spec_HidNumericControlDescription, bases.get(), nullptr);
    if (!state->type_HidNumericControlDescription)
    {
        return nullptr;
    }

    state->type_HidOutputReport = py::register_python_type(module.get(), type_name_HidOutputReport, &type_spec_HidOutputReport, bases.get(), nullptr);
    if (!state->type_HidOutputReport)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidCollectionType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidCollectionType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidCollectionType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::HumanInterfaceDevice::HidReportType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidReportType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidReportType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidBooleanControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidBooleanControlDescription;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidBooleanControlDescription is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidFeatureReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidFeatureReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidInputReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidInputReport is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidInputReportReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidInputReportReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidNumericControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidNumericControlDescription;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidNumericControlDescription is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::HumanInterfaceDevice;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::HumanInterfaceDevice");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HidOutputReport;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::HumanInterfaceDevice::HidOutputReport is not registered");
        return nullptr;
    }

    return python_type;
}
