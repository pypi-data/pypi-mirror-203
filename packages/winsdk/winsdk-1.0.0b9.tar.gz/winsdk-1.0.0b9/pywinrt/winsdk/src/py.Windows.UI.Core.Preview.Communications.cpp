// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.9

#include "pybase.h"
#include "py.Windows.UI.Core.Preview.Communications.h"


namespace py::cpp::Windows::UI::Core::Preview::Communications
{
    struct module_state
    {
        PyObject* type_PreviewMeetingInfoDisplayKind;
        PyObject* type_PreviewSystemState;
        PyObject* type_PreviewTeamEndMeetingKind;
        PyObject* type_PreviewTeamViewCommand;
        PyTypeObject* type_PreviewTeamCleanupRequestedEventArgs;
        PyTypeObject* type_PreviewTeamCommandInvokedEventArgs;
        PyTypeObject* type_PreviewTeamDeviceCredentials;
        PyTypeObject* type_PreviewTeamEndMeetingRequestedEventArgs;
        PyTypeObject* type_PreviewTeamJoinMeetingRequestedEventArgs;
        PyTypeObject* type_PreviewTeamView;
    };

    static PyObject* register_PreviewMeetingInfoDisplayKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PreviewMeetingInfoDisplayKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PreviewMeetingInfoDisplayKind = type;
        Py_INCREF(state->type_PreviewMeetingInfoDisplayKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PreviewSystemState(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PreviewSystemState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PreviewSystemState = type;
        Py_INCREF(state->type_PreviewSystemState);


        Py_RETURN_NONE;
    }

    static PyObject* register_PreviewTeamEndMeetingKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PreviewTeamEndMeetingKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PreviewTeamEndMeetingKind = type;
        Py_INCREF(state->type_PreviewTeamEndMeetingKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_PreviewTeamViewCommand(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PreviewTeamViewCommand)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PreviewTeamViewCommand = type;
        Py_INCREF(state->type_PreviewTeamViewCommand);


        Py_RETURN_NONE;
    }

    // ----- PreviewTeamCleanupRequestedEventArgs class --------------------
    static constexpr const char* const type_name_PreviewTeamCleanupRequestedEventArgs = "PreviewTeamCleanupRequestedEventArgs";

    static PyObject* _new_PreviewTeamCleanupRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PreviewTeamCleanupRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PreviewTeamCleanupRequestedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamCleanupRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamCleanupRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamCleanupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamCleanupRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamCleanupRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PreviewTeamCleanupRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamCleanupRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamCleanupRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamCleanupRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamCleanupRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamCleanupRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamCleanupRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamCleanupRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamCleanupRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PreviewTeamCleanupRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Core_Preview_Communications.PreviewTeamCleanupRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamCleanupRequestedEventArgs
    };

    // ----- PreviewTeamCommandInvokedEventArgs class --------------------
    static constexpr const char* const type_name_PreviewTeamCommandInvokedEventArgs = "PreviewTeamCommandInvokedEventArgs";

    static PyObject* _new_PreviewTeamCommandInvokedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PreviewTeamCommandInvokedEventArgs);
        return nullptr;
    }

    static void _dealloc_PreviewTeamCommandInvokedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamCommandInvokedEventArgs_get_Command(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamCommandInvokedEventArgs", L"Command"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamCommandInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamCommandInvokedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamCommandInvokedEventArgs[] = {
        { "_assign_array_", _assign_array_PreviewTeamCommandInvokedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamCommandInvokedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamCommandInvokedEventArgs[] = {
        { "command", reinterpret_cast<getter>(PreviewTeamCommandInvokedEventArgs_get_Command), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamCommandInvokedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamCommandInvokedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamCommandInvokedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamCommandInvokedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamCommandInvokedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PreviewTeamCommandInvokedEventArgs =
    {
        "_winsdk_Windows_UI_Core_Preview_Communications.PreviewTeamCommandInvokedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamCommandInvokedEventArgs
    };

    // ----- PreviewTeamDeviceCredentials class --------------------
    static constexpr const char* const type_name_PreviewTeamDeviceCredentials = "PreviewTeamDeviceCredentials";

    static PyObject* _new_PreviewTeamDeviceCredentials(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PreviewTeamDeviceCredentials(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamDeviceCredentials_get_DomainUserName(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamDeviceCredentials", L"DomainUserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DomainUserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamDeviceCredentials_get_Password(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamDeviceCredentials", L"Password"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamDeviceCredentials_get_UserPrincipalName(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamDeviceCredentials", L"UserPrincipalName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserPrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamDeviceCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamDeviceCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamDeviceCredentials[] = {
        { "_assign_array_", _assign_array_PreviewTeamDeviceCredentials, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamDeviceCredentials), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamDeviceCredentials[] = {
        { "domain_user_name", reinterpret_cast<getter>(PreviewTeamDeviceCredentials_get_DomainUserName), nullptr, nullptr, nullptr },
        { "password", reinterpret_cast<getter>(PreviewTeamDeviceCredentials_get_Password), nullptr, nullptr, nullptr },
        { "user_principal_name", reinterpret_cast<getter>(PreviewTeamDeviceCredentials_get_UserPrincipalName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamDeviceCredentials[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamDeviceCredentials) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamDeviceCredentials) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamDeviceCredentials) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamDeviceCredentials) },
        { },
    };

    static PyType_Spec type_spec_PreviewTeamDeviceCredentials =
    {
        "_winsdk_Windows_UI_Core_Preview_Communications.PreviewTeamDeviceCredentials",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamDeviceCredentials
    };

    // ----- PreviewTeamEndMeetingRequestedEventArgs class --------------------
    static constexpr const char* const type_name_PreviewTeamEndMeetingRequestedEventArgs = "PreviewTeamEndMeetingRequestedEventArgs";

    static PyObject* _new_PreviewTeamEndMeetingRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PreviewTeamEndMeetingRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PreviewTeamEndMeetingRequestedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamEndMeetingRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamEndMeetingRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamEndMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamEndMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamEndMeetingRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PreviewTeamEndMeetingRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamEndMeetingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamEndMeetingRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamEndMeetingRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamEndMeetingRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamEndMeetingRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamEndMeetingRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamEndMeetingRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamEndMeetingRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PreviewTeamEndMeetingRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Core_Preview_Communications.PreviewTeamEndMeetingRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamEndMeetingRequestedEventArgs
    };

    // ----- PreviewTeamJoinMeetingRequestedEventArgs class --------------------
    static constexpr const char* const type_name_PreviewTeamJoinMeetingRequestedEventArgs = "PreviewTeamJoinMeetingRequestedEventArgs";

    static PyObject* _new_PreviewTeamJoinMeetingRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PreviewTeamJoinMeetingRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PreviewTeamJoinMeetingRequestedEventArgs(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamJoinMeetingRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamJoinMeetingRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamJoinMeetingRequestedEventArgs_get_MeetingUri(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamJoinMeetingRequestedEventArgs", L"MeetingUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MeetingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamJoinMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamJoinMeetingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamJoinMeetingRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(PreviewTeamJoinMeetingRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamJoinMeetingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamJoinMeetingRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamJoinMeetingRequestedEventArgs[] = {
        { "meeting_uri", reinterpret_cast<getter>(PreviewTeamJoinMeetingRequestedEventArgs_get_MeetingUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamJoinMeetingRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamJoinMeetingRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamJoinMeetingRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamJoinMeetingRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamJoinMeetingRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_PreviewTeamJoinMeetingRequestedEventArgs =
    {
        "_winsdk_Windows_UI_Core_Preview_Communications.PreviewTeamJoinMeetingRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamJoinMeetingRequestedEventArgs
    };

    // ----- PreviewTeamView class --------------------
    static constexpr const char* const type_name_PreviewTeamView = "PreviewTeamView";

    static PyObject* _new_PreviewTeamView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PreviewTeamView);
        return nullptr;
    }

    static void _dealloc_PreviewTeamView(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PreviewTeamView_EnterFullScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"EnterFullScreen", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.EnterFullScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"GetForCurrentView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_JoinMeetingWithUri(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"JoinMeetingWithUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.JoinMeetingWithUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_LeaveFullScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"LeaveFullScreen", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.LeaveFullScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_NotifyMeetingEnded(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"NotifyMeetingEnded", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingKind>(args, 0);

                self->obj.NotifyMeetingEnded(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_RequestForeground(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"RequestForeground", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RequestForeground();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_SetButtonLabel(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SetButtonLabel", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetButtonLabel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_SetTitle(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SetTitle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetTitle(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_StartSharingScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"StartSharingScreen", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartSharingScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_StopSharingScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"StopSharingScreen", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopSharingScreen();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_IsFullScreen(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsFullScreen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFullScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_IsScreenSharing(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsScreenSharing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScreenSharing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_MeetingInfoDisplayType(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"MeetingInfoDisplayType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MeetingInfoDisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_MeetingUri(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"MeetingUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MeetingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_SharingScreenBounds(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SharingScreenBounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SharingScreenBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_get_SystemState(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SystemState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_CleanupRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CleanupRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>>(arg);

            return py::convert(self->obj.CleanupRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_CleanupRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CleanupRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CleanupRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_CommandInvoked(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CommandInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>>(arg);

            return py::convert(self->obj.CommandInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_CommandInvoked(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"CommandInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_EndMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"EndMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>>(arg);

            return py::convert(self->obj.EndMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_EndMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"EndMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_IsFullScreenChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsFullScreenChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsFullScreenChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_IsFullScreenChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsFullScreenChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsFullScreenChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_IsScreenSharingChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsScreenSharingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsScreenSharingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_IsScreenSharingChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"IsScreenSharingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsScreenSharingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_JoinMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"JoinMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>>(arg);

            return py::convert(self->obj.JoinMeetingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_JoinMeetingRequested(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"JoinMeetingRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.JoinMeetingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_SharingScreenBoundsChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SharingScreenBoundsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SharingScreenBoundsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_SharingScreenBoundsChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SharingScreenBoundsChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SharingScreenBoundsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_add_SystemStateChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SystemStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SystemStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PreviewTeamView_remove_SystemStateChanged(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Core.Preview.Communications.PreviewTeamView", L"SystemStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PreviewTeamView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PreviewTeamView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PreviewTeamView[] = {
        { "enter_full_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_EnterFullScreen), METH_VARARGS, nullptr },
        { "get_for_current_view", reinterpret_cast<PyCFunction>(PreviewTeamView_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "join_meeting_with_uri", reinterpret_cast<PyCFunction>(PreviewTeamView_JoinMeetingWithUri), METH_VARARGS, nullptr },
        { "leave_full_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_LeaveFullScreen), METH_VARARGS, nullptr },
        { "notify_meeting_ended", reinterpret_cast<PyCFunction>(PreviewTeamView_NotifyMeetingEnded), METH_VARARGS, nullptr },
        { "request_foreground", reinterpret_cast<PyCFunction>(PreviewTeamView_RequestForeground), METH_VARARGS, nullptr },
        { "set_button_label", reinterpret_cast<PyCFunction>(PreviewTeamView_SetButtonLabel), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(PreviewTeamView_SetTitle), METH_VARARGS, nullptr },
        { "start_sharing_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_StartSharingScreen), METH_VARARGS, nullptr },
        { "stop_sharing_screen", reinterpret_cast<PyCFunction>(PreviewTeamView_StopSharingScreen), METH_VARARGS, nullptr },
        { "add_cleanup_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_add_CleanupRequested), METH_O, nullptr },
        { "remove_cleanup_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_CleanupRequested), METH_O, nullptr },
        { "add_command_invoked", reinterpret_cast<PyCFunction>(PreviewTeamView_add_CommandInvoked), METH_O, nullptr },
        { "remove_command_invoked", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_CommandInvoked), METH_O, nullptr },
        { "add_end_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_add_EndMeetingRequested), METH_O, nullptr },
        { "remove_end_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_EndMeetingRequested), METH_O, nullptr },
        { "add_is_full_screen_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_IsFullScreenChanged), METH_O, nullptr },
        { "remove_is_full_screen_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_IsFullScreenChanged), METH_O, nullptr },
        { "add_is_screen_sharing_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_IsScreenSharingChanged), METH_O, nullptr },
        { "remove_is_screen_sharing_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_IsScreenSharingChanged), METH_O, nullptr },
        { "add_join_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_add_JoinMeetingRequested), METH_O, nullptr },
        { "remove_join_meeting_requested", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_JoinMeetingRequested), METH_O, nullptr },
        { "add_sharing_screen_bounds_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_SharingScreenBoundsChanged), METH_O, nullptr },
        { "remove_sharing_screen_bounds_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_SharingScreenBoundsChanged), METH_O, nullptr },
        { "add_system_state_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_add_SystemStateChanged), METH_O, nullptr },
        { "remove_system_state_changed", reinterpret_cast<PyCFunction>(PreviewTeamView_remove_SystemStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PreviewTeamView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PreviewTeamView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PreviewTeamView[] = {
        { "is_full_screen", reinterpret_cast<getter>(PreviewTeamView_get_IsFullScreen), nullptr, nullptr, nullptr },
        { "is_screen_sharing", reinterpret_cast<getter>(PreviewTeamView_get_IsScreenSharing), nullptr, nullptr, nullptr },
        { "meeting_info_display_type", reinterpret_cast<getter>(PreviewTeamView_get_MeetingInfoDisplayType), nullptr, nullptr, nullptr },
        { "meeting_uri", reinterpret_cast<getter>(PreviewTeamView_get_MeetingUri), nullptr, nullptr, nullptr },
        { "sharing_screen_bounds", reinterpret_cast<getter>(PreviewTeamView_get_SharingScreenBounds), nullptr, nullptr, nullptr },
        { "system_state", reinterpret_cast<getter>(PreviewTeamView_get_SystemState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PreviewTeamView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PreviewTeamView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PreviewTeamView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PreviewTeamView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PreviewTeamView) },
        { },
    };

    static PyType_Spec type_spec_PreviewTeamView =
    {
        "_winsdk_Windows_UI_Core_Preview_Communications.PreviewTeamView",
        sizeof(py::wrapper::Windows::UI::Core::Preview::Communications::PreviewTeamView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PreviewTeamView
    };

    // ----- Windows.UI.Core.Preview.Communications Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Core::Preview::Communications");

    static PyMethodDef module_methods[] = {
        {"_register_PreviewMeetingInfoDisplayKind", register_PreviewMeetingInfoDisplayKind, METH_O, "registers type"},
        {"_register_PreviewSystemState", register_PreviewSystemState, METH_O, "registers type"},
        {"_register_PreviewTeamEndMeetingKind", register_PreviewTeamEndMeetingKind, METH_O, "registers type"},
        {"_register_PreviewTeamViewCommand", register_PreviewTeamViewCommand, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PreviewMeetingInfoDisplayKind);
        Py_VISIT(state->type_PreviewSystemState);
        Py_VISIT(state->type_PreviewTeamEndMeetingKind);
        Py_VISIT(state->type_PreviewTeamViewCommand);
        Py_VISIT(state->type_PreviewTeamCleanupRequestedEventArgs);
        Py_VISIT(state->type_PreviewTeamCommandInvokedEventArgs);
        Py_VISIT(state->type_PreviewTeamDeviceCredentials);
        Py_VISIT(state->type_PreviewTeamEndMeetingRequestedEventArgs);
        Py_VISIT(state->type_PreviewTeamJoinMeetingRequestedEventArgs);
        Py_VISIT(state->type_PreviewTeamView);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PreviewMeetingInfoDisplayKind);
        Py_CLEAR(state->type_PreviewSystemState);
        Py_CLEAR(state->type_PreviewTeamEndMeetingKind);
        Py_CLEAR(state->type_PreviewTeamViewCommand);
        Py_CLEAR(state->type_PreviewTeamCleanupRequestedEventArgs);
        Py_CLEAR(state->type_PreviewTeamCommandInvokedEventArgs);
        Py_CLEAR(state->type_PreviewTeamDeviceCredentials);
        Py_CLEAR(state->type_PreviewTeamEndMeetingRequestedEventArgs);
        Py_CLEAR(state->type_PreviewTeamJoinMeetingRequestedEventArgs);
        Py_CLEAR(state->type_PreviewTeamView);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Core_Preview_Communications",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Core::Preview::Communications

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_Core_Preview_Communications(void) noexcept
{
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_PreviewTeamCleanupRequestedEventArgs = py::register_python_type(module.get(), type_name_PreviewTeamCleanupRequestedEventArgs, &type_spec_PreviewTeamCleanupRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_PreviewTeamCleanupRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_PreviewTeamCommandInvokedEventArgs = py::register_python_type(module.get(), type_name_PreviewTeamCommandInvokedEventArgs, &type_spec_PreviewTeamCommandInvokedEventArgs, bases.get(), nullptr);
    if (!state->type_PreviewTeamCommandInvokedEventArgs)
    {
        return nullptr;
    }

    state->type_PreviewTeamDeviceCredentials = py::register_python_type(module.get(), type_name_PreviewTeamDeviceCredentials, &type_spec_PreviewTeamDeviceCredentials, bases.get(), nullptr);
    if (!state->type_PreviewTeamDeviceCredentials)
    {
        return nullptr;
    }

    state->type_PreviewTeamEndMeetingRequestedEventArgs = py::register_python_type(module.get(), type_name_PreviewTeamEndMeetingRequestedEventArgs, &type_spec_PreviewTeamEndMeetingRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_PreviewTeamEndMeetingRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_PreviewTeamJoinMeetingRequestedEventArgs = py::register_python_type(module.get(), type_name_PreviewTeamJoinMeetingRequestedEventArgs, &type_spec_PreviewTeamJoinMeetingRequestedEventArgs, bases.get(), nullptr);
    if (!state->type_PreviewTeamJoinMeetingRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_PreviewTeamView = py::register_python_type(module.get(), type_name_PreviewTeamView, &type_spec_PreviewTeamView, bases.get(), nullptr);
    if (!state->type_PreviewTeamView)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewMeetingInfoDisplayKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewMeetingInfoDisplayKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewMeetingInfoDisplayKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewSystemState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewSystemState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewSystemState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamEndMeetingKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamViewCommand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamViewCommand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamViewCommand is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamCleanupRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCleanupRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamCommandInvokedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamCommandInvokedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamDeviceCredentials;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamDeviceCredentials is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamEndMeetingRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamEndMeetingRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamJoinMeetingRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamJoinMeetingRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Core::Preview::Communications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Core::Preview::Communications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PreviewTeamView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Core::Preview::Communications::PreviewTeamView is not registered");
        return nullptr;
    }

    return python_type;
}
