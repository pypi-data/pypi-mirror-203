# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['kernel_sidecar', 'kernel_sidecar.handlers', 'kernel_sidecar.models']

package_data = \
{'': ['*']}

install_requires = \
['jupyter-client>=7.3.4', 'pydantic>=1.10.4,<2.0.0']

extras_require = \
{'cli': ['structlog', 'typer']}

entry_points = \
{'console_scripts': ['sidecar = kernel_sidecar.cli:app']}

setup_kwargs = {
    'name': 'kernel-sidecar',
    'version': '0.5.2',
    'description': 'A sidecar ',
    'long_description': '<p align="center">\nKernel Sidecar\n</p>\n\n<p align="center">\n<img alt="Pypi" src="https://img.shields.io/pypi/v/kernel-sidecar">\n<a href="https://github.com/kafonek/kernel-sidecar/actions/workflows/tests.yaml">\n    <img src="https://github.com/kafonek/kernel-sidecar/actions/workflows/tests.yaml/badge.svg" alt="Tests" />\n</a>\n<img alt="Python versions" src="https://img.shields.io/pypi/pyversions/kernel-sidecar">\n</p>\n\n# Kernel-Sidecar\n\nThis package offers the building blocks for creating a "Kernel Sidecar" Jupyter framework. In normal Jupyter Notebook architecture, one or many frontends manage the document model (code cells, outputs, metadata, etc) and send requests to a single Kernel. Each frontend observes responses on different ZMQ channels (`iopub`, `shell`, etc) but may end up with some inconsistency based on the Kernel only sending certain responses to the client that made the request.\n\nIn a `kernel-sidecar` architecture, all frontend clients talk to the `kernel-sidecar` client, and only the `kernel-sidecar` client communicates with the Kernel over ZMQ. That pattern offers several potential features:\n - Keep a document model within `kernel-sidecar` or the backend architecture\n - Add "extension"-esque capabilities on the backend such as auto-linting code on execute\n - Eliminate inconsistencies in what messages individual frontends receive because of Kernel replies\n - Model all requests, replies, and the Notebook document with Pydantic\n\n## Installation\n\n```bash\npip install kernel-sidecar\n```\n\n# Key Concepts\n## KernelSidecarClient\n\nA manager that uses `jupyter_client` under the hood to create ZMQ connections and watch for messages coming in over different ZMQ channels (`iopub`, `shell`, etc. An important assumption here is that `kernel-sidecar` is the only client talking to the Kernel, which means every message observed coming from the Kernel should be a reply (based on `parent_header_msg.msg_id`) to a request sent from this client.\n\nWhen the `KernelSidecarClient` send a request to the Kernel, it is wrapped in an `KernelAction` class. Every message received from the Kernel is delegated to the requesting Action and triggers callbacks attached to the Action class.\n\n## Actions\n\nActions in `kernel-sidecar` encompass a request-reply cycle, including an `await action` syntax, where the Action is complete when the Kernel has reported its status returning to `idle` and optionally emitted a reply appropriate for the request. For instance, an `execute_request` is "done" when the `status` has been reported as `idle` *and* the Kernel has emitted an `execute_reply`, both with the `parent_header_msg.msg_id` the same as the `execute_request` `header.msg_id`.\n\nIn a nutshell, an `actions.KernelAction` takes in a `requests.Request` and zero-to-many `handlers.Handler` subclasses (or just `async functions`) and creates an `awaitable` instance. `kernel.send(action)` submits the Request over ZMQ, and registers the Action so that all observed messages get routed to that Action to be handled by the Handlers/callbacks.\n\nMost of the time, you should be able to just use convience functions in the `KernelSidecarClient` class to create the actions. See `tests/test_actions.py` for many examples of using Actions and Handlers.\n\n## Handlers\n\nWhen the `KernelSidecarClient` receives a message over ZMQ, parses it into a Pydantic model, and delegates it to the appropriate `Action` to be handled, it passes on that message to every `Handler` attached to the `Action` and awaits all of them to handle that message. `Handler` objects can define handling different message types by creating methods `handle_<msg_type>`. See `handlers.DebugHandler` or `cli.OutputHandler` for examples of custom Handlers.\n\n## Comms\n\nComms are a flexible way for a client and the Kernel to send messages outside of the `execute_request` format. The most widely used package that utilizes Comms is probably `ipywidgets`, but Comms in general are a very powerful tool for a Sidecar application. A Comm can be opened by either the Sidecar or the Kernel. A target for that Comm should be registered on the other side before the open happens. It\'s probably most typical to register a Comm target in the Kernel by sending an `execute_request`, then sending a `comm_open` from the Sidecar side. See `tests/test_comms.py` for examples.\n\nOnce a Comm is open, it has a unique `comm_id`. `KernelSidecarClient` will automatically route all `comm_msg` messages to a `CommHandler` instance by `comm_id` in the `comm_msg` content. That routing pattern is a bit confusing as it overlaps the `Handler` / `Action` pattern, but it\'s necessary because `comm_msg` can come in as a result of `execute_request`\'s or `comm_msg`\'s or potentially other messages. So the `CommManager` -> `CommHandler` routing basically needs to be applied to every message the `KernelSidecarClient` receives over ZMQ.\n\n\n## Models\n\n`kernel-sidecar` has Pydantic models for:\n - The Jupyter Notebook document (`models/notebook.py`), which should be consistent with `nbformat` parsing / structure\n - Request messages sent to the Kernel over ZMQ (`models/requests.py`)\n - Messages received over ZMQ from the Kernel (`models/messages.py`)\n\n\n## CLI\n\n`kernel-sidecar` ships a small CLI for testing a connection to a Kernel.\n\n```bash\nâ¯ sidecar --help\nUsage: sidecar [OPTIONS]\n\nOptions:\n  -f FILE                         Kernel connection file  [required]\n  --debug / --no-debug            Turn on DEBUG logging  [default: no-debug]\n  --execute TEXT                  Execute code string instead of sending\n                                  kernel info request\n  --tail / --no-tail              Continue tailing ZMQ after connecting or\n                                  executing code  [default: no-tail]\n  --install-completion [bash|zsh|fish|powershell|pwsh]\n                                  Install completion for the specified shell.\n  --show-completion [bash|zsh|fish|powershell|pwsh]\n                                  Show completion for the specified shell, to\n                                  copy it or customize the installation.\n  --help                          Show this message and exit.\n```\n\nTry it out by starting an IPython kernel in one terminal and using the CLI in another.\n\n```bash\npython -m ipykernel_launcher --debug -f /tmp/kernel.json\n```\n\n```bash\nkernel-sidecar on \ue0a0 release-0.3.2 [$?] is ðŸ“¦ v0.3.1 via ðŸ v3.11.0 (kernel-sidecar-py3.11) \nâ¯ sidecar -f /tmp/kernel.json\n2023-03-10T14:31:59.992235Z [info     ] Attempting to connect:\n{\'control_port\': 34897,\n \'hb_port\': 49821,\n \'iopub_port\': 40577,\n \'ip\': \'127.0.0.1\',\n \'kernel_name\': \'\',\n \'key\': \'615bcebc-baf2e28abad1f6c017dc71dc\',\n \'shell_port\': 37421,\n \'signature_scheme\': \'hmac-sha256\',\n \'stdin_port\': 41405,\n \'transport\': \'tcp\'} [kernel_sidecar.cli] filename=cli.py func_name=main lineno=62\n2023-03-10T14:32:00.026503Z [info     ] {\'banner\': \'Python 3.11.0 (main, Nov  7 2022, 09:38:45) [GCC 9.4.0]\\n\'\n           "Type \'copyright\', \'credits\' or \'license\' for more information\\n"\n           "IPython 8.10.0 -- An enhanced Interactive Python. Type \'?\' for "\n           \'help.\\n\',\n \'debugger\': None,\n \'help_links\': [{\'text\': \'Python Reference\',\n                 \'url\': \'https://docs.python.org/3.11\'},\n                {\'text\': \'IPython Reference\',\n                 \'url\': \'https://ipython.org/documentation.html\'},\n                {\'text\': \'NumPy Reference\',\n                 \'url\': \'https://docs.scipy.org/doc/numpy/reference/\'},\n                {\'text\': \'SciPy Reference\',\n                 \'url\': \'https://docs.scipy.org/doc/scipy/reference/\'},\n                {\'text\': \'Matplotlib Reference\',\n                 \'url\': \'https://matplotlib.org/contents.html\'},\n                {\'text\': \'SymPy Reference\',\n                 \'url\': \'http://docs.sympy.org/latest/index.html\'},\n                {\'text\': \'pandas Reference\',\n                 \'url\': \'https://pandas.pydata.org/pandas-docs/stable/\'}],\n \'implementation\': \'ipython\',\n \'implementation_version\': \'8.10.0\',\n \'language_info\': {\'codemirror_mode\': {\'name\': \'ipython\', \'version\': 3},\n                   \'file_extension\': \'.py\',\n                   \'mimetype\': \'text/x-python\',\n                   \'name\': \'python\',\n                   \'nbconvert_exporter\': \'python\',\n                   \'pygments_lexer\': \'ipython3\',\n                   \'version\': \'3.11.0\'},\n \'protocol_version\': \'5.3\',\n \'status\': \'ok\'} [kernel_sidecar.cli] filename=cli.py func_name=connect lineno=44\n```\n\n```bash\nâ¯ sidecar -f /tmp/kernel.json --execute "print(\'Hello, World\'); 1/0"\n2023-03-10T14:33:27.394935Z [info     ] Attempting to connect:\n{\'control_port\': 34897,\n \'hb_port\': 49821,\n \'iopub_port\': 40577,\n \'ip\': \'127.0.0.1\',\n \'kernel_name\': \'\',\n \'key\': \'615bcebc-baf2e28abad1f6c017dc71dc\',\n \'shell_port\': 37421,\n \'signature_scheme\': \'hmac-sha256\',\n \'stdin_port\': 41405,\n \'transport\': \'tcp\'} [kernel_sidecar.cli] filename=cli.py func_name=main lineno=62\n2023-03-10T14:33:27.629630Z [info     ] Hello, World\n                  [kernel_sidecar.cli] filename=cli.py func_name=handle_stream lineno=23\n2023-03-10T14:33:27.702700Z [error    ] division by zero               [kernel_sidecar.cli] filename=cli.py func_name=handle_error lineno=31\n```\n',
    'author': 'Matt Kafonek',
    'author_email': 'matt.kafonek@noteable.io',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/kafonek/kernel-sidecar',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'entry_points': entry_points,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
