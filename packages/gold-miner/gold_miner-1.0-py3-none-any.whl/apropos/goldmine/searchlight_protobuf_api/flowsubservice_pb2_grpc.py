# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import apropos.goldmine.searchlight_protobuf_api.flowsubservice_pb2 as flowsubservice__pb2


class FlowSubscriptionServiceStub(object):
    """Define the Flow Subscription API service / methods

    TODO:
    - Here I've put all service methods in 1 separate file; could distribute among object files?

    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetVersion = channel.unary_unary(
            "/flowapi.FlowSubscriptionService/GetVersion",
            request_serializer=flowsubservice__pb2.GetVersionRequest.SerializeToString,
            response_deserializer=flowsubservice__pb2.GetVersionResponse.FromString,
        )
        self.Subscribe = channel.unary_unary(
            "/flowapi.FlowSubscriptionService/Subscribe",
            request_serializer=flowsubservice__pb2.SubscribeRequest.SerializeToString,
            response_deserializer=flowsubservice__pb2.SubscribeResponse.FromString,
        )
        self.GetMatchingFlows = channel.unary_stream(
            "/flowapi.FlowSubscriptionService/GetMatchingFlows",
            request_serializer=flowsubservice__pb2.GetMatchingFlowsRequest.SerializeToString,
            response_deserializer=flowsubservice__pb2.GetMatchingFlowsResponse.FromString,
        )


class FlowSubscriptionServiceServicer(object):
    """Define the Flow Subscription API service / methods

    TODO:
    - Here I've put all service methods in 1 separate file; could distribute among object files?

    """

    def GetVersion(self, request, context):
        """Used to check the identity and version of an endpoint
        Can also be used to find the proper contact point and alternate contact points.
        Should not require any state / knowledge of the client.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details("Method not implemented!")
        raise NotImplementedError("Method not implemented!")

    def Subscribe(self, request, context):
        """Aka CreateSubscription. This is how TA2 asks for flows that match some kind of pattern.
        The method is synchronous (immediate return), with matching flows returned later over time (see GetMatchingFlows).
        Note that multiple Subscriptions may overlap.
        Two calls to Subscribe with the same Subscribe request (containing a SubscriptionSpec)
        will produce two identical subscriptions with distinct IDs. It is the caller's responsibility to avoid this if desired.
        Subscriptions are immutable; once created, its definition does not change.
        A new subscription is required (with a new ID) to vary any SubscriptionSpec details.
        Subscriptions are specific to a given client.
        The server should never send subscription information to a different client
        Note: A given TA1 implementation may fail to create a Subscription for any number of reasons
        - (lack of resources, failure to parse the SubscriptionSpec, a SubscriptionSpec uses an ApplicationClass
        that uses an unrecognized Label, etc).
        - If this happens, it fails the call to Subscribe with an appropriate error message.
        - System operators (generating and using operator intent) may need to create an operator intent
        whose content or complexity is known to work with the configured TA1 instance.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details("Method not implemented!")
        raise NotImplementedError("Method not implemented!")

    def GetMatchingFlows(self, request, context):
        """Postponed to APIv2
        // Remove this subscription from the set of things looked for / from the labels to report on Flows.
        // Any flows that no longer match any current subscriptions should no longer be tracked/reported.
        // Path information only relevant to this Subscription is no longer interesting, and may no longer be tracked.
        // If the given ID is not known, an appropriate error code is returned.
        // Synchronous method (return is immediate).
        // Note: You cannot change an existing subscription; you must create a new one. But see BulkChangeSubscriptions
        rpc Unsubscribe(UnsubscribeRequest) returns (UnsubscribeResponse) {};

        This specific client is requesting a stream of all Flows that match any current Subscription issued by this client.
        Each time a Flow is found to newly match one or more Subscriptions (with a score meeting the threshold), that Flow object is sent over this stream.
        Each time an attribute on the Flow has a new value (subject to score sensitivity rules), that Flow object is sent over this stream.
        The time interval between Flow objects on the stream is unspecified; keep-alive and timeout values should be set to keep this stream open
        Note that the Flow traffic itself may have started or even finished some time before the server reports the Flow on this stream, depending on server processing time.
        As noted above, each "Flow" may in fact be a group or class of flows (if the identifying FlowNTuple is not specific to a single flow)
        Both client and server should check stream liveness
        The client may re-open the stream if timeouts expire.
        If there are no current subscriptions or no Flows that match any current Subscription, then no Flow objects will be sent on the stream
        If a Flow is reported with a SubscriptionID unknown to the client then that is a server error, or sign that the client lost state; the client should call Unsubscribe(<the unknown ID>) to re-sync state
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details("Method not implemented!")
        raise NotImplementedError("Method not implemented!")


def add_FlowSubscriptionServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
        "GetVersion": grpc.unary_unary_rpc_method_handler(
            servicer.GetVersion,
            request_deserializer=flowsubservice__pb2.GetVersionRequest.FromString,
            response_serializer=flowsubservice__pb2.GetVersionResponse.SerializeToString,
        ),
        "Subscribe": grpc.unary_unary_rpc_method_handler(
            servicer.Subscribe,
            request_deserializer=flowsubservice__pb2.SubscribeRequest.FromString,
            response_serializer=flowsubservice__pb2.SubscribeResponse.SerializeToString,
        ),
        "GetMatchingFlows": grpc.unary_stream_rpc_method_handler(
            servicer.GetMatchingFlows,
            request_deserializer=flowsubservice__pb2.GetMatchingFlowsRequest.FromString,
            response_serializer=flowsubservice__pb2.GetMatchingFlowsResponse.SerializeToString,
        ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
        "flowapi.FlowSubscriptionService", rpc_method_handlers
    )
    server.add_generic_rpc_handlers((generic_handler,))


# This class is part of an EXPERIMENTAL API.
class FlowSubscriptionService(object):
    """Define the Flow Subscription API service / methods

    TODO:
    - Here I've put all service methods in 1 separate file; could distribute among object files?

    """

    @staticmethod
    def GetVersion(
        request,
        target,
        options=(),
        channel_credentials=None,
        call_credentials=None,
        insecure=False,
        compression=None,
        wait_for_ready=None,
        timeout=None,
        metadata=None,
    ):
        return grpc.experimental.unary_unary(
            request,
            target,
            "/flowapi.FlowSubscriptionService/GetVersion",
            flowsubservice__pb2.GetVersionRequest.SerializeToString,
            flowsubservice__pb2.GetVersionResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
        )

    @staticmethod
    def Subscribe(
        request,
        target,
        options=(),
        channel_credentials=None,
        call_credentials=None,
        insecure=False,
        compression=None,
        wait_for_ready=None,
        timeout=None,
        metadata=None,
    ):
        return grpc.experimental.unary_unary(
            request,
            target,
            "/flowapi.FlowSubscriptionService/Subscribe",
            flowsubservice__pb2.SubscribeRequest.SerializeToString,
            flowsubservice__pb2.SubscribeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
        )

    @staticmethod
    def GetMatchingFlows(
        request,
        target,
        options=(),
        channel_credentials=None,
        call_credentials=None,
        insecure=False,
        compression=None,
        wait_for_ready=None,
        timeout=None,
        metadata=None,
    ):
        return grpc.experimental.unary_stream(
            request,
            target,
            "/flowapi.FlowSubscriptionService/GetMatchingFlows",
            flowsubservice__pb2.GetMatchingFlowsRequest.SerializeToString,
            flowsubservice__pb2.GetMatchingFlowsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
        )
